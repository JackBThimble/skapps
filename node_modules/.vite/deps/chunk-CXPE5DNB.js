// node_modules/zimmerframe/src/walk.js
function walk(node, state, visitors) {
  const universal = visitors._;
  let stopped = false;
  function default_visitor(_, { next, state: state2 }) {
    next(state2);
  }
  function visit(node2, path, state2) {
    if (stopped) return;
    if (!node2.type) return;
    let result;
    const mutations = {};
    const context = {
      path,
      state: state2,
      next: (next_state = state2) => {
        path.push(node2);
        for (const key in node2) {
          if (key === "type") continue;
          const child_node = node2[key];
          if (child_node && typeof child_node === "object") {
            if (Array.isArray(child_node)) {
              const array_mutations = {};
              child_node.forEach((node3, i) => {
                if (node3 && typeof node3 === "object") {
                  const result2 = visit(node3, path, next_state);
                  if (result2) array_mutations[i] = result2;
                }
              });
              if (Object.keys(array_mutations).length > 0) {
                mutations[key] = child_node.map(
                  (node3, i) => array_mutations[i] ?? node3
                );
              }
            } else {
              const result2 = visit(
                /** @type {T} */
                child_node,
                path,
                next_state
              );
              if (result2) {
                mutations[key] = result2;
              }
            }
          }
        }
        path.pop();
        if (Object.keys(mutations).length > 0) {
          return apply_mutations(node2, mutations);
        }
      },
      stop: () => {
        stopped = true;
      },
      visit: (next_node, next_state = state2) => {
        path.push(node2);
        const result2 = visit(next_node, path, next_state) ?? next_node;
        path.pop();
        return result2;
      }
    };
    let visitor = (
      /** @type {import('./types').Visitor<T, U, T>} */
      visitors[
        /** @type {T['type']} */
        node2.type
      ] ?? default_visitor
    );
    if (universal) {
      let inner_result;
      result = universal(node2, {
        ...context,
        /** @param {U} next_state */
        next: (next_state = state2) => {
          state2 = next_state;
          inner_result = visitor(node2, {
            ...context,
            state: next_state
          });
          return inner_result;
        }
      });
      if (!result && inner_result) {
        result = inner_result;
      }
    } else {
      result = visitor(node2, context);
    }
    if (!result) {
      if (Object.keys(mutations).length > 0) {
        result = apply_mutations(node2, mutations);
      }
    }
    if (result) {
      return result;
    }
  }
  return visit(node, [], state) ?? node;
}
function apply_mutations(node, mutations) {
  const obj = {};
  const descriptors = Object.getOwnPropertyDescriptors(node);
  for (const key in descriptors) {
    Object.defineProperty(obj, key, descriptors[key]);
  }
  for (const key in mutations) {
    obj[key] = mutations[key];
  }
  return (
    /** @type {T} */
    obj
  );
}

export {
  walk
};
//# sourceMappingURL=chunk-CXPE5DNB.js.map
