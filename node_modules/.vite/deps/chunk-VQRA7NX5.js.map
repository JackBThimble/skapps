{
  "version": 3,
  "sources": ["../../@sveltejs/acorn-typescript/index.js"],
  "sourcesContent": ["// src/index.ts\nimport * as acornNamespace from \"acorn\";\n\n// src/tokenType.ts\nimport { TokenType, keywordTypes, tokTypes, TokContext } from \"acorn\";\nvar startsExpr = true;\nfunction kwLike(_name, options = {}) {\n  return new TokenType(\"name\", options);\n}\nvar acornTypeScriptMap = /* @__PURE__ */ new WeakMap();\nfunction generateAcornTypeScript(_acorn) {\n  const acorn = _acorn.Parser.acorn || _acorn;\n  let acornTypeScript = acornTypeScriptMap.get(acorn);\n  if (!acornTypeScript) {\n    let tokenIsLiteralPropertyName = function(token) {\n      return [\n        ...[tokTypes.name, tokTypes.string, tokTypes.num],\n        ...Object.values(keywordTypes),\n        ...Object.values(tsKwTokenType)\n      ].includes(token);\n    }, tokenIsKeywordOrIdentifier = function(token) {\n      return [\n        ...[tokTypes.name],\n        ...Object.values(keywordTypes),\n        ...Object.values(tsKwTokenType)\n      ].includes(token);\n    }, tokenIsIdentifier = function(token) {\n      return [...Object.values(tsKwTokenType), tokTypes.name].includes(token);\n    }, tokenIsTSDeclarationStart = function(token) {\n      return [\n        tsKwTokenType.abstract,\n        tsKwTokenType.declare,\n        tsKwTokenType.enum,\n        tsKwTokenType.module,\n        tsKwTokenType.namespace,\n        tsKwTokenType.interface,\n        tsKwTokenType.type\n      ].includes(token);\n    }, tokenIsTSTypeOperator = function(token) {\n      return [tsKwTokenType.keyof, tsKwTokenType.readonly, tsKwTokenType.unique].includes(token);\n    }, tokenIsTemplate = function(token) {\n      return token === tokTypes.invalidTemplate;\n    };\n    const tsKwTokenType = generateTsKwTokenType();\n    const tsTokenType = generateTsTokenType();\n    const tsTokenContext = generateTsTokenContext();\n    const tsKeywordsRegExp = new RegExp(`^(?:${Object.keys(tsKwTokenType).join(\"|\")})$`);\n    tsTokenType.jsxTagStart.updateContext = function() {\n      this.context.push(tsTokenContext.tc_expr);\n      this.context.push(tsTokenContext.tc_oTag);\n      this.exprAllowed = false;\n    };\n    tsTokenType.jsxTagEnd.updateContext = function(prevType) {\n      let out = this.context.pop();\n      if (out === tsTokenContext.tc_oTag && prevType === tokTypes.slash || out === tsTokenContext.tc_cTag) {\n        this.context.pop();\n        this.exprAllowed = this.curContext() === tsTokenContext.tc_expr;\n      } else {\n        this.exprAllowed = true;\n      }\n    };\n    acornTypeScript = {\n      tokTypes: {\n        ...tsKwTokenType,\n        ...tsTokenType\n      },\n      tokContexts: {\n        ...tsTokenContext\n      },\n      keywordsRegExp: tsKeywordsRegExp,\n      tokenIsLiteralPropertyName,\n      tokenIsKeywordOrIdentifier,\n      tokenIsIdentifier,\n      tokenIsTSDeclarationStart,\n      tokenIsTSTypeOperator,\n      tokenIsTemplate\n    };\n  }\n  return acornTypeScript;\n}\nfunction generateTsTokenContext() {\n  return {\n    tc_oTag: new TokContext(\"<tag\", false, false),\n    tc_cTag: new TokContext(\"</tag\", false, false),\n    tc_expr: new TokContext(\"<tag>...</tag>\", true, true)\n  };\n}\nfunction generateTsTokenType() {\n  return {\n    // @ts-expect-error\n    at: new TokenType(\"@\"),\n    // @ts-expect-error\n    jsxName: new TokenType(\"jsxName\"),\n    // @ts-expect-error\n    jsxText: new TokenType(\"jsxText\", { beforeExpr: true }),\n    // @ts-expect-error\n    jsxTagStart: new TokenType(\"jsxTagStart\", { startsExpr: true }),\n    // @ts-expect-error\n    jsxTagEnd: new TokenType(\"jsxTagEnd\")\n  };\n}\nfunction generateTsKwTokenType() {\n  return {\n    assert: kwLike(\"assert\", { startsExpr }),\n    asserts: kwLike(\"asserts\", { startsExpr }),\n    global: kwLike(\"global\", { startsExpr }),\n    keyof: kwLike(\"keyof\", { startsExpr }),\n    readonly: kwLike(\"readonly\", { startsExpr }),\n    unique: kwLike(\"unique\", { startsExpr }),\n    abstract: kwLike(\"abstract\", { startsExpr }),\n    declare: kwLike(\"declare\", { startsExpr }),\n    enum: kwLike(\"enum\", { startsExpr }),\n    module: kwLike(\"module\", { startsExpr }),\n    namespace: kwLike(\"namespace\", { startsExpr }),\n    interface: kwLike(\"interface\", { startsExpr }),\n    type: kwLike(\"type\", { startsExpr })\n  };\n}\n\n// src/scopeflags.ts\nvar TS_SCOPE_OTHER = 512;\nvar TS_SCOPE_TS_MODULE = 1024;\nvar BIND_KIND_VALUE = 1;\nvar BIND_KIND_TYPE = 2;\nvar BIND_SCOPE_VAR = 4;\nvar BIND_SCOPE_LEXICAL = 8;\nvar BIND_SCOPE_FUNCTION = 16;\nvar BIND_FLAGS_NONE = 64;\nvar BIND_FLAGS_CLASS = 128;\nvar BIND_FLAGS_TS_ENUM = 256;\nvar BIND_FLAGS_TS_CONST_ENUM = 512;\nvar BIND_FLAGS_TS_EXPORT_ONLY = 1024;\nvar BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;\nvar BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;\nvar BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;\nvar BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;\nvar BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;\nvar BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;\nvar BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;\nvar BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;\nvar BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE;\nvar BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;\nvar BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;\nvar BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;\nvar CLASS_ELEMENT_FLAG_STATIC = 4;\nvar CLASS_ELEMENT_KIND_GETTER = 2;\nvar CLASS_ELEMENT_KIND_SETTER = 1;\nvar CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\nvar CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;\nvar CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;\n\n// src/whitespace.ts\nvar skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/y;\nvar skipWhiteSpaceToLineBreak = new RegExp(\n  // Unfortunately JS doesn't support Perl's atomic /(?>pattern)/ or\n  // possessive quantifiers, so we use a trick to prevent backtracking\n  // when the look-ahead for line terminator fails.\n  \"(?=(\" + // Capture the whitespace and comments that should be skipped inside\n  // a look-ahead assertion, and then re-match the group as a unit.\n  skipWhiteSpaceInLine.source + \"))\\\\1\" + // Look-ahead for either line terminator, start of multi-line comment,\n  // or end of string.\n  /(?=[\\n\\r\\u2028\\u2029]|\\/\\*(?!.*?\\*\\/)|$)/.source,\n  \"y\"\n  // sticky\n);\n\n// src/parseutil.ts\nvar DestructuringErrors = class {\n  constructor() {\n    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n  }\n};\nfunction isPrivateNameConflicted(privateNameMap, element) {\n  const name = element.key.name;\n  const curr = privateNameMap[name];\n  let next = \"true\";\n  if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) {\n    next = (element.static ? \"s\" : \"i\") + element.kind;\n  }\n  if (curr === \"iget\" && next === \"iset\" || curr === \"iset\" && next === \"iget\" || curr === \"sget\" && next === \"sset\" || curr === \"sset\" && next === \"sget\") {\n    privateNameMap[name] = \"true\";\n    return false;\n  } else if (!curr) {\n    privateNameMap[name] = next;\n    return false;\n  } else {\n    return true;\n  }\n}\nfunction checkKeyName(node, name) {\n  const { computed, key } = node;\n  return !computed && (key.type === \"Identifier\" && key.name === name || key.type === \"Literal\" && key.value === name);\n}\n\n// src/error.ts\nvar TypeScriptError = {\n  AbstractMethodHasImplementation: ({ methodName }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({ propertyName }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  AccesorCannotDeclareThisParameter: \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccesorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  CannotFindName: ({ name }) => `Cannot find name '${name}'.`,\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({ kind }) => `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier: (\n    // `Accessibility modifier already seen: ${modifier}` would be more helpful.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    () => `Accessibility modifier already seen.`\n  ),\n  DuplicateModifier: ({ modifier }) => `Duplicate modifier: '${modifier}'.`,\n  // `token` matches the terminology used by typescript:\n  // https://github.com/microsoft/TypeScript/blob/main/src/compiler/types.ts#L2915\n  EmptyHeritageClauseType: ({ token }) => `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  IncompatibleModifiers: ({ modifiers }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({ modifier }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride: \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext: \"Initializers are not allowed in ambient contexts.\",\n  InvalidModifierOnTypeMember: ({ modifier }) => `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({ modifier }) => `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({ modifier }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifiersOrder: ({ orderedModifiers }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression: \"Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName: \"'interface' declarations must be followed by an identifier.\",\n  MixedLabeledAndUnlabeledElements: \"Tuple members must all have names or all not have names.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass: \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({ modifier }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  PrivateMethodsHasAccessibility: ({ modifier }) => `Private methods cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam: \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion: \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccesorCannotHaveOptionalParameter: \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccesorCannotHaveRestParameter: \"A 'set' accessor cannot have rest parameter.\",\n  SetAccesorCannotHaveReturnType: \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({ typeParameterName }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier: \"Static class blocks cannot have any modifier.\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed: \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports: \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports: \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  GenericsEndWithComma: `Trailing comma is not allowed at the end of generics.`,\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({ type }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,\n  LetInLexicalBinding: \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\"\n};\nvar DecoratorsError = {\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration.\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  SpreadElementDecorator: `Decorators can't be used with SpreadElement`\n};\n\n// src/extentions/decorators.ts\nfunction generateParseDecorators(Parse, acornTypeScript, acorn) {\n  const { tokTypes: tt } = acorn;\n  const { tokTypes: tokTypes2 } = acornTypeScript;\n  return class ParseDecorators extends Parse {\n    takeDecorators(node) {\n      const decorators = this.decoratorStack[this.decoratorStack.length - 1];\n      if (decorators.length) {\n        node.decorators = decorators;\n        this.resetStartLocationFromNode(node, decorators[0]);\n        this.decoratorStack[this.decoratorStack.length - 1] = [];\n      }\n    }\n    parseDecorators(allowExport) {\n      const currentContextDecorators = this.decoratorStack[this.decoratorStack.length - 1];\n      while (this.match(tokTypes2.at)) {\n        const decorator = this.parseDecorator();\n        currentContextDecorators.push(decorator);\n      }\n      if (this.match(tt._export)) {\n        if (!allowExport) {\n          this.unexpected();\n        }\n      } else if (!this.canHaveLeadingDecorator()) {\n        this.raise(this.start, DecoratorsError.UnexpectedLeadingDecorator);\n      }\n    }\n    parseDecorator() {\n      const node = this.startNode();\n      this.next();\n      this.decoratorStack.push([]);\n      const startPos = this.start;\n      const startLoc = this.startLoc;\n      let expr;\n      if (this.match(tt.parenL)) {\n        const startPos2 = this.start;\n        const startLoc2 = this.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(tt.parenR);\n        if (this.options.preserveParens) {\n          let par = this.startNodeAt(startPos2, startLoc2);\n          par.expression = expr;\n          expr = this.finishNode(par, \"ParenthesizedExpression\");\n        }\n      } else {\n        expr = this.parseIdent(false);\n        while (this.eat(tt.dot)) {\n          const node2 = this.startNodeAt(startPos, startLoc);\n          node2.object = expr;\n          node2.property = this.parseIdent(true);\n          node2.computed = false;\n          expr = this.finishNode(node2, \"MemberExpression\");\n        }\n      }\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.decoratorStack.pop();\n      return this.finishNode(node, \"Decorator\");\n    }\n    parseMaybeDecoratorArguments(expr) {\n      if (this.eat(tt.parenL)) {\n        const node = this.startNodeAtNode(expr);\n        node.callee = expr;\n        node.arguments = this.parseExprList(tt.parenR, false);\n        return this.finishNode(node, \"CallExpression\");\n      }\n      return expr;\n    }\n  };\n}\n\n// src/extentions/jsx/xhtml.ts\nvar xhtml_default = {\n  quot: '\"',\n  amp: \"&\",\n  apos: \"'\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\xA0\",\n  iexcl: \"\\xA1\",\n  cent: \"\\xA2\",\n  pound: \"\\xA3\",\n  curren: \"\\xA4\",\n  yen: \"\\xA5\",\n  brvbar: \"\\xA6\",\n  sect: \"\\xA7\",\n  uml: \"\\xA8\",\n  copy: \"\\xA9\",\n  ordf: \"\\xAA\",\n  laquo: \"\\xAB\",\n  not: \"\\xAC\",\n  shy: \"\\xAD\",\n  reg: \"\\xAE\",\n  macr: \"\\xAF\",\n  deg: \"\\xB0\",\n  plusmn: \"\\xB1\",\n  sup2: \"\\xB2\",\n  sup3: \"\\xB3\",\n  acute: \"\\xB4\",\n  micro: \"\\xB5\",\n  para: \"\\xB6\",\n  middot: \"\\xB7\",\n  cedil: \"\\xB8\",\n  sup1: \"\\xB9\",\n  ordm: \"\\xBA\",\n  raquo: \"\\xBB\",\n  frac14: \"\\xBC\",\n  frac12: \"\\xBD\",\n  frac34: \"\\xBE\",\n  iquest: \"\\xBF\",\n  Agrave: \"\\xC0\",\n  Aacute: \"\\xC1\",\n  Acirc: \"\\xC2\",\n  Atilde: \"\\xC3\",\n  Auml: \"\\xC4\",\n  Aring: \"\\xC5\",\n  AElig: \"\\xC6\",\n  Ccedil: \"\\xC7\",\n  Egrave: \"\\xC8\",\n  Eacute: \"\\xC9\",\n  Ecirc: \"\\xCA\",\n  Euml: \"\\xCB\",\n  Igrave: \"\\xCC\",\n  Iacute: \"\\xCD\",\n  Icirc: \"\\xCE\",\n  Iuml: \"\\xCF\",\n  ETH: \"\\xD0\",\n  Ntilde: \"\\xD1\",\n  Ograve: \"\\xD2\",\n  Oacute: \"\\xD3\",\n  Ocirc: \"\\xD4\",\n  Otilde: \"\\xD5\",\n  Ouml: \"\\xD6\",\n  times: \"\\xD7\",\n  Oslash: \"\\xD8\",\n  Ugrave: \"\\xD9\",\n  Uacute: \"\\xDA\",\n  Ucirc: \"\\xDB\",\n  Uuml: \"\\xDC\",\n  Yacute: \"\\xDD\",\n  THORN: \"\\xDE\",\n  szlig: \"\\xDF\",\n  agrave: \"\\xE0\",\n  aacute: \"\\xE1\",\n  acirc: \"\\xE2\",\n  atilde: \"\\xE3\",\n  auml: \"\\xE4\",\n  aring: \"\\xE5\",\n  aelig: \"\\xE6\",\n  ccedil: \"\\xE7\",\n  egrave: \"\\xE8\",\n  eacute: \"\\xE9\",\n  ecirc: \"\\xEA\",\n  euml: \"\\xEB\",\n  igrave: \"\\xEC\",\n  iacute: \"\\xED\",\n  icirc: \"\\xEE\",\n  iuml: \"\\xEF\",\n  eth: \"\\xF0\",\n  ntilde: \"\\xF1\",\n  ograve: \"\\xF2\",\n  oacute: \"\\xF3\",\n  ocirc: \"\\xF4\",\n  otilde: \"\\xF5\",\n  ouml: \"\\xF6\",\n  divide: \"\\xF7\",\n  oslash: \"\\xF8\",\n  ugrave: \"\\xF9\",\n  uacute: \"\\xFA\",\n  ucirc: \"\\xFB\",\n  uuml: \"\\xFC\",\n  yacute: \"\\xFD\",\n  thorn: \"\\xFE\",\n  yuml: \"\\xFF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\n// src/extentions/jsx/index.ts\nvar hexNumber = /^[\\da-fA-F]+$/;\nvar decimalNumber = /^\\d+$/;\nfunction getQualifiedJSXName(object) {\n  if (!object) return object;\n  if (object.type === \"JSXIdentifier\") return object.name;\n  if (object.type === \"JSXNamespacedName\") return object.namespace.name + \":\" + object.name.name;\n  if (object.type === \"JSXMemberExpression\")\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n}\nfunction generateJsxParser(acorn, acornTypeScript, Parser, jsxOptions) {\n  const tt = acorn.tokTypes;\n  const tok = acornTypeScript.tokTypes;\n  const isNewLine = acorn.isNewLine;\n  const isIdentifierChar = acorn.isIdentifierChar;\n  const options = Object.assign(\n    {\n      allowNamespaces: true,\n      allowNamespacedObjects: true\n    },\n    jsxOptions || {}\n  );\n  return class JsxParser extends Parser {\n    // Reads inline JSX contents token.\n    jsx_readToken() {\n      let out = \"\", chunkStart = this.pos;\n      for (; ; ) {\n        if (this.pos >= this.input.length) this.raise(this.start, \"Unterminated JSX contents\");\n        let ch = this.input.charCodeAt(this.pos);\n        switch (ch) {\n          case 60:\n          // '<'\n          case 123:\n            if (this.pos === this.start) {\n              if (ch === 60 && this.exprAllowed) {\n                ++this.pos;\n                return this.finishToken(tok.jsxTagStart);\n              }\n              return this.getTokenFromCode(ch);\n            }\n            out += this.input.slice(chunkStart, this.pos);\n            return this.finishToken(tok.jsxText, out);\n          case 38:\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readEntity();\n            chunkStart = this.pos;\n            break;\n          case 62:\n          // '>'\n          case 125:\n            this.raise(\n              this.pos,\n              \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" + (ch === 62 ? \"&gt;\" : \"&rbrace;\") + '` or `{\"' + this.input[this.pos] + '\"}`?'\n            );\n          default:\n            if (isNewLine(ch)) {\n              out += this.input.slice(chunkStart, this.pos);\n              out += this.jsx_readNewLine(true);\n              chunkStart = this.pos;\n            } else {\n              ++this.pos;\n            }\n        }\n      }\n    }\n    jsx_readNewLine(normalizeCRLF) {\n      let ch = this.input.charCodeAt(this.pos);\n      let out;\n      ++this.pos;\n      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n        out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      return out;\n    }\n    jsx_readString(quote) {\n      let out = \"\", chunkStart = ++this.pos;\n      for (; ; ) {\n        if (this.pos >= this.input.length) this.raise(this.start, \"Unterminated string constant\");\n        let ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) break;\n        if (ch === 38) {\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readNewLine(false);\n          chunkStart = this.pos;\n        } else {\n          ++this.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos++);\n      return this.finishToken(tt.string, out);\n    }\n    jsx_readEntity() {\n      let str = \"\", count = 0, entity;\n      let ch = this.input[this.pos];\n      if (ch !== \"&\") this.raise(this.pos, \"Entity must start with an ampersand\");\n      let startPos = ++this.pos;\n      while (this.pos < this.input.length && count++ < 10) {\n        ch = this.input[this.pos++];\n        if (ch === \";\") {\n          if (str[0] === \"#\") {\n            if (str[1] === \"x\") {\n              str = str.substr(2);\n              if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));\n            } else {\n              str = str.substr(1);\n              if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));\n            }\n          } else {\n            entity = xhtml_default[str];\n          }\n          break;\n        }\n        str += ch;\n      }\n      if (!entity) {\n        this.pos = startPos;\n        return \"&\";\n      }\n      return entity;\n    }\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can't contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n    jsx_readWord() {\n      let ch, start = this.pos;\n      do {\n        ch = this.input.charCodeAt(++this.pos);\n      } while (isIdentifierChar(ch) || ch === 45);\n      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n    }\n    // Parse next token as JSX identifier\n    jsx_parseIdentifier() {\n      let node = this.startNode();\n      if (this.type === tok.jsxName) node.name = this.value;\n      else if (this.type.keyword) node.name = this.type.keyword;\n      else this.unexpected();\n      this.next();\n      return this.finishNode(node, \"JSXIdentifier\");\n    }\n    // Parse namespaced identifier.\n    jsx_parseNamespacedName() {\n      let startPos = this.start, startLoc = this.startLoc;\n      let name = this.jsx_parseIdentifier();\n      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n      var node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsx_parseIdentifier();\n      return this.finishNode(node, \"JSXNamespacedName\");\n    }\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n    jsx_parseElementName() {\n      if (this.type === tok.jsxTagEnd) return \"\";\n      let startPos = this.start, startLoc = this.startLoc;\n      let node = this.jsx_parseNamespacedName();\n      if (this.type === tt.dot && node.type === \"JSXNamespacedName\" && !options.allowNamespacedObjects) {\n        this.unexpected();\n      }\n      while (this.eat(tt.dot)) {\n        let newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsx_parseIdentifier();\n        node = this.finishNode(newNode, \"JSXMemberExpression\");\n      }\n      return node;\n    }\n    // Parses any type of JSX attribute value.\n    jsx_parseAttributeValue() {\n      switch (this.type) {\n        case tt.braceL:\n          let node = this.jsx_parseExpressionContainer();\n          if (node.expression.type === \"JSXEmptyExpression\")\n            this.raise(node.start, \"JSX attributes must only be assigned a non-empty expression\");\n          return node;\n        case tok.jsxTagStart:\n        case tt.string:\n          return this.parseExprAtom();\n        default:\n          this.raise(this.start, \"JSX value should be either an expression or a quoted JSX text\");\n      }\n    }\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n    jsx_parseEmptyExpression() {\n      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n      return this.finishNodeAt(node, \"JSXEmptyExpression\", this.start, this.startLoc);\n    }\n    // Parses JSX expression enclosed into curly brackets.\n    jsx_parseExpressionContainer() {\n      let node = this.startNode();\n      this.next();\n      node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();\n      this.expect(tt.braceR);\n      return this.finishNode(node, \"JSXExpressionContainer\");\n    }\n    // Parses following JSX attribute name-value pair.\n    jsx_parseAttribute() {\n      let node = this.startNode();\n      if (this.eat(tt.braceL)) {\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssign();\n        this.expect(tt.braceR);\n        return this.finishNode(node, \"JSXSpreadAttribute\");\n      }\n      node.name = this.jsx_parseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n      return this.finishNode(node, \"JSXAttribute\");\n    }\n    // Parses JSX opening tag starting after '<'.\n    jsx_parseOpeningElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      node.attributes = [];\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)\n        node.attributes.push(this.jsx_parseAttribute());\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? \"JSXOpeningElement\" : \"JSXOpeningFragment\");\n    }\n    // Parses JSX closing tag starting after '</'.\n    jsx_parseClosingElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? \"JSXClosingElement\" : \"JSXClosingFragment\");\n    }\n    // Parses entire JSX element, including it's opening tag\n    // (starting after '<'), attributes, contents and closing tag.\n    jsx_parseElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let children = [];\n      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n      if (!openingElement.selfClosing) {\n        contents: for (; ; ) {\n          switch (this.type) {\n            case tok.jsxTagStart:\n              startPos = this.start;\n              startLoc = this.startLoc;\n              this.next();\n              if (this.eat(tt.slash)) {\n                closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n                break contents;\n              }\n              children.push(this.jsx_parseElementAt(startPos, startLoc));\n              break;\n            case tok.jsxText:\n              children.push(this.parseExprAtom());\n              break;\n            case tt.braceL:\n              children.push(this.jsx_parseExpressionContainer());\n              break;\n            default:\n              this.unexpected();\n          }\n        }\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(\n            closingElement.start,\n            \"Expected corresponding JSX closing tag for <\" + getQualifiedJSXName(openingElement.name) + \">\"\n          );\n        }\n      }\n      let fragmentOrElement = openingElement.name ? \"Element\" : \"Fragment\";\n      node[\"opening\" + fragmentOrElement] = openingElement;\n      node[\"closing\" + fragmentOrElement] = closingElement;\n      node.children = children;\n      if (this.type === tt.relational && this.value === \"<\") {\n        this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n      }\n      return this.finishNode(node, \"JSX\" + fragmentOrElement);\n    }\n    // Parse JSX text\n    jsx_parseText() {\n      let node = this.parseLiteral(this.value);\n      node.type = \"JSXText\";\n      return node;\n    }\n    // Parses entire JSX element from current position.\n    jsx_parseElement() {\n      let startPos = this.start, startLoc = this.startLoc;\n      this.next();\n      return this.jsx_parseElementAt(startPos, startLoc);\n    }\n  };\n}\n\n// src/extentions/import-assertions.ts\nfunction generateParseImportAssertions(Parse, acornTypeScript, acorn) {\n  const { tokTypes: tokTypes2 } = acornTypeScript;\n  const { tokTypes: tt } = acorn;\n  return class ImportAttributes extends Parse {\n    parseMaybeImportAttributes(node) {\n      if (this.type === tt._with || this.type === tokTypes2.assert) {\n        this.next();\n        const attributes = this.parseImportAttributes();\n        if (attributes) {\n          node.attributes = attributes;\n        }\n      }\n    }\n    parseImportAttributes() {\n      this.expect(tt.braceL);\n      const attrs = this.parseWithEntries();\n      this.expect(tt.braceR);\n      return attrs;\n    }\n    parseWithEntries() {\n      const attrs = [];\n      const attrNames = /* @__PURE__ */ new Set();\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n        const node = this.startNode();\n        let withionKeyNode;\n        if (this.type === tt.string) {\n          withionKeyNode = this.parseLiteral(this.value);\n        } else {\n          withionKeyNode = this.parseIdent(true);\n        }\n        this.next();\n        node.key = withionKeyNode;\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in attributes\");\n        }\n        attrNames.add(node.key.name);\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an attribute value\");\n        }\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n      return attrs;\n    }\n  };\n}\n\n// src/index.ts\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\nfunction tsIsClassAccessor(modifier) {\n  return modifier === \"accessor\";\n}\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === \"in\" || modifier === \"out\";\n}\nvar FUNC_STATEMENT = 1;\nvar FUNC_HANGING_STATEMENT = 2;\nvar FUNC_NULLABLE_ID = 4;\nvar acornScope = {\n  SCOPE_TOP: 1,\n  SCOPE_FUNCTION: 2,\n  SCOPE_ASYNC: 4,\n  SCOPE_GENERATOR: 8,\n  SCOPE_ARROW: 16,\n  SCOPE_SIMPLE_CATCH: 32,\n  SCOPE_SUPER: 64,\n  SCOPE_DIRECT_SUPER: 128,\n  SCOPE_CLASS_STATIC_BLOCK: 256,\n  SCOPE_VAR: 256,\n  BIND_NONE: 0,\n  // Not a binding\n  BIND_VAR: 1,\n  // Var-style binding\n  BIND_LEXICAL: 2,\n  // Let- or const-style binding\n  BIND_FUNCTION: 3,\n  // Function declaration\n  BIND_SIMPLE_CATCH: 4,\n  // Simple (identifier pattern) catch binding\n  BIND_OUTSIDE: 5,\n  // Special case for function names as bound inside the\n  BIND_TS_TYPE: 6,\n  BIND_TS_INTERFACE: 7,\n  BIND_TS_NAMESPACE: 8,\n  BIND_FLAGS_TS_EXPORT_ONLY: 1024,\n  BIND_FLAGS_TS_IMPORT: 4096,\n  BIND_FLAGS_TS_ENUM: 256,\n  BIND_FLAGS_TS_CONST_ENUM: 512,\n  BIND_FLAGS_CLASS: 128\n  // function\n};\nfunction functionFlags(async, generator) {\n  return acornScope.SCOPE_FUNCTION | (async ? acornScope.SCOPE_ASYNC : 0) | (generator ? acornScope.SCOPE_GENERATOR : 0);\n}\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== \"MemberExpression\") return false;\n  const { computed, property } = expression;\n  if (computed && (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\") return false;\n  if (expression.computed) return false;\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\nfunction tokenCanStartExpression(token) {\n  return Boolean(token.startsExpr);\n}\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return void 0;\n  }\n}\nfunction tsPlugin(options) {\n  const { dts = false } = options || {};\n  const disallowAmbiguousJSXLike = !!options?.jsx;\n  return function(Parser) {\n    const _acorn = Parser.acorn || acornNamespace;\n    const acornTypeScript = generateAcornTypeScript(_acorn);\n    const tt = _acorn.tokTypes;\n    const keywordTypes2 = _acorn.keywordTypes;\n    const isIdentifierStart = _acorn.isIdentifierStart;\n    const lineBreak = _acorn.lineBreak;\n    const isNewLine = _acorn.isNewLine;\n    const tokContexts = _acorn.tokContexts;\n    const isIdentifierChar = _acorn.isIdentifierChar;\n    const {\n      tokTypes: tokTypes2,\n      tokContexts: tsTokContexts,\n      keywordsRegExp,\n      tokenIsLiteralPropertyName,\n      tokenIsTemplate,\n      tokenIsTSDeclarationStart,\n      tokenIsIdentifier,\n      tokenIsKeywordOrIdentifier,\n      tokenIsTSTypeOperator\n    } = acornTypeScript;\n    function nextLineBreak(code, from, end = code.length) {\n      for (let i = from; i < end; i++) {\n        let next = code.charCodeAt(i);\n        if (isNewLine(next))\n          return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;\n      }\n      return -1;\n    }\n    Parser = generateParseDecorators(Parser, acornTypeScript, _acorn);\n    if (options?.jsx) {\n      Parser = generateJsxParser(\n        _acorn,\n        acornTypeScript,\n        Parser,\n        typeof options.jsx === \"boolean\" ? {} : options.jsx\n      );\n    }\n    Parser = generateParseImportAssertions(Parser, acornTypeScript, _acorn);\n    class TypeScriptParser extends Parser {\n      constructor(options2, input, startPos) {\n        super(options2, input, startPos);\n        this.preValue = null;\n        this.preToken = null;\n        this.isLookahead = false;\n        this.isAmbientContext = false;\n        this.inAbstractClass = false;\n        this.inType = false;\n        this.inDisallowConditionalTypesContext = false;\n        this.maybeInArrowParameters = false;\n        this.shouldParseArrowReturnType = void 0;\n        this.shouldParseAsyncArrowReturnType = void 0;\n        this.decoratorStack = [[]];\n        this.importsStack = [[]];\n        /**\n         * we will only parse one import node or export node at same time.\n         * default kind is undefined\n         * */\n        this.importOrExportOuterKind = void 0;\n        this.tsParseConstModifier = (node) => {\n          this.tsParseModifiers({\n            modified: node,\n            allowedModifiers: [\"const\"],\n            // for better error recovery\n            disallowedModifiers: [\"in\", \"out\"],\n            errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions\n          });\n        };\n        this.ecmaVersion = this.options.ecmaVersion;\n      }\n      // support in Class static\n      static get acornTypeScript() {\n        return acornTypeScript;\n      }\n      // support in runtime, get acornTypeScript be this\n      get acornTypeScript() {\n        return acornTypeScript;\n      }\n      getTokenFromCodeInType(code) {\n        if (code === 62) {\n          return this.finishOp(tt.relational, 1);\n        }\n        if (code === 60) {\n          return this.finishOp(tt.relational, 1);\n        }\n        return super.getTokenFromCode(code);\n      }\n      readToken(code) {\n        if (!this.inType) {\n          let context = this.curContext();\n          if (context === tsTokContexts.tc_expr) return this.jsx_readToken();\n          if (context === tsTokContexts.tc_oTag || context === tsTokContexts.tc_cTag) {\n            if (isIdentifierStart(code)) return this.jsx_readWord();\n            if (code == 62) {\n              ++this.pos;\n              return this.finishToken(tokTypes2.jsxTagEnd);\n            }\n            if ((code === 34 || code === 39) && context == tsTokContexts.tc_oTag)\n              return this.jsx_readString(code);\n          }\n          if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n            ++this.pos;\n            if (options?.jsx) {\n              return this.finishToken(tokTypes2.jsxTagStart);\n            } else {\n              return this.finishToken(tt.relational, \"<\");\n            }\n          }\n        }\n        return super.readToken(code);\n      }\n      getTokenFromCode(code) {\n        if (this.inType) {\n          return this.getTokenFromCodeInType(code);\n        }\n        if (code === 64) {\n          ++this.pos;\n          return this.finishToken(tokTypes2.at);\n        }\n        return super.getTokenFromCode(code);\n      }\n      isAbstractClass() {\n        return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt._class;\n      }\n      finishNode(node, type) {\n        if (node.type !== \"\" && node.end !== 0) {\n          return node;\n        }\n        return super.finishNode(node, type);\n      }\n      // tryParse will clone parser state.\n      // It is expensive and should be used with cautions\n      tryParse(fn, oldState = this.cloneCurLookaheadState()) {\n        const abortSignal = { node: null };\n        try {\n          const node = fn((node2 = null) => {\n            abortSignal.node = node2;\n            throw abortSignal;\n          });\n          return {\n            node,\n            error: null,\n            thrown: false,\n            aborted: false,\n            failState: null\n          };\n        } catch (error) {\n          const failState = this.getCurLookaheadState();\n          this.setLookaheadState(oldState);\n          if (error instanceof SyntaxError) {\n            return {\n              node: null,\n              error,\n              thrown: true,\n              aborted: false,\n              failState\n            };\n          }\n          if (error === abortSignal) {\n            return {\n              node: abortSignal.node,\n              error: null,\n              thrown: false,\n              aborted: true,\n              failState\n            };\n          }\n          throw error;\n        }\n      }\n      setOptionalParametersError(refExpressionErrors, resultError) {\n        refExpressionErrors.optionalParametersLoc = resultError?.loc ?? this.startLoc;\n      }\n      // used after we have finished parsing types\n      reScan_lt_gt() {\n        if (this.type === tt.relational) {\n          this.pos -= 1;\n          this.readToken_lt_gt(this.fullCharCodeAtPos());\n        }\n      }\n      reScan_lt() {\n        const { type } = this;\n        if (type === tt.bitShift) {\n          this.pos -= 2;\n          this.finishOp(tt.relational, 1);\n          return tt.relational;\n        }\n        return type;\n      }\n      resetEndLocation(node, endPos = this.lastTokEnd, endLoc = this.lastTokEndLoc) {\n        node.end = endPos;\n        node.loc.end = endLoc;\n        if (this.options.ranges) node.range[1] = endPos;\n      }\n      startNodeAtNode(type) {\n        return super.startNodeAt(type.start, type.loc.start);\n      }\n      nextTokenStart() {\n        return this.nextTokenStartSince(this.pos);\n      }\n      tsHasSomeModifiers(member, modifiers) {\n        return modifiers.some((modifier) => {\n          if (tsIsAccessModifier(modifier)) {\n            return member.accessibility === modifier;\n          }\n          return !!member[modifier];\n        });\n      }\n      tsIsStartOfStaticBlocks() {\n        return this.isContextual(\"static\") && this.lookaheadCharCode() === 123;\n      }\n      tsCheckForInvalidTypeCasts(items) {\n        items.forEach((node) => {\n          if (node?.type === \"TSTypeCastExpression\") {\n            this.raise(node.typeAnnotation.start, TypeScriptError.UnexpectedTypeAnnotation);\n          }\n        });\n      }\n      atPossibleAsyncArrow(base) {\n        return base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEndLoc.column === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.potentialArrowAt;\n      }\n      tsIsIdentifier() {\n        return tokenIsIdentifier(this.type);\n      }\n      tsTryParseTypeOrTypePredicateAnnotation() {\n        return this.match(tt.colon) ? this.tsParseTypeOrTypePredicateAnnotation(tt.colon) : void 0;\n      }\n      tsTryParseGenericAsyncArrowFunction(startPos, startLoc, forInit) {\n        if (!this.tsMatchLeftRelational()) {\n          return void 0;\n        }\n        const oldMaybeInArrowParameters = this.maybeInArrowParameters;\n        this.maybeInArrowParameters = true;\n        const res = this.tsTryParseAndCatch(() => {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n          super.parseFunctionParams(node);\n          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n          this.expect(tt.arrow);\n          return node;\n        });\n        this.maybeInArrowParameters = oldMaybeInArrowParameters;\n        if (!res) {\n          return void 0;\n        }\n        return super.parseArrowExpression(\n          res,\n          /* params are already set */\n          null,\n          /* async */\n          true,\n          /* forInit */\n          forInit\n        );\n      }\n      // Used when parsing type arguments from ES productions, where the first token\n      // has been created without state.inType. Thus we need to rescan the lt token.\n      tsParseTypeArgumentsInExpression() {\n        if (this.reScan_lt() !== tt.relational) {\n          return void 0;\n        }\n        return this.tsParseTypeArguments();\n      }\n      tsInNoContext(cb) {\n        const oldContext = this.context;\n        this.context = [oldContext[0]];\n        try {\n          return cb();\n        } finally {\n          this.context = oldContext;\n        }\n      }\n      tsTryParseTypeAnnotation() {\n        return this.match(tt.colon) ? this.tsParseTypeAnnotation() : void 0;\n      }\n      isUnparsedContextual(nameStart, name) {\n        const nameEnd = nameStart + name.length;\n        if (this.input.slice(nameStart, nameEnd) === name) {\n          const nextCh = this.input.charCodeAt(nameEnd);\n          return !(isIdentifierChar(nextCh) || // check if `nextCh is between 0xd800 - 0xdbff,\n          // if `nextCh` is NaN, `NaN & 0xfc00` is 0, the function\n          // returns true\n          (nextCh & 64512) === 55296);\n        }\n        return false;\n      }\n      isAbstractConstructorSignature() {\n        return this.ts_isContextual(tokTypes2.abstract) && this.lookahead().type === tt._new;\n      }\n      nextTokenStartSince(pos) {\n        skipWhiteSpace.lastIndex = pos;\n        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n      }\n      lookaheadCharCode() {\n        return this.input.charCodeAt(this.nextTokenStart());\n      }\n      compareLookaheadState(state, state2) {\n        for (const key of Object.keys(state)) {\n          if (state[key] !== state2[key]) return false;\n        }\n        return true;\n      }\n      createLookaheadState() {\n        this.value = null;\n        this.context = [this.curContext()];\n      }\n      getCurLookaheadState() {\n        return {\n          endLoc: this.endLoc,\n          lastTokEnd: this.lastTokEnd,\n          lastTokStart: this.lastTokStart,\n          lastTokStartLoc: this.lastTokStartLoc,\n          pos: this.pos,\n          value: this.value,\n          type: this.type,\n          start: this.start,\n          end: this.end,\n          context: this.context,\n          startLoc: this.startLoc,\n          lastTokEndLoc: this.lastTokEndLoc,\n          curLine: this.curLine,\n          lineStart: this.lineStart,\n          curPosition: this.curPosition,\n          containsEsc: this.containsEsc\n        };\n      }\n      cloneCurLookaheadState() {\n        return {\n          pos: this.pos,\n          value: this.value,\n          type: this.type,\n          start: this.start,\n          end: this.end,\n          context: this.context && this.context.slice(),\n          startLoc: this.startLoc,\n          lastTokEndLoc: this.lastTokEndLoc,\n          endLoc: this.endLoc,\n          lastTokEnd: this.lastTokEnd,\n          lastTokStart: this.lastTokStart,\n          lastTokStartLoc: this.lastTokStartLoc,\n          curLine: this.curLine,\n          lineStart: this.lineStart,\n          curPosition: this.curPosition,\n          containsEsc: this.containsEsc\n        };\n      }\n      setLookaheadState(state) {\n        this.pos = state.pos;\n        this.value = state.value;\n        this.endLoc = state.endLoc;\n        this.lastTokEnd = state.lastTokEnd;\n        this.lastTokStart = state.lastTokStart;\n        this.lastTokStartLoc = state.lastTokStartLoc;\n        this.type = state.type;\n        this.start = state.start;\n        this.end = state.end;\n        this.context = state.context;\n        this.startLoc = state.startLoc;\n        this.lastTokEndLoc = state.lastTokEndLoc;\n        this.curLine = state.curLine;\n        this.lineStart = state.lineStart;\n        this.curPosition = state.curPosition;\n        this.containsEsc = state.containsEsc;\n      }\n      // Utilities\n      tsLookAhead(f) {\n        const state = this.getCurLookaheadState();\n        const res = f();\n        this.setLookaheadState(state);\n        return res;\n      }\n      lookahead(number) {\n        const oldState = this.getCurLookaheadState();\n        this.createLookaheadState();\n        this.isLookahead = true;\n        if (number !== void 0) {\n          for (let i = 0; i < number; i++) {\n            this.nextToken();\n          }\n        } else {\n          this.nextToken();\n        }\n        this.isLookahead = false;\n        const curState = this.getCurLookaheadState();\n        this.setLookaheadState(oldState);\n        return curState;\n      }\n      readWord() {\n        let word = this.readWord1();\n        let type = tt.name;\n        if (this.keywords.test(word)) {\n          type = keywordTypes2[word];\n        } else if (new RegExp(keywordsRegExp).test(word)) {\n          type = tokTypes2[word];\n        }\n        return this.finishToken(type, word);\n      }\n      skipBlockComment() {\n        let startLoc;\n        if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();\n        let start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n        if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\");\n        this.pos = end + 2;\n        if (this.options.locations) {\n          for (let nextBreak, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {\n            ++this.curLine;\n            pos = this.lineStart = nextBreak;\n          }\n        }\n        if (this.isLookahead) return;\n        if (this.options.onComment) {\n          this.options.onComment(\n            true,\n            this.input.slice(start + 2, end),\n            start,\n            this.pos,\n            startLoc,\n            this.curPosition()\n          );\n        }\n      }\n      skipLineComment(startSkip) {\n        let start = this.pos;\n        let startLoc;\n        if (!this.isLookahead) startLoc = this.options.onComment && this.curPosition();\n        let ch = this.input.charCodeAt(this.pos += startSkip);\n        while (this.pos < this.input.length && !isNewLine(ch)) {\n          ch = this.input.charCodeAt(++this.pos);\n        }\n        if (this.isLookahead) return;\n        if (this.options.onComment)\n          this.options.onComment(\n            false,\n            this.input.slice(start + startSkip, this.pos),\n            start,\n            this.pos,\n            startLoc,\n            this.curPosition()\n          );\n      }\n      finishToken(type, val) {\n        this.preValue = this.value;\n        this.preToken = this.type;\n        this.end = this.pos;\n        if (this.options.locations) this.endLoc = this.curPosition();\n        let prevType = this.type;\n        this.type = type;\n        this.value = val;\n        if (!this.isLookahead) {\n          this.updateContext(prevType);\n        }\n      }\n      resetStartLocation(node, start, startLoc) {\n        node.start = start;\n        node.loc.start = startLoc;\n        if (this.options.ranges) node.range[0] = start;\n      }\n      isLineTerminator() {\n        return this.eat(tt.semi) || super.canInsertSemicolon();\n      }\n      hasFollowingLineBreak() {\n        skipWhiteSpaceToLineBreak.lastIndex = this.end;\n        return skipWhiteSpaceToLineBreak.test(this.input);\n      }\n      addExtra(node, key, value, enumerable = true) {\n        if (!node) return;\n        const extra = node.extra = node.extra || {};\n        if (enumerable) {\n          extra[key] = value;\n        } else {\n          Object.defineProperty(extra, key, { enumerable, value });\n        }\n      }\n      /**\n       * Test if current token is a literal property name\n       * https://tc39.es/ecma262/#prod-LiteralPropertyName\n       * LiteralPropertyName:\n       *   IdentifierName\n       *   StringLiteral\n       *   NumericLiteral\n       *   BigIntLiteral\n       */\n      isLiteralPropertyName() {\n        return tokenIsLiteralPropertyName(this.type);\n      }\n      hasPrecedingLineBreak() {\n        return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n      }\n      createIdentifier(node, name) {\n        node.name = name;\n        return this.finishNode(node, \"Identifier\");\n      }\n      /**\n       * Reset the start location of node to the start location of locationNode\n       */\n      resetStartLocationFromNode(node, locationNode) {\n        this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n      }\n      // This is used in flow and typescript plugin\n      // Determine whether a parameter is a this param\n      isThisParam(param) {\n        return param.type === \"Identifier\" && param.name === \"this\";\n      }\n      isLookaheadContextual(name) {\n        const next = this.nextTokenStart();\n        return this.isUnparsedContextual(next, name);\n      }\n      /**\n       * ts type isContextual\n       * @param {TokenType} type\n       * @param {TokenType} token\n       * @returns {boolean}\n       * */\n      ts_type_isContextual(type, token) {\n        return type === token && !this.containsEsc;\n      }\n      /**\n       * ts isContextual\n       * @param {TokenType} token\n       * @returns {boolean}\n       * */\n      ts_isContextual(token) {\n        return this.type === token && !this.containsEsc;\n      }\n      ts_isContextualWithState(state, token) {\n        return state.type === token && !state.containsEsc;\n      }\n      isContextualWithState(keyword, state) {\n        return state.type === tt.name && state.value === keyword && !state.containsEsc;\n      }\n      tsIsStartOfMappedType() {\n        this.next();\n        if (this.eat(tt.plusMin)) {\n          return this.ts_isContextual(tokTypes2.readonly);\n        }\n        if (this.ts_isContextual(tokTypes2.readonly)) {\n          this.next();\n        }\n        if (!this.match(tt.bracketL)) {\n          return false;\n        }\n        this.next();\n        if (!this.tsIsIdentifier()) {\n          return false;\n        }\n        this.next();\n        return this.match(tt._in);\n      }\n      tsInDisallowConditionalTypesContext(cb) {\n        const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;\n        this.inDisallowConditionalTypesContext = true;\n        try {\n          return cb();\n        } finally {\n          this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n        }\n      }\n      tsTryParseType() {\n        return this.tsEatThenParseType(tt.colon);\n      }\n      /**\n       * Whether current token matches given type\n       *\n       * @param {TokenType} type\n       * @returns {boolean}\n       * @memberof Tokenizer\n       */\n      match(type) {\n        return this.type === type;\n      }\n      matchJsx(type) {\n        return this.type === acornTypeScript.tokTypes[type];\n      }\n      ts_eatWithState(type, nextCount, state) {\n        const targetType = state.type;\n        if (type === targetType) {\n          for (let i = 0; i < nextCount; i++) {\n            this.next();\n          }\n          return true;\n        } else {\n          return false;\n        }\n      }\n      ts_eatContextualWithState(name, nextCount, state) {\n        if (keywordsRegExp.test(name)) {\n          if (this.ts_isContextualWithState(state, tokTypes2[name])) {\n            for (let i = 0; i < nextCount; i++) {\n              this.next();\n            }\n            return true;\n          }\n          return false;\n        } else {\n          if (!this.isContextualWithState(name, state)) return false;\n          for (let i = 0; i < nextCount; i++) {\n            this.next();\n          }\n          return true;\n        }\n      }\n      canHaveLeadingDecorator() {\n        return this.match(tt._class);\n      }\n      eatContextual(name) {\n        if (keywordsRegExp.test(name)) {\n          if (this.ts_isContextual(tokTypes2[name])) {\n            this.next();\n            return true;\n          }\n          return false;\n        } else {\n          return super.eatContextual(name);\n        }\n      }\n      tsIsExternalModuleReference() {\n        return this.isContextual(\"require\") && this.lookaheadCharCode() === 40;\n      }\n      tsParseExternalModuleReference() {\n        const node = this.startNode();\n        this.expectContextual(\"require\");\n        this.expect(tt.parenL);\n        if (!this.match(tt.string)) {\n          this.unexpected();\n        }\n        node.expression = this.parseExprAtom();\n        this.expect(tt.parenR);\n        return this.finishNode(node, \"TSExternalModuleReference\");\n      }\n      tsParseEntityName(allowReservedWords = true) {\n        let entity = this.parseIdent(allowReservedWords);\n        while (this.eat(tt.dot)) {\n          const node = this.startNodeAtNode(entity);\n          node.left = entity;\n          node.right = this.parseIdent(allowReservedWords);\n          entity = this.finishNode(node, \"TSQualifiedName\");\n        }\n        return entity;\n      }\n      tsParseEnumMember() {\n        const node = this.startNode();\n        node.id = this.match(tt.string) ? this.parseLiteral(this.value) : this.parseIdent(\n          /* liberal */\n          true\n        );\n        if (this.eat(tt.eq)) {\n          node.initializer = this.parseMaybeAssign();\n        }\n        return this.finishNode(node, \"TSEnumMember\");\n      }\n      tsParseEnumDeclaration(node, properties = {}) {\n        if (properties.const) node.const = true;\n        if (properties.declare) node.declare = true;\n        this.expectContextual(\"enum\");\n        node.id = this.parseIdent();\n        this.checkLValSimple(node.id);\n        this.expect(tt.braceL);\n        node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n        this.expect(tt.braceR);\n        return this.finishNode(node, \"TSEnumDeclaration\");\n      }\n      tsParseModuleBlock() {\n        const node = this.startNode();\n        this.enterScope(TS_SCOPE_OTHER);\n        this.expect(tt.braceL);\n        node.body = [];\n        while (this.type !== tt.braceR) {\n          let stmt = this.parseStatement(null, true);\n          node.body.push(stmt);\n        }\n        this.next();\n        super.exitScope();\n        return this.finishNode(node, \"TSModuleBlock\");\n      }\n      tsParseAmbientExternalModuleDeclaration(node) {\n        if (this.ts_isContextual(tokTypes2.global)) {\n          node.global = true;\n          node.id = this.parseIdent();\n        } else if (this.match(tt.string)) {\n          node.id = this.parseLiteral(this.value);\n        } else {\n          this.unexpected();\n        }\n        if (this.match(tt.braceL)) {\n          this.enterScope(TS_SCOPE_TS_MODULE);\n          node.body = this.tsParseModuleBlock();\n          super.exitScope();\n        } else {\n          super.semicolon();\n        }\n        return this.finishNode(node, \"TSModuleDeclaration\");\n      }\n      tsTryParseDeclare(nany) {\n        if (this.isLineTerminator()) {\n          return;\n        }\n        let starttype = this.type;\n        let kind;\n        if (this.isContextual(\"let\")) {\n          starttype = tt._var;\n          kind = \"let\";\n        }\n        return this.tsInAmbientContext(() => {\n          if (starttype === tt._function) {\n            nany.declare = true;\n            return this.parseFunctionStatement(\n              nany,\n              /* async */\n              false,\n              /* declarationPosition */\n              true\n            );\n          }\n          if (starttype === tt._class) {\n            nany.declare = true;\n            return this.parseClass(nany, true);\n          }\n          if (starttype === tokTypes2.enum) {\n            return this.tsParseEnumDeclaration(nany, { declare: true });\n          }\n          if (starttype === tokTypes2.global) {\n            return this.tsParseAmbientExternalModuleDeclaration(nany);\n          }\n          if (starttype === tt._const || starttype === tt._var) {\n            if (!this.match(tt._const) || !this.isLookaheadContextual(\"enum\")) {\n              nany.declare = true;\n              return this.parseVarStatement(nany, kind || this.value, true);\n            }\n            this.expect(tt._const);\n            return this.tsParseEnumDeclaration(nany, {\n              const: true,\n              declare: true\n            });\n          }\n          if (starttype === tokTypes2.interface) {\n            const result = this.tsParseInterfaceDeclaration(nany, {\n              declare: true\n            });\n            if (result) return result;\n          }\n          if (tokenIsIdentifier(starttype)) {\n            return this.tsParseDeclaration(\n              nany,\n              this.value,\n              /* next */\n              true\n            );\n          }\n        });\n      }\n      tsIsListTerminator(kind) {\n        switch (kind) {\n          case \"EnumMembers\":\n          case \"TypeMembers\":\n            return this.match(tt.braceR);\n          case \"HeritageClauseElement\":\n            return this.match(tt.braceL);\n          case \"TupleElementTypes\":\n            return this.match(tt.bracketR);\n          case \"TypeParametersOrArguments\":\n            return this.tsMatchRightRelational();\n        }\n      }\n      /**\n       * If !expectSuccess, returns undefined instead of failing to parse.\n       * If expectSuccess, parseElement should always return a defined value.\n       */\n      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n        const result = [];\n        let trailingCommaPos = -1;\n        for (; ; ) {\n          if (this.tsIsListTerminator(kind)) {\n            break;\n          }\n          trailingCommaPos = -1;\n          const element = parseElement();\n          if (element == null) {\n            return void 0;\n          }\n          result.push(element);\n          if (this.eat(tt.comma)) {\n            trailingCommaPos = this.lastTokStart;\n            continue;\n          }\n          if (this.tsIsListTerminator(kind)) {\n            break;\n          }\n          if (expectSuccess) {\n            this.expect(tt.comma);\n          }\n          return void 0;\n        }\n        if (refTrailingCommaPos) {\n          refTrailingCommaPos.value = trailingCommaPos;\n        }\n        return result;\n      }\n      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n        return nonNull(\n          this.tsParseDelimitedListWorker(\n            kind,\n            parseElement,\n            /* expectSuccess */\n            true,\n            refTrailingCommaPos\n          )\n        );\n      }\n      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n        if (!skipFirstToken) {\n          if (bracket) {\n            this.expect(tt.bracketL);\n          } else {\n            this.expect(tt.relational);\n          }\n        }\n        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n        if (bracket) {\n          this.expect(tt.bracketR);\n        } else {\n          this.expect(tt.relational);\n        }\n        return result;\n      }\n      tsParseTypeParameterName() {\n        const typeName = this.parseIdent();\n        return typeName.name;\n      }\n      tsEatThenParseType(token) {\n        return !this.match(token) ? void 0 : this.tsNextThenParseType();\n      }\n      tsExpectThenParseType(token) {\n        return this.tsDoThenParseType(() => this.expect(token));\n      }\n      tsNextThenParseType() {\n        return this.tsDoThenParseType(() => this.next());\n      }\n      tsDoThenParseType(cb) {\n        return this.tsInType(() => {\n          cb();\n          return this.tsParseType();\n        });\n      }\n      tsSkipParameterStart() {\n        if (tokenIsIdentifier(this.type) || this.match(tt._this)) {\n          this.next();\n          return true;\n        }\n        if (this.match(tt.braceL)) {\n          try {\n            this.parseObj(true);\n            return true;\n          } catch {\n            return false;\n          }\n        }\n        if (this.match(tt.bracketL)) {\n          this.next();\n          try {\n            this.parseBindingList(tt.bracketR, true, true);\n            return true;\n          } catch {\n            return false;\n          }\n        }\n        return false;\n      }\n      tsIsUnambiguouslyStartOfFunctionType() {\n        this.next();\n        if (this.match(tt.parenR) || this.match(tt.ellipsis)) {\n          return true;\n        }\n        if (this.tsSkipParameterStart()) {\n          if (this.match(tt.colon) || this.match(tt.comma) || this.match(tt.question) || this.match(tt.eq)) {\n            return true;\n          }\n          if (this.match(tt.parenR)) {\n            this.next();\n            if (this.match(tt.arrow)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n      tsIsStartOfFunctionType() {\n        if (this.tsMatchLeftRelational()) {\n          return true;\n        }\n        return this.match(tt.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n      }\n      tsInAllowConditionalTypesContext(cb) {\n        const oldInDisallowConditionalTypesContext = this.inDisallowConditionalTypesContext;\n        this.inDisallowConditionalTypesContext = false;\n        try {\n          return cb();\n        } finally {\n          this.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n        }\n      }\n      tsParseBindingListForSignature() {\n        return super.parseBindingList(tt.parenR, true, true).map((pattern) => {\n          if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\" && pattern.type !== \"ObjectPattern\" && pattern.type !== \"ArrayPattern\") {\n            this.raise(\n              pattern.start,\n              TypeScriptError.UnsupportedSignatureParameterKind(pattern.type)\n            );\n          }\n          return pattern;\n        });\n      }\n      tsParseTypePredicateAsserts() {\n        if (this.type !== tokTypes2.asserts) {\n          return false;\n        }\n        const containsEsc = this.containsEsc;\n        this.next();\n        if (!tokenIsIdentifier(this.type) && !this.match(tt._this)) {\n          return false;\n        }\n        if (containsEsc) {\n          this.raise(this.lastTokStart, \"Escape sequence in keyword asserts\");\n        }\n        return true;\n      }\n      tsParseThisTypeNode() {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSThisType\");\n      }\n      tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n        this.tsInType(() => {\n          if (eatColon) this.expect(tt.colon);\n          t.typeAnnotation = this.tsParseType();\n        });\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      tsParseThisTypePredicate(lhs) {\n        this.next();\n        const node = this.startNodeAtNode(lhs);\n        node.parameterName = lhs;\n        node.typeAnnotation = this.tsParseTypeAnnotation(\n          /* eatColon */\n          false\n        );\n        node.asserts = false;\n        return this.finishNode(node, \"TSTypePredicate\");\n      }\n      tsParseThisTypeOrThisTypePredicate() {\n        const thisKeyword = this.tsParseThisTypeNode();\n        if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n          return this.tsParseThisTypePredicate(thisKeyword);\n        } else {\n          return thisKeyword;\n        }\n      }\n      tsParseTypePredicatePrefix() {\n        const id = this.parseIdent();\n        if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n          this.next();\n          return id;\n        }\n      }\n      tsParseTypeOrTypePredicateAnnotation(returnToken) {\n        return this.tsInType(() => {\n          const t = this.startNode();\n          this.expect(returnToken);\n          const node = this.startNode();\n          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n          if (asserts && this.match(tt._this)) {\n            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n            if (thisTypePredicate.type === \"TSThisType\") {\n              node.parameterName = thisTypePredicate;\n              node.asserts = true;\n              node.typeAnnotation = null;\n              thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n            } else {\n              this.resetStartLocationFromNode(thisTypePredicate, node);\n              thisTypePredicate.asserts = true;\n            }\n            t.typeAnnotation = thisTypePredicate;\n            return this.finishNode(t, \"TSTypeAnnotation\");\n          }\n          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n          if (!typePredicateVariable) {\n            if (!asserts) {\n              return this.tsParseTypeAnnotation(\n                /* eatColon */\n                false,\n                t\n              );\n            }\n            node.parameterName = this.parseIdent();\n            node.asserts = asserts;\n            node.typeAnnotation = null;\n            t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n            return this.finishNode(t, \"TSTypeAnnotation\");\n          }\n          const type = this.tsParseTypeAnnotation(\n            /* eatColon */\n            false\n          );\n          node.parameterName = typePredicateVariable;\n          node.typeAnnotation = type;\n          node.asserts = asserts;\n          t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        });\n      }\n      // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n      // but here it's always false, because this is only used for types.\n      tsFillSignature(returnToken, signature) {\n        const returnTokenRequired = returnToken === tt.arrow;\n        const paramsKey = \"parameters\";\n        const returnTypeKey = \"typeAnnotation\";\n        signature.typeParameters = this.tsTryParseTypeParameters();\n        this.expect(tt.parenL);\n        signature[paramsKey] = this.tsParseBindingListForSignature();\n        if (returnTokenRequired) {\n          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n        } else if (this.match(returnToken)) {\n          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n        }\n      }\n      tsTryNextParseConstantContext() {\n        if (this.lookahead().type !== tt._const) return null;\n        this.next();\n        const typeReference = this.tsParseTypeReference();\n        if (typeReference.typeParameters || typeReference.typeArguments) {\n          this.raise(\n            typeReference.typeName.start,\n            TypeScriptError.CannotFindName({\n              name: \"const\"\n            })\n          );\n        }\n        return typeReference;\n      }\n      tsParseFunctionOrConstructorType(type, abstract) {\n        const node = this.startNode();\n        if (type === \"TSConstructorType\") {\n          node.abstract = !!abstract;\n          if (abstract) this.next();\n          this.next();\n        }\n        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(tt.arrow, node));\n        return this.finishNode(node, type);\n      }\n      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n        const node = this.startNode();\n        const hasLeadingOperator = this.eat(operator);\n        const types = [];\n        do {\n          types.push(parseConstituentType());\n        } while (this.eat(operator));\n        if (types.length === 1 && !hasLeadingOperator) {\n          return types[0];\n        }\n        node.types = types;\n        return this.finishNode(node, kind);\n      }\n      tsCheckTypeAnnotationForReadOnly(node) {\n        switch (node.typeAnnotation.type) {\n          case \"TSTupleType\":\n          case \"TSArrayType\":\n            return;\n          default:\n            this.raise(node.start, TypeScriptError.UnexpectedReadonly);\n        }\n      }\n      tsParseTypeOperator() {\n        const node = this.startNode();\n        const operator = this.value;\n        this.next();\n        node.operator = operator;\n        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n        if (operator === \"readonly\") {\n          this.tsCheckTypeAnnotationForReadOnly(node);\n        }\n        return this.finishNode(node, \"TSTypeOperator\");\n      }\n      tsParseConstraintForInferType() {\n        if (this.eat(tt._extends)) {\n          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n          if (this.inDisallowConditionalTypesContext || !this.match(tt.question)) {\n            return constraint;\n          }\n        }\n      }\n      tsParseInferType() {\n        const node = this.startNode();\n        this.expectContextual(\"infer\");\n        const typeParameter = this.startNode();\n        typeParameter.name = this.tsParseTypeParameterName();\n        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n        node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n        return this.finishNode(node, \"TSInferType\");\n      }\n      tsParseLiteralTypeNode() {\n        const node = this.startNode();\n        node.literal = (() => {\n          switch (this.type) {\n            case tt.num:\n            // we don't need bigint type here\n            // case tt.bigint:\n            case tt.string:\n            case tt._true:\n            case tt._false:\n              return this.parseExprAtom();\n            default:\n              this.unexpected();\n          }\n        })();\n        return this.finishNode(node, \"TSLiteralType\");\n      }\n      tsParseImportType() {\n        const node = this.startNode();\n        this.expect(tt._import);\n        this.expect(tt.parenL);\n        if (!this.match(tt.string)) {\n          this.raise(this.start, TypeScriptError.UnsupportedImportTypeArgument);\n        }\n        node.argument = this.parseExprAtom();\n        this.expect(tt.parenR);\n        if (this.eat(tt.dot)) {\n          node.qualifier = this.tsParseEntityName();\n        }\n        if (this.tsMatchLeftRelational()) {\n          node.typeArguments = this.tsParseTypeArguments();\n        }\n        return this.finishNode(node, \"TSImportType\");\n      }\n      tsParseTypeQuery() {\n        const node = this.startNode();\n        this.expect(tt._typeof);\n        if (this.match(tt._import)) {\n          node.exprName = this.tsParseImportType();\n        } else {\n          node.exprName = this.tsParseEntityName();\n        }\n        if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) {\n          node.typeArguments = this.tsParseTypeArguments();\n        }\n        return this.finishNode(node, \"TSTypeQuery\");\n      }\n      tsParseMappedTypeParameter() {\n        const node = this.startNode();\n        node.name = this.tsParseTypeParameterName();\n        node.constraint = this.tsExpectThenParseType(tt._in);\n        return this.finishNode(node, \"TSTypeParameter\");\n      }\n      tsParseMappedType() {\n        const node = this.startNode();\n        this.expect(tt.braceL);\n        if (this.match(tt.plusMin)) {\n          node.readonly = this.value;\n          this.next();\n          this.expectContextual(\"readonly\");\n        } else if (this.eatContextual(\"readonly\")) {\n          node.readonly = true;\n        }\n        this.expect(tt.bracketL);\n        node.typeParameter = this.tsParseMappedTypeParameter();\n        node.nameType = this.eatContextual(\"as\") ? this.tsParseType() : null;\n        this.expect(tt.bracketR);\n        if (this.match(tt.plusMin)) {\n          node.optional = this.value;\n          this.next();\n          this.expect(tt.question);\n        } else if (this.eat(tt.question)) {\n          node.optional = true;\n        }\n        node.typeAnnotation = this.tsTryParseType();\n        this.semicolon();\n        this.expect(tt.braceR);\n        return this.finishNode(node, \"TSMappedType\");\n      }\n      tsParseTypeLiteral() {\n        const node = this.startNode();\n        node.members = this.tsParseObjectTypeMembers();\n        return this.finishNode(node, \"TSTypeLiteral\");\n      }\n      tsParseTupleElementType() {\n        const startLoc = this.startLoc;\n        const startPos = this[\"start\"];\n        const rest = this.eat(tt.ellipsis);\n        let type = this.tsParseType();\n        const optional = this.eat(tt.question);\n        const labeled = this.eat(tt.colon);\n        if (labeled) {\n          const labeledNode = this.startNodeAtNode(type);\n          labeledNode.optional = optional;\n          if (type.type === \"TSTypeReference\" && !type.typeArguments && type.typeName.type === \"Identifier\") {\n            labeledNode.label = type.typeName;\n          } else {\n            this.raise(type.start, TypeScriptError.InvalidTupleMemberLabel);\n            labeledNode.label = type;\n          }\n          labeledNode.elementType = this.tsParseType();\n          type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n        } else if (optional) {\n          const optionalTypeNode = this.startNodeAtNode(type);\n          optionalTypeNode.typeAnnotation = type;\n          type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n        }\n        if (rest) {\n          const restNode = this.startNodeAt(startPos, startLoc);\n          restNode.typeAnnotation = type;\n          type = this.finishNode(restNode, \"TSRestType\");\n        }\n        return type;\n      }\n      tsParseTupleType() {\n        const node = this.startNode();\n        node.elementTypes = this.tsParseBracketedList(\n          \"TupleElementTypes\",\n          this.tsParseTupleElementType.bind(this),\n          /* bracket */\n          true,\n          /* skipFirstToken */\n          false\n        );\n        let seenOptionalElement = false;\n        let labeledElements = null;\n        node.elementTypes.forEach((elementNode) => {\n          const { type } = elementNode;\n          if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n            this.raise(elementNode.start, TypeScriptError.OptionalTypeBeforeRequired);\n          }\n          seenOptionalElement ||= type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\";\n          let checkType = type;\n          if (type === \"TSRestType\") {\n            elementNode = elementNode.typeAnnotation;\n            checkType = elementNode.type;\n          }\n          const isLabeled = checkType === \"TSNamedTupleMember\";\n          labeledElements ??= isLabeled;\n          if (labeledElements !== isLabeled) {\n            this.raise(elementNode.start, TypeScriptError.MixedLabeledAndUnlabeledElements);\n          }\n        });\n        return this.finishNode(node, \"TSTupleType\");\n      }\n      tsParseTemplateLiteralType() {\n        const node = this.startNode();\n        node.literal = this.parseTemplate({ isTagged: false });\n        return this.finishNode(node, \"TSLiteralType\");\n      }\n      tsParseTypeReference() {\n        const node = this.startNode();\n        node.typeName = this.tsParseEntityName();\n        if (!this.hasPrecedingLineBreak() && this.tsMatchLeftRelational()) {\n          node.typeArguments = this.tsParseTypeArguments();\n        }\n        return this.finishNode(node, \"TSTypeReference\");\n      }\n      tsMatchLeftRelational() {\n        return this.match(tt.relational) && this.value === \"<\";\n      }\n      tsMatchRightRelational() {\n        return this.match(tt.relational) && this.value === \">\";\n      }\n      tsParseParenthesizedType() {\n        const node = this.startNode();\n        this.expect(tt.parenL);\n        node.typeAnnotation = this.tsParseType();\n        this.expect(tt.parenR);\n        return this.finishNode(node, \"TSParenthesizedType\");\n      }\n      tsParseNonArrayType() {\n        switch (this.type) {\n          case tt.string:\n          case tt.num:\n          // we don't need bigint type here\n          // case tt.bigint:\n          case tt._true:\n          case tt._false:\n            return this.tsParseLiteralTypeNode();\n          case tt.plusMin:\n            if (this.value === \"-\") {\n              const node = this.startNode();\n              const nextToken = this.lookahead();\n              if (nextToken.type !== tt.num) {\n                this.unexpected();\n              }\n              node.literal = this.parseMaybeUnary();\n              return this.finishNode(node, \"TSLiteralType\");\n            }\n            break;\n          case tt._this:\n            return this.tsParseThisTypeOrThisTypePredicate();\n          case tt._typeof:\n            return this.tsParseTypeQuery();\n          case tt._import:\n            return this.tsParseImportType();\n          case tt.braceL:\n            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n          case tt.bracketL:\n            return this.tsParseTupleType();\n          case tt.parenL:\n            return this.tsParseParenthesizedType();\n          // parse template string here\n          case tt.backQuote:\n          case tt.dollarBraceL:\n            return this.tsParseTemplateLiteralType();\n          default: {\n            const { type } = this;\n            if (tokenIsIdentifier(type) || type === tt._void || type === tt._null) {\n              const nodeType = type === tt._void ? \"TSVoidKeyword\" : type === tt._null ? \"TSNullKeyword\" : keywordTypeFromName(this.value);\n              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {\n                const node = this.startNode();\n                this.next();\n                return this.finishNode(node, nodeType);\n              }\n              return this.tsParseTypeReference();\n            }\n          }\n        }\n        this.unexpected();\n      }\n      tsParseArrayTypeOrHigher() {\n        let type = this.tsParseNonArrayType();\n        while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) {\n          if (this.match(tt.bracketR)) {\n            const node = this.startNodeAtNode(type);\n            node.elementType = type;\n            this.expect(tt.bracketR);\n            type = this.finishNode(node, \"TSArrayType\");\n          } else {\n            const node = this.startNodeAtNode(type);\n            node.objectType = type;\n            node.indexType = this.tsParseType();\n            this.expect(tt.bracketR);\n            type = this.finishNode(node, \"TSIndexedAccessType\");\n          }\n        }\n        return type;\n      }\n      tsParseTypeOperatorOrHigher() {\n        const isTypeOperator = tokenIsTSTypeOperator(this.type) && !this.containsEsc;\n        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(\"infer\") ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n      }\n      tsParseIntersectionTypeOrHigher() {\n        return this.tsParseUnionOrIntersectionType(\n          \"TSIntersectionType\",\n          this.tsParseTypeOperatorOrHigher.bind(this),\n          tt.bitwiseAND\n        );\n      }\n      tsParseUnionTypeOrHigher() {\n        return this.tsParseUnionOrIntersectionType(\n          \"TSUnionType\",\n          this.tsParseIntersectionTypeOrHigher.bind(this),\n          tt.bitwiseOR\n        );\n      }\n      tsParseNonConditionalType() {\n        if (this.tsIsStartOfFunctionType()) {\n          return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n        }\n        if (this.match(tt._new)) {\n          return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n        } else if (this.isAbstractConstructorSignature()) {\n          return this.tsParseFunctionOrConstructorType(\n            \"TSConstructorType\",\n            /* abstract */\n            true\n          );\n        }\n        return this.tsParseUnionTypeOrHigher();\n      }\n      /** Be sure to be in a type context before calling this, using `tsInType`. */\n      tsParseType() {\n        assert(this.inType);\n        const type = this.tsParseNonConditionalType();\n        if (this.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(tt._extends)) {\n          return type;\n        }\n        const node = this.startNodeAtNode(type);\n        node.checkType = type;\n        node.extendsType = this.tsInDisallowConditionalTypesContext(\n          () => this.tsParseNonConditionalType()\n        );\n        this.expect(tt.question);\n        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n        this.expect(tt.colon);\n        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n        return this.finishNode(node, \"TSConditionalType\");\n      }\n      tsIsUnambiguouslyIndexSignature() {\n        this.next();\n        if (tokenIsIdentifier(this.type)) {\n          this.next();\n          return this.match(tt.colon);\n        }\n        return false;\n      }\n      /**\n       * Runs `cb` in a type context.\n       * This should be called one token *before* the first type token,\n       * so that the call to `next()` is run in type context.\n       */\n      tsInType(cb) {\n        const oldInType = this.inType;\n        this.inType = true;\n        try {\n          return cb();\n        } finally {\n          this.inType = oldInType;\n        }\n      }\n      tsTryParseIndexSignature(node) {\n        if (!(this.match(tt.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n          return void 0;\n        }\n        this.expect(tt.bracketL);\n        const id = this.parseIdent();\n        id.typeAnnotation = this.tsParseTypeAnnotation();\n        this.resetEndLocation(id);\n        this.expect(tt.bracketR);\n        node.parameters = [id];\n        const type = this.tsTryParseTypeAnnotation();\n        if (type) node.typeAnnotation = type;\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(node, \"TSIndexSignature\");\n      }\n      // for better error recover\n      tsParseNoneModifiers(node) {\n        this.tsParseModifiers({\n          modified: node,\n          allowedModifiers: [],\n          disallowedModifiers: [\"in\", \"out\"],\n          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions\n        });\n      }\n      tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {\n        const node = this.startNode();\n        parseModifiers(node);\n        node.name = this.tsParseTypeParameterName();\n        node.constraint = this.tsEatThenParseType(tt._extends);\n        node.default = this.tsEatThenParseType(tt.eq);\n        return this.finishNode(node, \"TSTypeParameter\");\n      }\n      tsParseTypeParameters(parseModifiers) {\n        const node = this.startNode();\n        if (this.tsMatchLeftRelational() || this.matchJsx(\"jsxTagStart\")) {\n          this.next();\n        } else {\n          this.unexpected();\n        }\n        const refTrailingCommaPos = { value: -1 };\n        node.params = this.tsParseBracketedList(\n          \"TypeParametersOrArguments\",\n          this.tsParseTypeParameter.bind(this, parseModifiers),\n          /* bracket */\n          false,\n          /* skipFirstToken */\n          true,\n          refTrailingCommaPos\n        );\n        if (node.params.length === 0) {\n          this.raise(this.start, TypeScriptError.EmptyTypeParameters);\n        }\n        if (refTrailingCommaPos.value !== -1) {\n          this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n        }\n        return this.finishNode(node, \"TSTypeParameterDeclaration\");\n      }\n      tsTryParseTypeParameters(parseModifiers) {\n        if (this.tsMatchLeftRelational()) {\n          return this.tsParseTypeParameters(parseModifiers);\n        }\n      }\n      tsTryParse(f) {\n        const state = this.getCurLookaheadState();\n        const result = f();\n        if (result !== void 0 && result !== false) {\n          return result;\n        } else {\n          this.setLookaheadState(state);\n          return void 0;\n        }\n      }\n      tsTokenCanFollowModifier() {\n        return (this.match(tt.bracketL) || this.match(tt.braceL) || this.match(tt.star) || this.match(tt.ellipsis) || this.match(tt.privateId) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\n      }\n      tsNextTokenCanFollowModifier() {\n        this.next(true);\n        return this.tsTokenCanFollowModifier();\n      }\n      /** Parses a modifier matching one the given modifier names. */\n      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {\n        const modifier = this.value;\n        if (allowedModifiers.indexOf(modifier) !== -1 && !this.containsEsc) {\n          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n            return void 0;\n          }\n          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n            return modifier;\n          }\n        }\n        return void 0;\n      }\n      tsParseModifiersByMap({\n        modified,\n        map\n      }) {\n        for (const key of Object.keys(map)) {\n          modified[key] = map[key];\n        }\n      }\n      /** Parses a list of modifiers, in any order.\n       *  If you need a specific order, you must call this function multiple times:\n       *    this.tsParseModifiers({ modified: node, allowedModifiers: ['public'] });\n       *    this.tsParseModifiers({ modified: node, allowedModifiers: [\"abstract\", \"readonly\"] });\n       */\n      tsParseModifiers({\n        modified,\n        allowedModifiers,\n        disallowedModifiers,\n        stopOnStartOfClassStaticBlock,\n        errorTemplate = TypeScriptError.InvalidModifierOnTypeMember\n      }) {\n        const modifiedMap = {};\n        const enforceOrder = (loc, modifier, before, after) => {\n          if (modifier === before && modified[after]) {\n            this.raise(\n              loc.column,\n              TypeScriptError.InvalidModifiersOrder({ orderedModifiers: [before, after] })\n            );\n          }\n        };\n        const incompatible = (loc, modifier, mod1, mod2) => {\n          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n            this.raise(\n              loc.column,\n              TypeScriptError.IncompatibleModifiers({ modifiers: [mod1, mod2] })\n            );\n          }\n        };\n        for (; ; ) {\n          const startLoc = this.startLoc;\n          const modifier = this.tsParseModifier(\n            allowedModifiers.concat(disallowedModifiers ?? []),\n            stopOnStartOfClassStaticBlock\n          );\n          if (!modifier) break;\n          if (tsIsAccessModifier(modifier)) {\n            if (modified.accessibility) {\n              this.raise(this.start, TypeScriptError.DuplicateAccessibilityModifier());\n            } else {\n              enforceOrder(startLoc, modifier, modifier, \"override\");\n              enforceOrder(startLoc, modifier, modifier, \"static\");\n              enforceOrder(startLoc, modifier, modifier, \"readonly\");\n              enforceOrder(startLoc, modifier, modifier, \"accessor\");\n              modifiedMap.accessibility = modifier;\n              modified[\"accessibility\"] = modifier;\n            }\n          } else if (tsIsVarianceAnnotations(modifier)) {\n            if (modified[modifier]) {\n              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));\n            } else {\n              enforceOrder(startLoc, modifier, \"in\", \"out\");\n              modifiedMap[modifier] = modifier;\n              modified[modifier] = true;\n            }\n          } else if (tsIsClassAccessor(modifier)) {\n            if (modified[modifier]) {\n              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));\n            } else {\n              incompatible(startLoc, modifier, \"accessor\", \"readonly\");\n              incompatible(startLoc, modifier, \"accessor\", \"static\");\n              incompatible(startLoc, modifier, \"accessor\", \"override\");\n              modifiedMap[modifier] = modifier;\n              modified[modifier] = true;\n            }\n          } else if (modifier === \"const\") {\n            if (modified[modifier]) {\n              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));\n            } else {\n              modifiedMap[modifier] = modifier;\n              modified[modifier] = true;\n            }\n          } else {\n            if (Object.hasOwnProperty.call(modified, modifier)) {\n              this.raise(this.start, TypeScriptError.DuplicateModifier({ modifier }));\n            } else {\n              enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n              enforceOrder(startLoc, modifier, \"static\", \"override\");\n              enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n              enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n              incompatible(startLoc, modifier, \"declare\", \"override\");\n              incompatible(startLoc, modifier, \"static\", \"abstract\");\n              modifiedMap[modifier] = modifier;\n              modified[modifier] = true;\n            }\n          }\n          if (disallowedModifiers?.includes(modifier)) {\n            this.raise(this.start, errorTemplate);\n          }\n        }\n        return modifiedMap;\n      }\n      tsParseInOutModifiers(node) {\n        this.tsParseModifiers({\n          modified: node,\n          allowedModifiers: [\"in\", \"out\"],\n          disallowedModifiers: [\n            \"public\",\n            \"private\",\n            \"protected\",\n            \"readonly\",\n            \"declare\",\n            \"abstract\",\n            \"override\"\n          ],\n          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameter\n        });\n      }\n      // Handle type assertions\n      parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit) {\n        if (!options?.jsx && this.tsMatchLeftRelational()) {\n          return this.tsParseTypeAssertion();\n        } else {\n          return super.parseMaybeUnary(refExpressionErrors, sawUnary, incDec, forInit);\n        }\n      }\n      tsParseTypeAssertion() {\n        if (disallowAmbiguousJSXLike) {\n          this.raise(this.start, TypeScriptError.ReservedTypeAssertion);\n        }\n        const result = this.tryParse(() => {\n          const node = this.startNode();\n          const _const = this.tsTryNextParseConstantContext();\n          node.typeAnnotation = _const || this.tsNextThenParseType();\n          this.expect(tt.relational);\n          node.expression = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSTypeAssertion\");\n        });\n        if (result.error) {\n          return this.tsParseTypeParameters(this.tsParseConstModifier);\n        } else {\n          return result.node;\n        }\n      }\n      tsParseTypeArguments() {\n        const node = this.startNode();\n        node.params = this.tsInType(\n          () => (\n            // Temporarily remove a JSX parsing context, which makes us scan different tokens.\n            this.tsInNoContext(() => {\n              this.expect(tt.relational);\n              return this.tsParseDelimitedList(\n                \"TypeParametersOrArguments\",\n                this.tsParseType.bind(this)\n              );\n            })\n          )\n        );\n        if (node.params.length === 0) {\n          this.raise(this.start, TypeScriptError.EmptyTypeArguments);\n        }\n        this.exprAllowed = false;\n        this.expect(tt.relational);\n        return this.finishNode(node, \"TSTypeParameterInstantiation\");\n      }\n      tsParseHeritageClause(token) {\n        const originalStart = this.start;\n        const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", () => {\n          const node = this.startNode();\n          node.expression = this.tsParseEntityName();\n          if (this.tsMatchLeftRelational()) {\n            node.typeParameters = this.tsParseTypeArguments();\n          }\n          return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n        });\n        if (!delimitedList.length) {\n          this.raise(originalStart, TypeScriptError.EmptyHeritageClauseType({ token }));\n        }\n        return delimitedList;\n      }\n      tsParseTypeMemberSemicolon() {\n        if (!this.eat(tt.comma) && !this.isLineTerminator()) {\n          this.expect(tt.semi);\n        }\n      }\n      tsTryParseAndCatch(f) {\n        const result = this.tryParse(\n          (abort) => (\n            // @ts-expect-error todo(flow->ts)\n            f() || abort()\n          )\n        );\n        if (result.aborted || !result.node) return void 0;\n        if (result.error) this.setLookaheadState(result.failState);\n        return result.node;\n      }\n      tsParseSignatureMember(kind, node) {\n        this.tsFillSignature(tt.colon, node);\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(node, kind);\n      }\n      tsParsePropertyOrMethodSignature(node, readonly) {\n        if (this.eat(tt.question)) node.optional = true;\n        const nodeAny = node;\n        if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {\n          if (readonly) {\n            this.raise(node.start, TypeScriptError.ReadonlyForMethodSignature);\n          }\n          const method = nodeAny;\n          if (method.kind && this.tsMatchLeftRelational()) {\n            this.raise(this.start, TypeScriptError.AccesorCannotHaveTypeParameters);\n          }\n          this.tsFillSignature(tt.colon, method);\n          this.tsParseTypeMemberSemicolon();\n          const paramsKey = \"parameters\";\n          const returnTypeKey = \"typeAnnotation\";\n          if (method.kind === \"get\") {\n            if (method[paramsKey].length > 0) {\n              this.raise(this.start, \"A 'get' accesor must not have any formal parameters.\");\n              if (this.isThisParam(method[paramsKey][0])) {\n                this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);\n              }\n            }\n          } else if (method.kind === \"set\") {\n            if (method[paramsKey].length !== 1) {\n              this.raise(this.start, \"A 'get' accesor must not have any formal parameters.\");\n            } else {\n              const firstParameter = method[paramsKey][0];\n              if (this.isThisParam(firstParameter)) {\n                this.raise(this.start, TypeScriptError.AccesorCannotDeclareThisParameter);\n              }\n              if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n                this.raise(this.start, TypeScriptError.SetAccesorCannotHaveOptionalParameter);\n              }\n              if (firstParameter.type === \"RestElement\") {\n                this.raise(this.start, TypeScriptError.SetAccesorCannotHaveRestParameter);\n              }\n            }\n            if (method[returnTypeKey]) {\n              this.raise(\n                method[returnTypeKey].start,\n                TypeScriptError.SetAccesorCannotHaveReturnType\n              );\n            }\n          } else {\n            method.kind = \"method\";\n          }\n          return this.finishNode(method, \"TSMethodSignature\");\n        } else {\n          const property = nodeAny;\n          if (readonly) property.readonly = true;\n          const type = this.tsTryParseTypeAnnotation();\n          if (type) property.typeAnnotation = type;\n          this.tsParseTypeMemberSemicolon();\n          return this.finishNode(property, \"TSPropertySignature\");\n        }\n      }\n      tsParseTypeMember() {\n        const node = this.startNode();\n        if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {\n          return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n        }\n        if (this.match(tt._new)) {\n          const id = this.startNode();\n          this.next();\n          if (this.match(tt.parenL) || this.tsMatchLeftRelational()) {\n            return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n          } else {\n            node.key = this.createIdentifier(id, \"new\");\n            return this.tsParsePropertyOrMethodSignature(node, false);\n          }\n        }\n        this.tsParseModifiers({\n          modified: node,\n          allowedModifiers: [\"readonly\"],\n          disallowedModifiers: [\n            \"declare\",\n            \"abstract\",\n            \"private\",\n            \"protected\",\n            \"public\",\n            \"static\",\n            \"override\"\n          ]\n        });\n        const idx = this.tsTryParseIndexSignature(node);\n        if (idx) {\n          return idx;\n        }\n        this.parsePropertyName(node);\n        if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n          node.kind = node.key.name;\n          this.parsePropertyName(node);\n        }\n        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n      }\n      tsParseList(kind, parseElement) {\n        const result = [];\n        while (!this.tsIsListTerminator(kind)) {\n          result.push(parseElement());\n        }\n        return result;\n      }\n      tsParseObjectTypeMembers() {\n        this.expect(tt.braceL);\n        const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n        this.expect(tt.braceR);\n        return members;\n      }\n      tsParseInterfaceDeclaration(node, properties = {}) {\n        if (this.hasFollowingLineBreak()) return null;\n        this.expectContextual(\"interface\");\n        if (properties.declare) node.declare = true;\n        if (tokenIsIdentifier(this.type)) {\n          node.id = this.parseIdent();\n          this.checkLValSimple(node.id, acornScope.BIND_TS_INTERFACE);\n        } else {\n          node.id = null;\n          this.raise(this.start, TypeScriptError.MissingInterfaceName);\n        }\n        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n        if (this.eat(tt._extends)) {\n          node.extends = this.tsParseHeritageClause(\"extends\");\n        }\n        const body = this.startNode();\n        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n        node.body = this.finishNode(body, \"TSInterfaceBody\");\n        return this.finishNode(node, \"TSInterfaceDeclaration\");\n      }\n      tsParseAbstractDeclaration(node) {\n        if (this.match(tt._class)) {\n          node.abstract = true;\n          return this.parseClass(node, true);\n        } else if (this.ts_isContextual(tokTypes2.interface)) {\n          if (!this.hasFollowingLineBreak()) {\n            node.abstract = true;\n            return this.tsParseInterfaceDeclaration(node);\n          }\n        } else {\n          this.unexpected(node.start);\n        }\n      }\n      tsIsDeclarationStart() {\n        return tokenIsTSDeclarationStart(this.type);\n      }\n      tsParseExpressionStatement(node, expr) {\n        switch (expr.name) {\n          case \"declare\": {\n            const declaration = this.tsTryParseDeclare(node);\n            if (declaration) {\n              declaration.declare = true;\n              return declaration;\n            }\n            break;\n          }\n          case \"global\":\n            if (this.match(tt.braceL)) {\n              this.enterScope(TS_SCOPE_TS_MODULE);\n              const mod = node;\n              mod.global = true;\n              mod.id = expr;\n              mod.body = this.tsParseModuleBlock();\n              super.exitScope();\n              return this.finishNode(mod, \"TSModuleDeclaration\");\n            }\n            break;\n          default:\n            return this.tsParseDeclaration(\n              node,\n              expr.name,\n              /* next */\n              false\n            );\n        }\n      }\n      tsParseModuleReference() {\n        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(\n          /* allowReservedWords */\n          false\n        );\n      }\n      tsIsExportDefaultSpecifier() {\n        const { type } = this;\n        const isAsync = this.isAsyncFunction();\n        const isLet = this.isLet();\n        if (tokenIsIdentifier(type)) {\n          if (isAsync && !this.containsEsc || isLet) {\n            return false;\n          }\n          if ((type === tokTypes2.type || type === tokTypes2.interface) && !this.containsEsc) {\n            const ahead = this.lookahead();\n            if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState(\"from\", ahead) || ahead.type === tt.braceL) {\n              return false;\n            }\n          }\n        } else if (!this.match(tt._default)) {\n          return false;\n        }\n        const next = this.nextTokenStart();\n        const hasFrom = this.isUnparsedContextual(next, \"from\");\n        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.type) && hasFrom) {\n          return true;\n        }\n        if (this.match(tt._default) && hasFrom) {\n          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n          return nextAfterFrom === 34 || nextAfterFrom === 39;\n        }\n        return false;\n      }\n      tsInAmbientContext(cb) {\n        const oldIsAmbientContext = this.isAmbientContext;\n        this.isAmbientContext = true;\n        try {\n          return cb();\n        } finally {\n          this.isAmbientContext = oldIsAmbientContext;\n        }\n      }\n      tsCheckLineTerminator(next) {\n        if (next) {\n          if (this.hasFollowingLineBreak()) return false;\n          this.next();\n          return true;\n        }\n        return !this.isLineTerminator();\n      }\n      tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n        node.id = this.parseIdent();\n        if (!nested) {\n          this.checkLValSimple(node.id, acornScope.BIND_TS_NAMESPACE);\n        }\n        if (this.eat(tt.dot)) {\n          const inner = this.startNode();\n          this.tsParseModuleOrNamespaceDeclaration(inner, true);\n          node.body = inner;\n        } else {\n          this.enterScope(TS_SCOPE_TS_MODULE);\n          node.body = this.tsParseModuleBlock();\n          super.exitScope();\n        }\n        return this.finishNode(node, \"TSModuleDeclaration\");\n      }\n      checkLValSimple(expr, bindingType = acornScope.BIND_NONE, checkClashes) {\n        if (expr.type === \"TSNonNullExpression\" || expr.type === \"TSAsExpression\") {\n          expr = expr.expression;\n        }\n        return super.checkLValSimple(expr, bindingType, checkClashes);\n      }\n      tsParseTypeAliasDeclaration(node) {\n        node.id = this.parseIdent();\n        this.checkLValSimple(node.id, acornScope.BIND_TS_TYPE);\n        node.typeAnnotation = this.tsInType(() => {\n          node.typeParameters = this.tsTryParseTypeParameters(\n            this.tsParseInOutModifiers.bind(this)\n          );\n          this.expect(tt.eq);\n          if (this.ts_isContextual(tokTypes2.interface) && this.lookahead().type !== tt.dot) {\n            const node2 = this.startNode();\n            this.next();\n            return this.finishNode(node2, \"TSIntrinsicKeyword\");\n          }\n          return this.tsParseType();\n        });\n        this.semicolon();\n        return this.finishNode(node, \"TSTypeAliasDeclaration\");\n      }\n      // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.\n      tsParseDeclaration(node, value, next) {\n        switch (value) {\n          case \"abstract\":\n            if (this.tsCheckLineTerminator(next) && (this.match(tt._class) || tokenIsIdentifier(this.type))) {\n              return this.tsParseAbstractDeclaration(node);\n            }\n            break;\n          case \"module\":\n            if (this.tsCheckLineTerminator(next)) {\n              if (this.match(tt.string)) {\n                return this.tsParseAmbientExternalModuleDeclaration(node);\n              } else if (tokenIsIdentifier(this.type)) {\n                return this.tsParseModuleOrNamespaceDeclaration(node);\n              }\n            }\n            break;\n          case \"namespace\":\n            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.type)) {\n              return this.tsParseModuleOrNamespaceDeclaration(node);\n            }\n            break;\n          case \"type\":\n            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.type)) {\n              return this.tsParseTypeAliasDeclaration(node);\n            }\n            break;\n        }\n      }\n      // Note: this won't b·e called unless the keyword is allowed in\n      // `shouldParseExportDeclaration`.\n      tsTryParseExportDeclaration() {\n        return this.tsParseDeclaration(\n          this.startNode(),\n          this.value,\n          /* next */\n          true\n        );\n      }\n      tsParseImportEqualsDeclaration(node, isExport) {\n        node.isExport = isExport || false;\n        node.id = this.parseIdent();\n        this.checkLValSimple(node.id, acornScope.BIND_LEXICAL);\n        super.expect(tt.eq);\n        const moduleReference = this.tsParseModuleReference();\n        if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n          this.raise(moduleReference.start, TypeScriptError.ImportAliasHasImportType);\n        }\n        node.moduleReference = moduleReference;\n        super.semicolon();\n        return this.finishNode(node, \"TSImportEqualsDeclaration\");\n      }\n      isExportDefaultSpecifier() {\n        if (this.tsIsDeclarationStart()) return false;\n        const { type } = this;\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(\"async\") || this.isContextual(\"let\")) {\n            return false;\n          }\n          if ((type === tokTypes2.type || type === tokTypes2.interface) && !this.containsEsc) {\n            const ahead = this.lookahead();\n            if (tokenIsIdentifier(ahead.type) && !this.isContextualWithState(\"from\", ahead) || ahead.type === tt.braceL) {\n              return false;\n            }\n          }\n        } else if (!this.match(tt._default)) {\n          return false;\n        }\n        const next = this.nextTokenStart();\n        const hasFrom = this.isUnparsedContextual(next, \"from\");\n        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.type) && hasFrom) {\n          return true;\n        }\n        if (this.match(tt._default) && hasFrom) {\n          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n          return nextAfterFrom === 34 || nextAfterFrom === 39;\n        }\n        return false;\n      }\n      parseTemplate({ isTagged = false } = {}) {\n        let node = this.startNode();\n        this.next();\n        node.expressions = [];\n        let curElt = this.parseTemplateElement({ isTagged });\n        node.quasis = [curElt];\n        while (!curElt.tail) {\n          if (this.type === tt.eof) this.raise(this.pos, \"Unterminated template literal\");\n          this.expect(tt.dollarBraceL);\n          node.expressions.push(this.inType ? this.tsParseType() : this.parseExpression());\n          this.expect(tt.braceR);\n          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));\n        }\n        this.next();\n        return this.finishNode(node, \"TemplateLiteral\");\n      }\n      parseFunction(node, statement, allowExpressionBody, isAsync, forInit) {\n        this.initFunction(node);\n        if (this.ecmaVersion >= 9 || this.ecmaVersion >= 6 && !isAsync) {\n          if (this.type === tt.star && statement & FUNC_HANGING_STATEMENT) {\n            this.unexpected();\n          }\n          node.generator = this.eat(tt.star);\n        }\n        if (this.ecmaVersion >= 8) {\n          node.async = !!isAsync;\n        }\n        if (statement & FUNC_STATEMENT) {\n          node.id = statement & FUNC_NULLABLE_ID && this.type !== tt.name ? null : this.parseIdent();\n        }\n        let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        const oldMaybeInArrowParameters = this.maybeInArrowParameters;\n        this.maybeInArrowParameters = false;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        this.enterScope(functionFlags(node.async, node.generator));\n        if (!(statement & FUNC_STATEMENT)) {\n          node.id = this.type === tt.name ? this.parseIdent() : null;\n        }\n        this.parseFunctionParams(node);\n        const isDeclaration = statement & FUNC_STATEMENT;\n        this.parseFunctionBody(node, allowExpressionBody, false, forInit, {\n          isFunctionDeclaration: isDeclaration\n        });\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        if (statement & FUNC_STATEMENT && node.id && !(statement & FUNC_HANGING_STATEMENT)) {\n          if (node.body) {\n            this.checkLValSimple(\n              node.id,\n              this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? acornScope.BIND_VAR : acornScope.BIND_LEXICAL : acornScope.BIND_FUNCTION\n            );\n          } else {\n            this.checkLValSimple(node.id, acornScope.BIND_NONE);\n          }\n        }\n        this.maybeInArrowParameters = oldMaybeInArrowParameters;\n        return this.finishNode(node, isDeclaration ? \"FunctionDeclaration\" : \"FunctionExpression\");\n      }\n      parseFunctionBody(node, isArrowFunction = false, isMethod = false, forInit = false, tsConfig) {\n        if (this.match(tt.colon)) {\n          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\n        }\n        const bodilessType = tsConfig?.isFunctionDeclaration ? \"TSDeclareFunction\" : tsConfig?.isClassMethod ? \"TSDeclareMethod\" : void 0;\n        if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) {\n          return this.finishNode(node, bodilessType);\n        }\n        if (bodilessType === \"TSDeclareFunction\" && this.isAmbientContext) {\n          this.raise(node.start, TypeScriptError.DeclareFunctionHasImplementation);\n          if (node.declare) {\n            super.parseFunctionBody(node, isArrowFunction, isMethod, false);\n            return this.finishNode(node, bodilessType);\n          }\n        }\n        super.parseFunctionBody(node, isArrowFunction, isMethod, forInit);\n        return node;\n      }\n      parseNew() {\n        if (this.containsEsc) this.raiseRecoverable(this.start, \"Escape sequence in keyword new\");\n        let node = this.startNode();\n        let meta = this.parseIdent(true);\n        if (this.ecmaVersion >= 6 && this.eat(tt.dot)) {\n          node.meta = meta;\n          let containsEsc = this.containsEsc;\n          node.property = this.parseIdent(true);\n          if (node.property.name !== \"target\")\n            this.raiseRecoverable(\n              node.property.start,\n              \"The only valid meta property for new is 'new.target'\"\n            );\n          if (containsEsc)\n            this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\");\n          if (!this[\"allowNewDotTarget\"])\n            this.raiseRecoverable(\n              node.start,\n              \"'new.target' can only be used in functions and class static block\"\n            );\n          return this.finishNode(node, \"MetaProperty\");\n        }\n        let startPos = this.start, startLoc = this.startLoc, isImport = this.type === tt._import;\n        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);\n        if (isImport && node.callee.type === \"ImportExpression\") {\n          this.raise(startPos, \"Cannot use new with import()\");\n        }\n        const { callee } = node;\n        if (callee.type === \"TSInstantiationExpression\" && !callee.extra?.parenthesized) {\n          node.typeArguments = callee.typeArguments;\n          node.callee = callee.expression;\n        }\n        if (this.eat(tt.parenL))\n          node.arguments = this.parseExprList(tt.parenR, this.ecmaVersion >= 8, false);\n        else node.arguments = [];\n        return this.finishNode(node, \"NewExpression\");\n      }\n      parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n        if (tt._in.binop > minPrec && !this.hasPrecedingLineBreak()) {\n          let nodeType;\n          if (this.isContextual(\"as\")) {\n            nodeType = \"TSAsExpression\";\n          }\n          if (this.isContextual(\"satisfies\")) {\n            nodeType = \"TSSatisfiesExpression\";\n          }\n          if (nodeType) {\n            const node = this.startNodeAt(leftStartPos, leftStartLoc);\n            node.expression = left;\n            const _const = this.tsTryNextParseConstantContext();\n            if (_const) {\n              node.typeAnnotation = _const;\n            } else {\n              node.typeAnnotation = this.tsNextThenParseType();\n            }\n            this.finishNode(node, nodeType);\n            this.reScan_lt_gt();\n            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);\n          }\n        }\n        return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, forInit);\n      }\n      parseImportSpecifiers() {\n        let nodes = [], first = true;\n        if (acornTypeScript.tokenIsIdentifier(this.type)) {\n          nodes.push(this.parseImportDefaultSpecifier());\n          if (!this.eat(tt.comma)) return nodes;\n        }\n        if (this.type === tt.star) {\n          nodes.push(this.parseImportNamespaceSpecifier());\n          return nodes;\n        }\n        this.expect(tt.braceL);\n        while (!this.eat(tt.braceR)) {\n          if (!first) {\n            this.expect(tt.comma);\n            if (this.afterTrailingComma(tt.braceR)) break;\n          } else first = false;\n          nodes.push(this.parseImportSpecifier());\n        }\n        return nodes;\n      }\n      /**\n       * @param {Node} node this may be ImportDeclaration |\n       * TsImportEqualsDeclaration\n       * @returns AnyImport\n       * */\n      parseImport(node) {\n        let enterHead = this.lookahead();\n        node.importKind = \"value\";\n        this.importOrExportOuterKind = \"value\";\n        if (tokenIsIdentifier(enterHead.type) || this.match(tt.star) || this.match(tt.braceL)) {\n          let ahead = this.lookahead(2);\n          if (\n            // import type, { a } from \"b\";\n            ahead.type !== tt.comma && // import type from \"a\";\n            !this.isContextualWithState(\"from\", ahead) && // import type = require(\"a\");\n            ahead.type !== tt.eq && this.ts_eatContextualWithState(\"type\", 1, enterHead)\n          ) {\n            this.importOrExportOuterKind = \"type\";\n            node.importKind = \"type\";\n            enterHead = this.lookahead();\n            ahead = this.lookahead(2);\n          }\n          if (tokenIsIdentifier(enterHead.type) && ahead.type === tt.eq) {\n            this.next();\n            const importNode = this.tsParseImportEqualsDeclaration(node);\n            this.importOrExportOuterKind = \"value\";\n            return importNode;\n          }\n        }\n        this.next();\n        if (this.type === tt.string) {\n          node.specifiers = [];\n          node.source = this.parseExprAtom();\n        } else {\n          node.specifiers = this.parseImportSpecifiers();\n          this.expectContextual(\"from\");\n          node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n        }\n        this.parseMaybeImportAttributes(node);\n        this.semicolon();\n        this.finishNode(node, \"ImportDeclaration\");\n        this.importOrExportOuterKind = \"value\";\n        if (node.importKind === \"type\" && node.specifiers.length > 1 && node.specifiers[0].type === \"ImportDefaultSpecifier\") {\n          this.raise(node.start, TypeScriptError.TypeImportCannotSpecifyDefaultAndNamed);\n        }\n        return node;\n      }\n      parseExportDefaultDeclaration() {\n        if (this.isAbstractClass()) {\n          const cls = this.startNode();\n          this.next();\n          cls.abstract = true;\n          return this.parseClass(cls, true);\n        }\n        if (this.match(tokTypes2.interface)) {\n          const result = this.tsParseInterfaceDeclaration(this.startNode());\n          if (result) return result;\n        }\n        return super.parseExportDefaultDeclaration();\n      }\n      parseExportAllDeclaration(node, exports) {\n        if (this.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseModuleExportName();\n            this.checkExport(exports, node.exported, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n        this.expectContextual(\"from\");\n        if (this.type !== tt.string) this.unexpected();\n        node.source = this.parseExprAtom();\n        this.parseMaybeImportAttributes(node);\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n      parseDynamicImport(node) {\n        this.next();\n        node.source = this.parseMaybeAssign();\n        if (this.eat(tt.comma)) {\n          const expr = this.parseExpression();\n          node.arguments = [expr];\n        }\n        if (!this.eat(tt.parenR)) {\n          const errorPos = this.start;\n          if (this.eat(tt.comma) && this.eat(tt.parenR)) {\n            this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n          } else {\n            this.unexpected(errorPos);\n          }\n        }\n        return this.finishNode(node, \"ImportExpression\");\n      }\n      parseExport(node, exports) {\n        let enterHead = this.lookahead();\n        if (this.ts_eatWithState(tt._import, 2, enterHead)) {\n          if (this.ts_isContextual(tokTypes2.type) && this.lookaheadCharCode() !== 61) {\n            node.importKind = \"type\";\n            this.importOrExportOuterKind = \"type\";\n            this.next();\n          } else {\n            node.importKind = \"value\";\n            this.importOrExportOuterKind = \"value\";\n          }\n          const exportEqualsNode = this.tsParseImportEqualsDeclaration(\n            node,\n            /* isExport */\n            true\n          );\n          this.importOrExportOuterKind = void 0;\n          return exportEqualsNode;\n        } else if (this.ts_eatWithState(tt.eq, 2, enterHead)) {\n          const assign = node;\n          assign.expression = this.parseExpression();\n          this.semicolon();\n          this.importOrExportOuterKind = void 0;\n          return this.finishNode(assign, \"TSExportAssignment\");\n        } else if (this.ts_eatContextualWithState(\"as\", 2, enterHead)) {\n          const decl = node;\n          this.expectContextual(\"namespace\");\n          decl.id = this.parseIdent();\n          this.semicolon();\n          this.importOrExportOuterKind = void 0;\n          return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n        } else {\n          if (this.ts_isContextualWithState(enterHead, tokTypes2.type) && this.lookahead(2).type === tt.braceL) {\n            this.next();\n            this.importOrExportOuterKind = \"type\";\n            node.exportKind = \"type\";\n          } else {\n            this.importOrExportOuterKind = \"value\";\n            node.exportKind = \"value\";\n          }\n          this.next();\n          if (this.eat(tt.star)) {\n            return this.parseExportAllDeclaration(node, exports);\n          }\n          if (this.eat(tt._default)) {\n            this.checkExport(exports, \"default\", this.lastTokStart);\n            node.declaration = this.parseExportDefaultDeclaration();\n            return this.finishNode(node, \"ExportDefaultDeclaration\");\n          }\n          if (this.shouldParseExportStatement()) {\n            node.declaration = this.parseExportDeclaration(node);\n            if (node.declaration.type === \"VariableDeclaration\")\n              this.checkVariableExport(exports, node.declaration.declarations);\n            else this.checkExport(exports, node.declaration.id, node.declaration.id.start);\n            node.specifiers = [];\n            node.source = null;\n          } else {\n            node.declaration = null;\n            node.specifiers = this.parseExportSpecifiers(exports);\n            if (this.eatContextual(\"from\")) {\n              if (this.type !== tt.string) this.unexpected();\n              node.source = this.parseExprAtom();\n              this.parseMaybeImportAttributes(node);\n            } else {\n              for (let spec of node.specifiers) {\n                this.checkUnreserved(spec.local);\n                this.checkLocalExport(spec.local);\n                if (spec.local.type === \"Literal\") {\n                  this.raise(\n                    spec.local.start,\n                    \"A string literal cannot be used as an exported binding without `from`.\"\n                  );\n                }\n              }\n              node.source = null;\n            }\n            this.semicolon();\n          }\n          return this.finishNode(node, \"ExportNamedDeclaration\");\n        }\n      }\n      checkExport(exports, name, _) {\n        if (!exports) {\n          return;\n        }\n        if (typeof name !== \"string\") {\n          name = name.type === \"Identifier\" ? name.name : name.value;\n        }\n        exports[name] = true;\n      }\n      parseMaybeDefault(startPos, startLoc, left) {\n        const node = super.parseMaybeDefault(startPos, startLoc, left);\n        if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n          this.raise(node.typeAnnotation.start, TypeScriptError.TypeAnnotationAfterAssign);\n        }\n        return node;\n      }\n      typeCastToParameter(node) {\n        node.expression.typeAnnotation = node.typeAnnotation;\n        this.resetEndLocation(\n          node.expression,\n          node.typeAnnotation.end,\n          node.typeAnnotation.loc?.end\n        );\n        return node.expression;\n      }\n      toAssignableList(exprList, isBinding) {\n        for (let i = 0; i < exprList.length; i++) {\n          const expr = exprList[i];\n          if (expr?.type === \"TSTypeCastExpression\") {\n            exprList[i] = this.typeCastToParameter(expr);\n          }\n        }\n        return super.toAssignableList(exprList, isBinding);\n      }\n      reportReservedArrowTypeParam(node) {\n        if (node.params.length === 1 && !node.extra?.trailingComma && disallowAmbiguousJSXLike) {\n          this.raise(node.start, TypeScriptError.ReservedArrowTypeParam);\n        }\n      }\n      parseExprAtom(refDestructuringErrors, forInit, forNew) {\n        if (this.type === tokTypes2.jsxText) {\n          return this.jsx_parseText();\n        } else if (this.type === tokTypes2.jsxTagStart) {\n          return this.jsx_parseElement();\n        } else if (this.type === tokTypes2.at) {\n          this.parseDecorators();\n          return this.parseExprAtom();\n        } else if (tokenIsIdentifier(this.type)) {\n          let canBeArrow = this.potentialArrowAt === this.start;\n          let startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n          let id = this.parseIdent(false);\n          if (this.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(tt._function)) {\n            this.overrideContext(tokContexts.f_expr);\n            return this.parseFunction(\n              this.startNodeAt(startPos, startLoc),\n              0,\n              false,\n              true,\n              forInit\n            );\n          }\n          if (canBeArrow && !this.canInsertSemicolon()) {\n            if (this.eat(tt.arrow))\n              return this.parseArrowExpression(\n                this.startNodeAt(startPos, startLoc),\n                [id],\n                false,\n                forInit\n              );\n            if (this.ecmaVersion >= 8 && id.name === \"async\" && this.type === tt.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n              id = this.parseIdent(false);\n              if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();\n              return this.parseArrowExpression(\n                this.startNodeAt(startPos, startLoc),\n                [id],\n                true,\n                forInit\n              );\n            }\n          }\n          return id;\n        } else {\n          return super.parseExprAtom(refDestructuringErrors, forInit, forNew);\n        }\n      }\n      parseExprAtomDefault() {\n        if (tokenIsIdentifier(this.type)) {\n          const canBeArrow = this[\"potentialArrowAt\"] === this.start;\n          const containsEsc = this.containsEsc;\n          const id = this.parseIdent();\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const { type } = this;\n            if (type === tt._function) {\n              this.next();\n              return this.parseFunction(this.startNodeAtNode(id), void 0, true, true);\n            } else if (tokenIsIdentifier(type)) {\n              if (this.lookaheadCharCode() === 61) {\n                const paramId = this.parseIdent(false);\n                if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();\n                return this.parseArrowExpression(this.startNodeAtNode(id), [paramId], true);\n              } else {\n                return id;\n              }\n            }\n          }\n          if (canBeArrow && this.match(tt.arrow) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n          return id;\n        } else {\n          this.unexpected();\n        }\n      }\n      parseIdentNode() {\n        let node = this.startNode();\n        if (tokenIsKeywordOrIdentifier(this.type) && // Taken from super-class method\n        !((this.type.keyword === \"class\" || this.type.keyword === \"function\") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46))) {\n          node.name = this.value;\n        } else {\n          return super.parseIdentNode();\n        }\n        return node;\n      }\n      parseVarStatement(node, kind, allowMissingInitializer = false) {\n        const { isAmbientContext } = this;\n        this.next();\n        super.parseVar(node, false, kind, allowMissingInitializer || isAmbientContext);\n        this.semicolon();\n        const declaration = this.finishNode(node, \"VariableDeclaration\");\n        if (!isAmbientContext) return declaration;\n        for (const { id, init } of declaration.declarations) {\n          if (!init) continue;\n          if (kind !== \"const\" || !!id.typeAnnotation) {\n            this.raise(init.start, TypeScriptError.InitializerNotAllowedInAmbientContext);\n          } else if (init.type !== \"StringLiteral\" && init.type !== \"BooleanLiteral\" && init.type !== \"NumericLiteral\" && init.type !== \"BigIntLiteral\" && (init.type !== \"TemplateLiteral\" || init.expressions.length > 0) && !isPossiblyLiteralEnum(init)) {\n            this.raise(\n              init.start,\n              TypeScriptError.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference\n            );\n          }\n        }\n        return declaration;\n      }\n      parseStatement(context, topLevel, exports) {\n        if (this.match(tokTypes2.at)) {\n          this.parseDecorators(true);\n        }\n        if (this.match(tt._const) && this.isLookaheadContextual(\"enum\")) {\n          const node = this.startNode();\n          this.expect(tt._const);\n          return this.tsParseEnumDeclaration(node, { const: true });\n        }\n        if (this.ts_isContextual(tokTypes2.enum)) {\n          return this.tsParseEnumDeclaration(this.startNode());\n        }\n        if (this.ts_isContextual(tokTypes2.interface)) {\n          const result = this.tsParseInterfaceDeclaration(this.startNode());\n          if (result) return result;\n        }\n        return super.parseStatement(context, topLevel, exports);\n      }\n      // NOTE: unused function\n      parseAccessModifier() {\n        return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n      }\n      parsePostMemberNameModifiers(methodOrProp) {\n        const optional = this.eat(tt.question);\n        if (optional) methodOrProp.optional = true;\n        if (methodOrProp.readonly && this.match(tt.parenL)) {\n          this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasReadonly);\n        }\n        if (methodOrProp.declare && this.match(tt.parenL)) {\n          this.raise(methodOrProp.start, TypeScriptError.ClassMethodHasDeclare);\n        }\n      }\n      // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`\n      // is that e.g. `type()` is valid JS, so we must try parsing that first.\n      // If it's really a type, we will parse `type` as the statement, and can correct it here\n      // by parsing the rest.\n      parseExpressionStatement(node, expr) {\n        const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr) : void 0;\n        return decl || super.parseExpressionStatement(node, expr);\n      }\n      shouldParseExportStatement() {\n        if (this.tsIsDeclarationStart()) return true;\n        if (this.match(tokTypes2.at)) {\n          return true;\n        }\n        return super.shouldParseExportStatement();\n      }\n      parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors) {\n        if (this.eat(tt.question)) {\n          let node = this.startNodeAt(startPos, startLoc);\n          node.test = expr;\n          node.consequent = this.parseMaybeAssign();\n          this.expect(tt.colon);\n          node.alternate = this.parseMaybeAssign(forInit);\n          return this.finishNode(node, \"ConditionalExpression\");\n        }\n        return expr;\n      }\n      parseMaybeConditional(forInit, refDestructuringErrors) {\n        let startPos = this.start, startLoc = this.startLoc;\n        let expr = this.parseExprOps(forInit, refDestructuringErrors);\n        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n        if (!this.maybeInArrowParameters || !this.match(tt.question)) {\n          return this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors);\n        }\n        const result = this.tryParse(\n          () => this.parseConditional(expr, startPos, startLoc, forInit, refDestructuringErrors)\n        );\n        if (!result.node) {\n          if (result.error) {\n            this.setOptionalParametersError(refDestructuringErrors, result.error);\n          }\n          return expr;\n        }\n        if (result.error) this.setLookaheadState(result.failState);\n        return result.node;\n      }\n      parseParenItem(node) {\n        const startPos = this.start;\n        const startLoc = this.startLoc;\n        node = super.parseParenItem(node);\n        if (this.eat(tt.question)) {\n          node.optional = true;\n          this.resetEndLocation(node);\n        }\n        if (this.match(tt.colon)) {\n          const typeCastNode = this.startNodeAt(startPos, startLoc);\n          typeCastNode.expression = node;\n          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n          return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n        }\n        return node;\n      }\n      parseExportDeclaration(node) {\n        if (!this.isAmbientContext && this.ts_isContextual(tokTypes2.declare)) {\n          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n        }\n        const startPos = this.start;\n        const startLoc = this.startLoc;\n        const isDeclare = this.eatContextual(\"declare\");\n        if (isDeclare && (this.ts_isContextual(tokTypes2.declare) || !this.shouldParseExportStatement())) {\n          this.raise(this.start, TypeScriptError.ExpectedAmbientAfterExportDeclare);\n        }\n        const isIdentifier = tokenIsIdentifier(this.type);\n        const declaration = isIdentifier && this.tsTryParseExportDeclaration() || this.parseStatement(null);\n        if (!declaration) return null;\n        if (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare) {\n          node.exportKind = \"type\";\n        }\n        if (isDeclare) {\n          this.resetStartLocation(declaration, startPos, startLoc);\n          declaration.declare = true;\n        }\n        return declaration;\n      }\n      parseClassId(node, isStatement) {\n        if (!isStatement && this.isContextual(\"implements\")) {\n          return;\n        }\n        super.parseClassId(node, isStatement);\n        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n        if (typeParameters) node.typeParameters = typeParameters;\n      }\n      parseClassPropertyAnnotation(node) {\n        if (!node.optional) {\n          if (this.value === \"!\" && this.eat(tt.prefix)) {\n            node.definite = true;\n          } else if (this.eat(tt.question)) {\n            node.optional = true;\n          }\n        }\n        const type = this.tsTryParseTypeAnnotation();\n        if (type) node.typeAnnotation = type;\n      }\n      parseClassField(field) {\n        const isPrivate = field.key.type === \"PrivateIdentifier\";\n        if (isPrivate) {\n          if (field.abstract) {\n            this.raise(field.start, TypeScriptError.PrivateElementHasAbstract);\n          }\n          if (field.accessibility) {\n            this.raise(\n              field.start,\n              TypeScriptError.PrivateElementHasAccessibility({\n                modifier: field.accessibility\n              })\n            );\n          }\n          this.parseClassPropertyAnnotation(field);\n        } else {\n          this.parseClassPropertyAnnotation(field);\n          if (this.isAmbientContext && !(field.readonly && !field.typeAnnotation) && this.match(tt.eq)) {\n            this.raise(this.start, TypeScriptError.DeclareClassFieldHasInitializer);\n          }\n          if (field.abstract && this.match(tt.eq)) {\n            const { key } = field;\n            this.raise(\n              this.start,\n              TypeScriptError.AbstractPropertyHasInitializer({\n                propertyName: key.type === \"Identifier\" && !field.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n              })\n            );\n          }\n        }\n        return super.parseClassField(field);\n      }\n      parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper) {\n        const isConstructor = method.kind === \"constructor\";\n        const isPrivate = method.key.type === \"PrivateIdentifier\";\n        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n        if (isPrivate) {\n          if (typeParameters) method.typeParameters = typeParameters;\n          if (method.accessibility) {\n            this.raise(\n              method.start,\n              TypeScriptError.PrivateMethodsHasAccessibility({\n                modifier: method.accessibility\n              })\n            );\n          }\n        } else {\n          if (typeParameters && isConstructor) {\n            this.raise(typeParameters.start, TypeScriptError.ConstructorHasTypeParameters);\n          }\n        }\n        const { declare = false, kind } = method;\n        if (declare && (kind === \"get\" || kind === \"set\")) {\n          this.raise(method.start, TypeScriptError.DeclareAccessor({ kind }));\n        }\n        if (typeParameters) method.typeParameters = typeParameters;\n        const key = method.key;\n        if (method.kind === \"constructor\") {\n          if (isGenerator) this.raise(key.start, \"Constructor can't be a generator\");\n          if (isAsync) this.raise(key.start, \"Constructor can't be an async method\");\n        } else if (method.static && checkKeyName(method, \"prototype\")) {\n          this.raise(key.start, \"Classes may not have a static property named prototype\");\n        }\n        const value = method.value = this.parseMethod(\n          isGenerator,\n          isAsync,\n          allowsDirectSuper,\n          true,\n          method\n        );\n        if (method.kind === \"get\" && value[\"params\"].length !== 0)\n          this.raiseRecoverable(value.start, \"getter should have no params\");\n        if (method.kind === \"set\" && value[\"params\"].length !== 1)\n          this.raiseRecoverable(value.start, \"setter should have exactly one param\");\n        if (method.kind === \"set\" && value[\"params\"][0].type === \"RestElement\")\n          this.raiseRecoverable(value[\"params\"][0].start, \"Setter cannot use rest params\");\n        return this.finishNode(method, \"MethodDefinition\");\n      }\n      isClassMethod() {\n        return this.match(tt.relational);\n      }\n      parseClassElement(constructorAllowsSuper) {\n        if (this.eat(tt.semi)) return null;\n        let node = this.startNode();\n        let keyName = \"\";\n        let isGenerator = false;\n        let isAsync = false;\n        let kind = \"method\";\n        let isStatic = false;\n        const modifiers = [\n          \"declare\",\n          \"private\",\n          \"public\",\n          \"protected\",\n          \"accessor\",\n          \"override\",\n          \"abstract\",\n          \"readonly\",\n          \"static\"\n        ];\n        const modifierMap = this.tsParseModifiers({\n          modified: node,\n          allowedModifiers: modifiers,\n          disallowedModifiers: [\"in\", \"out\"],\n          stopOnStartOfClassStaticBlock: true,\n          errorTemplate: TypeScriptError.InvalidModifierOnTypeParameterPositions\n        });\n        isStatic = Boolean(modifierMap.static);\n        const callParseClassMemberWithIsStatic = () => {\n          if (this.tsIsStartOfStaticBlocks()) {\n            this.next();\n            this.next();\n            if (this.tsHasSomeModifiers(node, modifiers)) {\n              this.raise(this.start, TypeScriptError.StaticBlockCannotHaveModifier);\n            }\n            if (this.ecmaVersion >= 13) {\n              super.parseClassStaticBlock(node);\n              return node;\n            }\n          } else {\n            const idx = this.tsTryParseIndexSignature(node);\n            if (idx) {\n              if (node.abstract) {\n                this.raise(node.start, TypeScriptError.IndexSignatureHasAbstract);\n              }\n              if (node.accessibility) {\n                this.raise(\n                  node.start,\n                  TypeScriptError.IndexSignatureHasAccessibility({\n                    modifier: node.accessibility\n                  })\n                );\n              }\n              if (node.declare) {\n                this.raise(node.start, TypeScriptError.IndexSignatureHasDeclare);\n              }\n              if (node.override) {\n                this.raise(node.start, TypeScriptError.IndexSignatureHasOverride);\n              }\n              return idx;\n            }\n            if (!this.inAbstractClass && node.abstract) {\n              this.raise(node.start, TypeScriptError.NonAbstractClassHasAbstractMethod);\n            }\n            if (node.override) {\n              if (!constructorAllowsSuper) {\n                this.raise(node.start, TypeScriptError.OverrideNotInSubClass);\n              }\n            }\n            node.static = isStatic;\n            if (isStatic) {\n              if (!(this.isClassElementNameStart() || this.type === tt.star)) {\n                keyName = \"static\";\n              }\n            }\n            if (!keyName && this.ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n              if ((this.isClassElementNameStart() || this.type === tt.star) && !this.canInsertSemicolon()) {\n                isAsync = true;\n              } else {\n                keyName = \"async\";\n              }\n            }\n            if (!keyName && (this.ecmaVersion >= 9 || !isAsync) && this.eat(tt.star)) {\n              isGenerator = true;\n            }\n            if (!keyName && !isAsync && !isGenerator) {\n              const lastValue = this.value;\n              if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n                if (this.isClassElementNameStart()) {\n                  kind = lastValue;\n                } else {\n                  keyName = lastValue;\n                }\n              }\n            }\n            if (keyName) {\n              node.computed = false;\n              node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n              node.key.name = keyName;\n              this.finishNode(node.key, \"Identifier\");\n            } else {\n              this.parseClassElementName(node);\n            }\n            this.parsePostMemberNameModifiers(node);\n            if (this.isClassMethod() || this.ecmaVersion < 13 || this.type === tt.parenL || kind !== \"method\" || isGenerator || isAsync) {\n              const isConstructor = !node.static && checkKeyName(node, \"constructor\");\n              const allowsDirectSuper = isConstructor && constructorAllowsSuper;\n              if (isConstructor && kind !== \"method\")\n                this.raise(node.key.start, \"Constructor can't have get/set modifier\");\n              node.kind = isConstructor ? \"constructor\" : kind;\n              this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n            } else {\n              this.parseClassField(node);\n            }\n            return node;\n          }\n        };\n        if (node.declare) {\n          this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n        } else {\n          callParseClassMemberWithIsStatic();\n        }\n        return node;\n      }\n      isClassElementNameStart() {\n        if (this.tsIsIdentifier()) {\n          return true;\n        }\n        return super.isClassElementNameStart();\n      }\n      parseClassSuper(node) {\n        super.parseClassSuper(node);\n        if (node.superClass && (this.tsMatchLeftRelational() || this.match(tt.bitShift))) {\n          node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n        }\n        if (this.eatContextual(\"implements\")) {\n          node.implements = this.tsParseHeritageClause(\"implements\");\n        }\n      }\n      parseFunctionParams(node) {\n        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n        if (typeParameters) node.typeParameters = typeParameters;\n        super.parseFunctionParams(node);\n      }\n      // `let x: number;`\n      parseVarId(decl, kind) {\n        super.parseVarId(decl, kind);\n        if (decl.id.type === \"Identifier\" && !this.hasPrecedingLineBreak() && this.value === \"!\" && this.eat(tt.prefix)) {\n          decl.definite = true;\n        }\n        const type = this.tsTryParseTypeAnnotation();\n        if (type) {\n          decl.id.typeAnnotation = type;\n          this.resetEndLocation(decl.id);\n        }\n      }\n      // parse the return type of an async arrow function - let foo = (async (): number => {});\n      parseArrowExpression(node, params, isAsync, forInit) {\n        if (this.match(tt.colon)) {\n          node.returnType = this.tsParseTypeAnnotation();\n        }\n        let oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.enterScope(functionFlags(isAsync, false) | acornScope.SCOPE_ARROW);\n        this.initFunction(node);\n        const oldMaybeInArrowParameters = this.maybeInArrowParameters;\n        if (this.ecmaVersion >= 8) node.async = !!isAsync;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        this.maybeInArrowParameters = true;\n        node.params = this.toAssignableList(params, true);\n        this.maybeInArrowParameters = false;\n        this.parseFunctionBody(node, true, false, forInit);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        this.maybeInArrowParameters = oldMaybeInArrowParameters;\n        return this.finishNode(node, \"ArrowFunctionExpression\");\n      }\n      parseMaybeAssignOrigin(forInit, refDestructuringErrors, afterLeftParse) {\n        if (this.isContextual(\"yield\")) {\n          if (this.inGenerator) return this.parseYield(forInit);\n          else this.exprAllowed = false;\n        }\n        let ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n        if (refDestructuringErrors) {\n          oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n          oldTrailingComma = refDestructuringErrors.trailingComma;\n          oldDoubleProto = refDestructuringErrors.doubleProto;\n          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n        } else {\n          refDestructuringErrors = new DestructuringErrors();\n          ownDestructuringErrors = true;\n        }\n        let startPos = this.start, startLoc = this.startLoc;\n        if (this.type === tt.parenL || tokenIsIdentifier(this.type)) {\n          this.potentialArrowAt = this.start;\n          this.potentialArrowInForAwait = forInit === \"await\";\n        }\n        let left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n        if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);\n        if (this.type.isAssign) {\n          let node = this.startNodeAt(startPos, startLoc);\n          node.operator = this.value;\n          if (this.type === tt.eq) left = this.toAssignable(left, true, refDestructuringErrors);\n          if (!ownDestructuringErrors) {\n            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n          }\n          if (refDestructuringErrors.shorthandAssign >= left.start)\n            refDestructuringErrors.shorthandAssign = -1;\n          if (!this.maybeInArrowParameters) {\n            if (this.type === tt.eq) this.checkLValPattern(left);\n            else this.checkLValSimple(left);\n          }\n          node.left = left;\n          this.next();\n          node.right = this.parseMaybeAssign(forInit);\n          if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;\n          return this.finishNode(node, \"AssignmentExpression\");\n        } else {\n          if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);\n        }\n        if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n        if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;\n        return left;\n      }\n      parseMaybeAssign(forInit, refExpressionErrors, afterLeftParse) {\n        let state;\n        let jsx;\n        let typeCast;\n        if (options?.jsx && (this.matchJsx(\"jsxTagStart\") || this.tsMatchLeftRelational())) {\n          state = this.cloneCurLookaheadState();\n          jsx = this.tryParse(\n            () => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse),\n            state\n          );\n          if (!jsx.error) return jsx.node;\n          const context = this.context;\n          const currentContext = context[context.length - 1];\n          const lastCurrentContext = context[context.length - 2];\n          if (currentContext === acornTypeScript.tokContexts.tc_oTag && lastCurrentContext === acornTypeScript.tokContexts.tc_expr) {\n            context.pop();\n            context.pop();\n          } else if (currentContext === acornTypeScript.tokContexts.tc_oTag || currentContext === acornTypeScript.tokContexts.tc_expr) {\n            context.pop();\n          }\n        }\n        if (!jsx?.error && !this.tsMatchLeftRelational()) {\n          return this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);\n        }\n        if (!state || this.compareLookaheadState(state, this.getCurLookaheadState())) {\n          state = this.cloneCurLookaheadState();\n        }\n        let typeParameters;\n        const arrow = this.tryParse((abort) => {\n          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n          const expr = this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse);\n          if (expr.type !== \"ArrowFunctionExpression\" || expr.extra?.parenthesized) {\n            abort();\n          }\n          if (typeParameters?.params.length !== 0) {\n            this.resetStartLocationFromNode(expr, typeParameters);\n          }\n          expr.typeParameters = typeParameters;\n          return expr;\n        }, state);\n        if (!arrow.error && !arrow.aborted) {\n          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n          return arrow.node;\n        }\n        if (!jsx) {\n          assert(true);\n          typeCast = this.tryParse(\n            () => this.parseMaybeAssignOrigin(forInit, refExpressionErrors, afterLeftParse),\n            state\n          );\n          if (!typeCast.error) return typeCast.node;\n        }\n        if (jsx?.node) {\n          this.setLookaheadState(jsx.failState);\n          return jsx.node;\n        }\n        if (arrow.node) {\n          this.setLookaheadState(arrow.failState);\n          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n          return arrow.node;\n        }\n        if (typeCast?.node) {\n          this.setLookaheadState(typeCast.failState);\n          return typeCast.node;\n        }\n        if (jsx?.thrown) throw jsx.error;\n        if (arrow.thrown) throw arrow.error;\n        if (typeCast?.thrown) throw typeCast.error;\n        throw jsx?.error || arrow.error || typeCast?.error;\n      }\n      parseAssignableListItem(allowModifiers) {\n        const decorators = [];\n        while (this.match(tokTypes2.at)) {\n          decorators.push(this.parseDecorator());\n        }\n        const startPos = this.start;\n        const startLoc = this.startLoc;\n        let accessibility;\n        let readonly = false;\n        let override = false;\n        if (allowModifiers !== void 0) {\n          const modified = {};\n          this.tsParseModifiers({\n            modified,\n            allowedModifiers: [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]\n          });\n          accessibility = modified.accessibility;\n          override = modified.override;\n          readonly = modified.readonly;\n          if (allowModifiers === false && (accessibility || readonly || override)) {\n            this.raise(startLoc.start, TypeScriptError.UnexpectedParameterModifier);\n          }\n        }\n        const left = this.parseMaybeDefault(startPos, startLoc);\n        this.parseBindingListItem(left);\n        const elt = this.parseMaybeDefault(left[\"start\"], left[\"loc\"], left);\n        if (decorators.length) {\n          elt.decorators = decorators;\n        }\n        if (accessibility || readonly || override) {\n          const pp = this.startNodeAt(startPos, startLoc);\n          if (accessibility) pp.accessibility = accessibility;\n          if (readonly) pp.readonly = readonly;\n          if (override) pp.override = override;\n          if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n            this.raise(pp.start, TypeScriptError.UnsupportedParameterPropertyKind);\n          }\n          pp.parameter = elt;\n          return this.finishNode(pp, \"TSParameterProperty\");\n        }\n        return elt;\n      }\n      // AssignmentPattern\n      checkLValInnerPattern(expr, bindingType = acornScope.BIND_NONE, checkClashes) {\n        switch (expr.type) {\n          case \"TSParameterProperty\":\n            this.checkLValInnerPattern(expr.parameter, bindingType, checkClashes);\n            break;\n          default: {\n            super.checkLValInnerPattern(expr, bindingType, checkClashes);\n            break;\n          }\n        }\n      }\n      // Allow type annotations inside of a parameter list.\n      parseBindingListItem(param) {\n        if (this.eat(tt.question)) {\n          if (param.type !== \"Identifier\" && !this.isAmbientContext && !this.inType) {\n            this.raise(param.start, TypeScriptError.PatternIsOptional);\n          }\n          param.optional = true;\n        }\n        const type = this.tsTryParseTypeAnnotation();\n        if (type) param.typeAnnotation = type;\n        this.resetEndLocation(param);\n        return param;\n      }\n      isAssignable(node, isBinding) {\n        switch (node.type) {\n          case \"TSTypeCastExpression\":\n            return this.isAssignable(node.expression, isBinding);\n          case \"TSParameterProperty\":\n            return true;\n          case \"Identifier\":\n          case \"ObjectPattern\":\n          case \"ArrayPattern\":\n          case \"AssignmentPattern\":\n          case \"RestElement\":\n            return true;\n          case \"ObjectExpression\": {\n            const last = node.properties.length - 1;\n            return node.properties.every((prop, i) => {\n              return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n            });\n          }\n          case \"Property\":\n          case \"ObjectProperty\":\n            return this.isAssignable(node.value);\n          case \"SpreadElement\":\n            return this.isAssignable(node.argument);\n          case \"ArrayExpression\":\n            return node.elements.every(\n              (element) => element === null || this.isAssignable(element)\n            );\n          case \"AssignmentExpression\":\n            return node.operator === \"=\";\n          case \"ParenthesizedExpression\":\n            return this.isAssignable(node.expression);\n          case \"MemberExpression\":\n          case \"OptionalMemberExpression\":\n            return !isBinding;\n          default:\n            return false;\n        }\n      }\n      toAssignable(node, isBinding = false, refDestructuringErrors = new DestructuringErrors()) {\n        switch (node.type) {\n          case \"ParenthesizedExpression\":\n            return this.toAssignableParenthesizedExpression(\n              node,\n              isBinding,\n              refDestructuringErrors\n            );\n          case \"TSAsExpression\":\n          case \"TSSatisfiesExpression\":\n          case \"TSNonNullExpression\":\n          case \"TSTypeAssertion\":\n            if (isBinding) {\n            } else {\n              this.raise(node.start, TypeScriptError.UnexpectedTypeCastInParameter);\n            }\n            return this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n          case \"MemberExpression\":\n            break;\n          case \"AssignmentExpression\":\n            if (!isBinding && node.left.type === \"TSTypeCastExpression\") {\n              node.left = this.typeCastToParameter(node.left);\n            }\n            return super.toAssignable(node, isBinding, refDestructuringErrors);\n          case \"TSTypeCastExpression\": {\n            return this.typeCastToParameter(node);\n          }\n          default:\n            return super.toAssignable(node, isBinding, refDestructuringErrors);\n        }\n        return node;\n      }\n      toAssignableParenthesizedExpression(node, isBinding, refDestructuringErrors) {\n        switch (node.expression.type) {\n          case \"TSAsExpression\":\n          case \"TSSatisfiesExpression\":\n          case \"TSNonNullExpression\":\n          case \"TSTypeAssertion\":\n          case \"ParenthesizedExpression\":\n            return this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n          default:\n            return super.toAssignable(node, isBinding, refDestructuringErrors);\n        }\n      }\n      parseBindingAtom() {\n        switch (this.type) {\n          case tt._this:\n            return this.parseIdent(\n              /* liberal */\n              true\n            );\n          default:\n            return super.parseBindingAtom();\n        }\n      }\n      shouldParseArrow(exprList) {\n        let shouldParseArrowRes;\n        if (this.match(tt.colon)) {\n          shouldParseArrowRes = exprList.every((expr) => this.isAssignable(expr, true));\n        } else {\n          shouldParseArrowRes = !this.canInsertSemicolon();\n        }\n        if (shouldParseArrowRes) {\n          if (this.match(tt.colon)) {\n            const result = this.tryParse((abort) => {\n              const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\n              if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();\n              return returnType;\n            });\n            if (result.aborted) {\n              this.shouldParseArrowReturnType = void 0;\n              return false;\n            }\n            if (!result.thrown) {\n              if (result.error) this.setLookaheadState(result.failState);\n              this.shouldParseArrowReturnType = result.node;\n            }\n          }\n          if (!this.match(tt.arrow)) {\n            this.shouldParseArrowReturnType = void 0;\n            return false;\n          }\n          return true;\n        }\n        this.shouldParseArrowReturnType = void 0;\n        return shouldParseArrowRes;\n      }\n      parseParenArrowList(startPos, startLoc, exprList, forInit) {\n        const node = this.startNodeAt(startPos, startLoc);\n        node.returnType = this.shouldParseArrowReturnType;\n        this.shouldParseArrowReturnType = void 0;\n        return this.parseArrowExpression(node, exprList, false, forInit);\n      }\n      parseParenAndDistinguishExpression(canBeArrow, forInit) {\n        let startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.ecmaVersion >= 8;\n        if (this.ecmaVersion >= 6) {\n          const oldMaybeInArrowParameters = this.maybeInArrowParameters;\n          this.maybeInArrowParameters = true;\n          this.next();\n          let innerStartPos = this.start, innerStartLoc = this.startLoc;\n          let exprList = [], first = true, lastIsComma = false;\n          let refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n          this.yieldPos = 0;\n          this.awaitPos = 0;\n          while (this.type !== tt.parenR) {\n            first ? first = false : this.expect(tt.comma);\n            if (allowTrailingComma && this.afterTrailingComma(tt.parenR, true)) {\n              lastIsComma = true;\n              break;\n            } else if (this.type === tt.ellipsis) {\n              spreadStart = this.start;\n              exprList.push(this.parseParenItem(this.parseRestBinding()));\n              if (this.type === tt.comma) {\n                this.raise(this.start, \"Comma is not permitted after the rest element\");\n              }\n              break;\n            } else {\n              exprList.push(\n                this.parseMaybeAssign(forInit, refDestructuringErrors, this.parseParenItem)\n              );\n            }\n          }\n          let innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n          this.expect(tt.parenR);\n          this.maybeInArrowParameters = oldMaybeInArrowParameters;\n          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(tt.arrow)) {\n            this.checkPatternErrors(refDestructuringErrors, false);\n            this.checkYieldAwaitInDefaultParams();\n            this.yieldPos = oldYieldPos;\n            this.awaitPos = oldAwaitPos;\n            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);\n          }\n          if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);\n          if (spreadStart) this.unexpected(spreadStart);\n          this.checkExpressionErrors(refDestructuringErrors, true);\n          this.yieldPos = oldYieldPos || this.yieldPos;\n          this.awaitPos = oldAwaitPos || this.awaitPos;\n          if (exprList.length > 1) {\n            val = this.startNodeAt(innerStartPos, innerStartLoc);\n            val.expressions = exprList;\n            this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n          } else {\n            val = exprList[0];\n          }\n        } else {\n          val = this.parseParenExpression();\n        }\n        if (this.options.preserveParens) {\n          let par = this.startNodeAt(startPos, startLoc);\n          par.expression = val;\n          return this.finishNode(par, \"ParenthesizedExpression\");\n        } else {\n          return val;\n        }\n      }\n      parseTaggedTemplateExpression(base, startPos, startLoc, optionalChainMember) {\n        const node = this.startNodeAt(startPos, startLoc);\n        node.tag = base;\n        node.quasi = this.parseTemplate({ isTagged: true });\n        if (optionalChainMember) {\n          this.raise(\n            startPos,\n            \"Tagged Template Literals are not allowed in optionalChain.\"\n          );\n        }\n        return this.finishNode(node, \"TaggedTemplateExpression\");\n      }\n      shouldParseAsyncArrow() {\n        if (this.match(tt.colon)) {\n          const result = this.tryParse((abort) => {\n            const returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\n            if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();\n            return returnType;\n          });\n          if (result.aborted) {\n            this.shouldParseAsyncArrowReturnType = void 0;\n            return false;\n          }\n          if (!result.thrown) {\n            if (result.error) this.setLookaheadState(result.failState);\n            this.shouldParseAsyncArrowReturnType = result.node;\n            return !this.canInsertSemicolon() && this.eat(tt.arrow);\n          }\n        } else {\n          return !this.canInsertSemicolon() && this.eat(tt.arrow);\n        }\n      }\n      parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit) {\n        const arrN = this.startNodeAt(startPos, startLoc);\n        arrN.returnType = this.shouldParseAsyncArrowReturnType;\n        this.shouldParseAsyncArrowReturnType = void 0;\n        return this.parseArrowExpression(arrN, exprList, true, forInit);\n      }\n      parseExprList(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n        let elts = [], first = true;\n        while (!this.eat(close)) {\n          if (!first) {\n            this.expect(tt.comma);\n            if (allowTrailingComma && this.afterTrailingComma(close)) break;\n          } else first = false;\n          let elt;\n          if (allowEmpty && this.type === tt.comma) elt = null;\n          else if (this.type === tt.ellipsis) {\n            elt = this.parseSpread(refDestructuringErrors);\n            if (this.maybeInArrowParameters && this.match(tt.colon)) {\n              elt.typeAnnotation = this.tsParseTypeAnnotation();\n            }\n            if (refDestructuringErrors && this.type === tt.comma && refDestructuringErrors.trailingComma < 0)\n              refDestructuringErrors.trailingComma = this.start;\n          } else {\n            elt = this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem);\n          }\n          elts.push(elt);\n        }\n        return elts;\n      }\n      parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n        let _optionalChained = optionalChained;\n        if (!this.hasPrecedingLineBreak() && // NODE: replace bang\n        this.value === \"!\" && this.match(tt.prefix)) {\n          this.exprAllowed = false;\n          this.next();\n          const nonNullExpression = this.startNodeAt(startPos, startLoc);\n          nonNullExpression.expression = base;\n          base = this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n          return base;\n        }\n        let isOptionalCall = false;\n        if (this.match(tt.questionDot) && this.lookaheadCharCode() === 60) {\n          if (noCalls) {\n            return base;\n          }\n          base.optional = true;\n          _optionalChained = isOptionalCall = true;\n          this.next();\n        }\n        if (this.tsMatchLeftRelational() || this.match(tt.bitShift)) {\n          let missingParenErrorLoc;\n          const result = this.tsTryParseAndCatch(() => {\n            if (!noCalls && this.atPossibleAsyncArrow(base)) {\n              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(\n                startPos,\n                startLoc,\n                forInit\n              );\n              if (asyncArrowFn) {\n                base = asyncArrowFn;\n                return base;\n              }\n            }\n            const typeArguments = this.tsParseTypeArgumentsInExpression();\n            if (!typeArguments) return base;\n            if (isOptionalCall && !this.match(tt.parenL)) {\n              missingParenErrorLoc = this.curPosition();\n              return base;\n            }\n            if (tokenIsTemplate(this.type) || this.type === tt.backQuote) {\n              const result2 = this.parseTaggedTemplateExpression(\n                base,\n                startPos,\n                startLoc,\n                _optionalChained\n              );\n              result2.typeArguments = typeArguments;\n              return result2;\n            }\n            if (!noCalls && this.eat(tt.parenL)) {\n              let refDestructuringErrors = new DestructuringErrors();\n              const node2 = this.startNodeAt(startPos, startLoc);\n              node2.callee = base;\n              node2.arguments = this.parseExprList(\n                tt.parenR,\n                this.ecmaVersion >= 8,\n                false,\n                refDestructuringErrors\n              );\n              this.tsCheckForInvalidTypeCasts(node2.arguments);\n              node2.typeArguments = typeArguments;\n              if (_optionalChained) {\n                node2.optional = isOptionalCall;\n              }\n              this.checkExpressionErrors(refDestructuringErrors, true);\n              base = this.finishNode(node2, \"CallExpression\");\n              return base;\n            }\n            const tokenType = this.type;\n            if (\n              // a<b>>c is not (a<b>)>c, but a<(b>>c)\n              this.tsMatchRightRelational() || // a<b>>>c is not (a<b>)>>c, but a<(b>>>c)\n              tokenType === tt.bitShift || // a<b>c is (a<b)>c\n              tokenType !== tt.parenL && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()\n            ) {\n              return;\n            }\n            const node = this.startNodeAt(startPos, startLoc);\n            node.expression = base;\n            node.typeArguments = typeArguments;\n            return this.finishNode(node, \"TSInstantiationExpression\");\n          });\n          if (missingParenErrorLoc) {\n            this.unexpected(missingParenErrorLoc);\n          }\n          if (result) {\n            if (result.type === \"TSInstantiationExpression\" && (this.match(tt.dot) || this.match(tt.questionDot) && this.lookaheadCharCode() !== 40)) {\n              this.raise(\n                this.start,\n                TypeScriptError.InvalidPropertyAccessAfterInstantiationExpression\n              );\n            }\n            base = result;\n            return base;\n          }\n        }\n        let optionalSupported = this.ecmaVersion >= 11;\n        let optional = optionalSupported && this.eat(tt.questionDot);\n        if (noCalls && optional)\n          this.raise(\n            this.lastTokStart,\n            \"Optional chaining cannot appear in the callee of new expressions\"\n          );\n        let computed = this.eat(tt.bracketL);\n        if (computed || optional && this.type !== tt.parenL && this.type !== tt.backQuote || this.eat(tt.dot)) {\n          let node = this.startNodeAt(startPos, startLoc);\n          node.object = base;\n          if (computed) {\n            node.property = this.parseExpression();\n            this.expect(tt.bracketR);\n          } else if (this.type === tt.privateId && base.type !== \"Super\") {\n            node.property = this.parsePrivateIdent();\n          } else {\n            node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n          }\n          node.computed = !!computed;\n          if (optionalSupported) {\n            node.optional = optional;\n          }\n          base = this.finishNode(node, \"MemberExpression\");\n        } else if (!noCalls && this.eat(tt.parenL)) {\n          const oldMaybeInArrowParameters = this.maybeInArrowParameters;\n          this.maybeInArrowParameters = true;\n          let refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n          this.yieldPos = 0;\n          this.awaitPos = 0;\n          this.awaitIdentPos = 0;\n          let exprList = this.parseExprList(\n            tt.parenR,\n            this.ecmaVersion >= 8,\n            false,\n            refDestructuringErrors\n          );\n          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n            this.checkPatternErrors(refDestructuringErrors, false);\n            this.checkYieldAwaitInDefaultParams();\n            if (this.awaitIdentPos > 0)\n              this.raise(\n                this.awaitIdentPos,\n                \"Cannot use 'await' as identifier inside an async function\"\n              );\n            this.yieldPos = oldYieldPos;\n            this.awaitPos = oldAwaitPos;\n            this.awaitIdentPos = oldAwaitIdentPos;\n            base = this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);\n          } else {\n            this.checkExpressionErrors(refDestructuringErrors, true);\n            this.yieldPos = oldYieldPos || this.yieldPos;\n            this.awaitPos = oldAwaitPos || this.awaitPos;\n            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n            let node = this.startNodeAt(startPos, startLoc);\n            node.callee = base;\n            node.arguments = exprList;\n            if (optionalSupported) {\n              node.optional = optional;\n            }\n            base = this.finishNode(node, \"CallExpression\");\n          }\n          this.maybeInArrowParameters = oldMaybeInArrowParameters;\n        } else if (this.type === tt.backQuote) {\n          if (optional || _optionalChained) {\n            this.raise(\n              this.start,\n              \"Optional chaining cannot appear in the tag of tagged template expressions\"\n            );\n          }\n          let node = this.startNodeAt(startPos, startLoc);\n          node.tag = base;\n          node.quasi = this.parseTemplate({ isTagged: true });\n          base = this.finishNode(node, \"TaggedTemplateExpression\");\n        }\n        return base;\n      }\n      parseGetterSetter(prop) {\n        prop.kind = prop.key.name;\n        this.parsePropertyName(prop);\n        prop.value = this.parseMethod(false);\n        let paramCount = prop.kind === \"get\" ? 0 : 1;\n        const firstParam = prop.value.params[0];\n        const hasContextParam = firstParam && this.isThisParam(firstParam);\n        paramCount = hasContextParam ? paramCount + 1 : paramCount;\n        if (prop.value.params.length !== paramCount) {\n          let start = prop.value.start;\n          if (prop.kind === \"get\") this.raiseRecoverable(start, \"getter should have no params\");\n          else this.raiseRecoverable(start, \"setter should have exactly one param\");\n        } else {\n          if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n            this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n        }\n      }\n      parseProperty(isPattern, refDestructuringErrors) {\n        if (!isPattern) {\n          let decorators = [];\n          if (this.match(tokTypes2.at)) {\n            while (this.match(tokTypes2.at)) {\n              decorators.push(this.parseDecorator());\n            }\n          }\n          const property = super.parseProperty(isPattern, refDestructuringErrors);\n          if (property.type === \"SpreadElement\") {\n            if (decorators.length)\n              this.raise(property.start, DecoratorsError.SpreadElementDecorator);\n          }\n          if (decorators.length) {\n            property.decorators = decorators;\n            decorators = [];\n          }\n          return property;\n        }\n        return super.parseProperty(isPattern, refDestructuringErrors);\n      }\n      parseCatchClauseParam() {\n        const param = this.parseBindingAtom();\n        let simple = param.type === \"Identifier\";\n        this.enterScope(simple ? acornScope.SCOPE_SIMPLE_CATCH : 0);\n        this.checkLValPattern(\n          param,\n          simple ? acornScope.BIND_SIMPLE_CATCH : acornScope.BIND_LEXICAL\n        );\n        const type = this.tsTryParseTypeAnnotation();\n        if (type) {\n          param.typeAnnotation = type;\n          this.resetEndLocation(param);\n        }\n        this.expect(tt.parenR);\n        return param;\n      }\n      parseClass(node, isStatement) {\n        const oldInAbstractClass = this.inAbstractClass;\n        this.inAbstractClass = !!node.abstract;\n        try {\n          this.next();\n          this.takeDecorators(node);\n          const oldStrict = this.strict;\n          this.strict = true;\n          this.parseClassId(node, isStatement);\n          this.parseClassSuper(node);\n          const privateNameMap = this.enterClassBody();\n          const classBody = this.startNode();\n          let hadConstructor = false;\n          classBody.body = [];\n          let decorators = [];\n          this.expect(tt.braceL);\n          while (this.type !== tt.braceR) {\n            if (this.match(tokTypes2.at)) {\n              decorators.push(this.parseDecorator());\n              continue;\n            }\n            const element = this.parseClassElement(node.superClass !== null);\n            if (decorators.length) {\n              element.decorators = decorators;\n              this.resetStartLocationFromNode(element, decorators[0]);\n              decorators = [];\n            }\n            if (element) {\n              classBody.body.push(element);\n              if (element.type === \"MethodDefinition\" && element.kind === \"constructor\" && element.value.type === \"FunctionExpression\") {\n                if (hadConstructor) {\n                  this.raiseRecoverable(element.start, \"Duplicate constructor in the same class\");\n                }\n                hadConstructor = true;\n                if (element.decorators && element.decorators.length > 0) {\n                  this.raise(element.start, DecoratorsError.DecoratorConstructor);\n                }\n              } else if (element.key && element.key.type === \"PrivateIdentifier\" && isPrivateNameConflicted(privateNameMap, element)) {\n                this.raiseRecoverable(\n                  element.key.start,\n                  `Identifier '#${element.key.name}' has already been declared`\n                );\n              }\n            }\n          }\n          this.strict = oldStrict;\n          this.next();\n          if (decorators.length) {\n            this.raise(this.start, DecoratorsError.TrailingDecorator);\n          }\n          node.body = this.finishNode(classBody, \"ClassBody\");\n          this.exitClassBody();\n          return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n        } finally {\n          this.inAbstractClass = oldInAbstractClass;\n        }\n      }\n      parseClassFunctionParams() {\n        const typeParameters = this.tsTryParseTypeParameters();\n        let params = this.parseBindingList(tt.parenR, false, this.ecmaVersion >= 8, true);\n        if (typeParameters) params.typeParameters = typeParameters;\n        return params;\n      }\n      parseMethod(isGenerator, isAsync, allowDirectSuper, inClassScope, method) {\n        let node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.initFunction(node);\n        if (this.ecmaVersion >= 6) node.generator = isGenerator;\n        if (this.ecmaVersion >= 8) node.async = !!isAsync;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        this.enterScope(\n          functionFlags(isAsync, node.generator) | acornScope.SCOPE_SUPER | (allowDirectSuper ? acornScope.SCOPE_DIRECT_SUPER : 0)\n        );\n        this.expect(tt.parenL);\n        node.params = this.parseClassFunctionParams();\n        this.checkYieldAwaitInDefaultParams();\n        this.parseFunctionBody(node, false, true, false, {\n          isClassMethod: inClassScope\n        });\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        if (method && method.abstract) {\n          const hasBody = !!node.body;\n          if (hasBody) {\n            const { key } = method;\n            this.raise(\n              method.start,\n              TypeScriptError.AbstractMethodHasImplementation({\n                methodName: key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n              })\n            );\n          }\n        }\n        return this.finishNode(node, \"FunctionExpression\");\n      }\n      static parse(input, options2) {\n        if (options2.locations === false) {\n          throw new Error(`You have to enable options.locations while using acorn-typescript`);\n        } else {\n          options2.locations = true;\n        }\n        const parser = new this(options2, input);\n        if (dts) {\n          parser.isAmbientContext = true;\n        }\n        return parser.parse();\n      }\n      static parseExpressionAt(input, pos, options2) {\n        if (options2.locations === false) {\n          throw new Error(`You have to enable options.locations while using acorn-typescript`);\n        } else {\n          options2.locations = true;\n        }\n        const parser = new this(options2, input, pos);\n        if (dts) {\n          parser.isAmbientContext = true;\n        }\n        parser.nextToken();\n        return parser.parseExpression();\n      }\n      parseImportSpecifier() {\n        const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);\n        if (isMaybeTypeOnly) {\n          let node = this.startNode();\n          node.imported = this.parseModuleExportName();\n          this.parseTypeOnlyImportExportSpecifier(\n            node,\n            /* isImport */\n            true,\n            this.importOrExportOuterKind === \"type\"\n          );\n          return this.finishNode(node, \"ImportSpecifier\");\n        } else {\n          const node = super.parseImportSpecifier();\n          node.importKind = \"value\";\n          return node;\n        }\n      }\n      parseExportSpecifier(exports) {\n        const isMaybeTypeOnly = this.ts_isContextual(tokTypes2.type);\n        const isString = this.match(tt.string);\n        if (!isString && isMaybeTypeOnly) {\n          let node = this.startNode();\n          node.local = this.parseModuleExportName();\n          this.parseTypeOnlyImportExportSpecifier(\n            node,\n            /* isImport */\n            false,\n            this.importOrExportOuterKind === \"type\"\n          );\n          this.finishNode(node, \"ExportSpecifier\");\n          this.checkExport(exports, node.exported, node.exported.start);\n          return node;\n        } else {\n          const node = super.parseExportSpecifier(exports);\n          node.exportKind = \"value\";\n          return node;\n        }\n      }\n      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n        const leftOfAsKey = isImport ? \"imported\" : \"local\";\n        const rightOfAsKey = isImport ? \"local\" : \"exported\";\n        let leftOfAs = node[leftOfAsKey];\n        let rightOfAs;\n        let hasTypeSpecifier = false;\n        let canParseAsKeyword = true;\n        const loc = leftOfAs.start;\n        if (this.isContextual(\"as\")) {\n          const firstAs = this.parseIdent();\n          if (this.isContextual(\"as\")) {\n            const secondAs = this.parseIdent();\n            if (tokenIsKeywordOrIdentifier(this.type)) {\n              hasTypeSpecifier = true;\n              leftOfAs = firstAs;\n              rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();\n              canParseAsKeyword = false;\n            } else {\n              rightOfAs = secondAs;\n              canParseAsKeyword = false;\n            }\n          } else if (tokenIsKeywordOrIdentifier(this.type)) {\n            canParseAsKeyword = false;\n            rightOfAs = isImport ? this.parseIdent() : this.parseModuleExportName();\n          } else {\n            hasTypeSpecifier = true;\n            leftOfAs = firstAs;\n          }\n        } else if (tokenIsKeywordOrIdentifier(this.type)) {\n          hasTypeSpecifier = true;\n          if (isImport) {\n            leftOfAs = super.parseIdent(true);\n            if (!this.isContextual(\"as\")) {\n              this.checkUnreserved(leftOfAs);\n            }\n          } else {\n            leftOfAs = this.parseModuleExportName();\n          }\n        }\n        if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n          this.raise(\n            loc,\n            isImport ? TypeScriptError.TypeModifierIsUsedInTypeImports : TypeScriptError.TypeModifierIsUsedInTypeExports\n          );\n        }\n        node[leftOfAsKey] = leftOfAs;\n        node[rightOfAsKey] = rightOfAs;\n        const kindKey = isImport ? \"importKind\" : \"exportKind\";\n        node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n        if (canParseAsKeyword && this.eatContextual(\"as\")) {\n          node[rightOfAsKey] = isImport ? this.parseIdent() : this.parseModuleExportName();\n        }\n        if (!node[rightOfAsKey]) {\n          node[rightOfAsKey] = this.copyNode(node[leftOfAsKey]);\n        }\n        if (isImport) {\n          this.checkLValSimple(node[rightOfAsKey], acornScope.BIND_LEXICAL);\n        }\n      }\n      raiseCommonCheck(pos, message, recoverable) {\n        switch (message) {\n          case \"Comma is not permitted after the rest element\": {\n            if (this.isAmbientContext && this.match(tt.comma) && this.lookaheadCharCode() === 41) {\n              this.next();\n              return;\n            } else {\n              return super.raise(pos, message);\n            }\n          }\n        }\n        return recoverable ? super.raiseRecoverable(pos, message) : super.raise(pos, message);\n      }\n      raiseRecoverable(pos, message) {\n        return this.raiseCommonCheck(pos, message, true);\n      }\n      raise(pos, message) {\n        return this.raiseCommonCheck(pos, message, true);\n      }\n      updateContext(prevType) {\n        const { type } = this;\n        if (type == tt.braceL) {\n          var curContext = this.curContext();\n          if (curContext == tsTokContexts.tc_oTag) this.context.push(tokContexts.b_expr);\n          else if (curContext == tsTokContexts.tc_expr) this.context.push(tokContexts.b_tmpl);\n          else super.updateContext(prevType);\n          this.exprAllowed = true;\n        } else if (type === tt.slash && prevType === tokTypes2.jsxTagStart) {\n          this.context.length -= 2;\n          this.context.push(tsTokContexts.tc_cTag);\n          this.exprAllowed = false;\n        } else {\n          return super.updateContext(prevType);\n        }\n      }\n      // Parses JSX opening tag starting after '<'.\n      jsx_parseOpeningElementAt(startPos, startLoc) {\n        let node = this.startNodeAt(startPos, startLoc);\n        let nodeName = this.jsx_parseElementName();\n        if (nodeName) node.name = nodeName;\n        if (this.match(tt.relational) || this.match(tt.bitShift)) {\n          const typeArguments = this.tsTryParseAndCatch(\n            () => this.tsParseTypeArgumentsInExpression()\n          );\n          if (typeArguments) node.typeArguments = typeArguments;\n        }\n        node.attributes = [];\n        while (this.type !== tt.slash && this.type !== tokTypes2.jsxTagEnd)\n          node.attributes.push(this.jsx_parseAttribute());\n        node.selfClosing = this.eat(tt.slash);\n        this.expect(tokTypes2.jsxTagEnd);\n        return this.finishNode(node, nodeName ? \"JSXOpeningElement\" : \"JSXOpeningFragment\");\n      }\n      enterScope(flags) {\n        if (flags === TS_SCOPE_TS_MODULE) {\n          this.importsStack.push([]);\n        }\n        super.enterScope(flags);\n        const scope = super.currentScope();\n        scope.types = [];\n        scope.enums = [];\n        scope.constEnums = [];\n        scope.classes = [];\n        scope.exportOnlyBindings = [];\n      }\n      exitScope() {\n        const scope = super.currentScope();\n        if (scope.flags === TS_SCOPE_TS_MODULE) {\n          this.importsStack.pop();\n        }\n        super.exitScope();\n      }\n      hasImport(name, allowShadow) {\n        const len = this.importsStack.length;\n        if (this.importsStack[len - 1].indexOf(name) > -1) {\n          return true;\n        }\n        if (!allowShadow && len > 1) {\n          for (let i = 0; i < len - 1; i++) {\n            if (this.importsStack[i].indexOf(name) > -1) return true;\n          }\n        }\n        return false;\n      }\n      maybeExportDefined(scope, name) {\n        if (this.inModule && scope.flags & acornScope.SCOPE_TOP) {\n          this.undefinedExports.delete(name);\n        }\n      }\n      declareName(name, bindingType, pos) {\n        if (bindingType & acornScope.BIND_FLAGS_TS_IMPORT) {\n          if (this.hasImport(name, true)) {\n            this.raise(pos, `Identifier '${name}' has already been declared.`);\n          }\n          this.importsStack[this.importsStack.length - 1].push(name);\n          return;\n        }\n        const scope = this.currentScope();\n        if (bindingType & acornScope.BIND_FLAGS_TS_EXPORT_ONLY) {\n          this.maybeExportDefined(scope, name);\n          scope.exportOnlyBindings.push(name);\n          return;\n        }\n        if (bindingType === acornScope.BIND_TS_TYPE || bindingType === acornScope.BIND_TS_INTERFACE) {\n          if (bindingType === acornScope.BIND_TS_TYPE && scope.types.includes(name)) {\n            this.raise(pos, `type '${name}' has already been declared.`);\n          }\n          scope.types.push(name);\n        } else {\n          super.declareName(name, bindingType, pos);\n        }\n        if (bindingType & acornScope.BIND_FLAGS_TS_ENUM) scope.enums.push(name);\n        if (bindingType & acornScope.BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);\n        if (bindingType & acornScope.BIND_FLAGS_CLASS) scope.classes.push(name);\n      }\n      checkLocalExport(id) {\n        const { name } = id;\n        if (this.hasImport(name)) return;\n        const len = this.scopeStack.length;\n        for (let i = len - 1; i >= 0; i--) {\n          const scope = this.scopeStack[i];\n          if (scope.types.indexOf(name) > -1 || scope.exportOnlyBindings.indexOf(name) > -1) return;\n        }\n        super.checkLocalExport(id);\n      }\n    }\n    return TypeScriptParser;\n  };\n}\nexport {\n  tsPlugin\n};\n"],
  "mappings": "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",
  "names": []
}
