import {
  VERSION
} from "./chunk-W3FP32TW.js";
import {
  require_lib
} from "./chunk-RTQQBXLT.js";
import {
  require_lib as require_lib2
} from "./chunk-5IIC2QU3.js";
import {
  escape_html
} from "./chunk-O53T737B.js";
import {
  cannot_be_set_statically,
  hash,
  is_boolean_attribute,
  is_capture_event,
  is_content_editable_binding,
  is_delegated,
  is_dom_property,
  is_load_error_element,
  is_mathml,
  is_passive_event,
  is_reserved,
  is_rune,
  is_svg,
  is_void,
  normalize_attribute,
  sanitize_location
} from "./chunk-D245TE6S.js";
import {
  EACH_INDEX_REACTIVE,
  EACH_IS_ANIMATED,
  EACH_IS_CONTROLLED,
  EACH_ITEM_IMMUTABLE,
  EACH_ITEM_REACTIVE,
  ELEMENT_IS_NAMESPACED,
  ELEMENT_PRESERVE_ATTRIBUTE_CASE,
  HYDRATION_END,
  HYDRATION_START,
  HYDRATION_START_ELSE,
  IGNORABLE_RUNTIME_WARNINGS,
  NAMESPACE_MATHML,
  NAMESPACE_SVG,
  PROPS_IS_BINDABLE,
  PROPS_IS_IMMUTABLE,
  PROPS_IS_LAZY_INITIAL,
  PROPS_IS_RUNES,
  PROPS_IS_UPDATED,
  TEMPLATE_FRAGMENT,
  TEMPLATE_USE_IMPORT_NODE,
  TRANSITION_GLOBAL,
  TRANSITION_IN,
  TRANSITION_OUT
} from "./chunk-R5XELRI3.js";
import {
  walk
} from "./chunk-CXPE5DNB.js";
import {
  tsPlugin
} from "./chunk-VQRA7NX5.js";
import {
  Parser,
  isIdentifierChar,
  isIdentifierStart
} from "./chunk-R3EH6JBN.js";
import {
  is_reference
} from "./chunk-KUBEPTDY.js";
import {
  print
} from "./chunk-XROCJLPZ.js";
import {
  getLocator
} from "./chunk-3DD2DS5V.js";
import {
  MagicString
} from "./chunk-RI5N244P.js";
import {
  require_remapping_umd
} from "./chunk-3HL55UXD.js";
import {
  require_sourcemap_codec_umd
} from "./chunk-H7TQ7GYX.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-B4Q33VKO.js";

// node_modules/svelte/src/compiler/phases/patterns.js
var regex_whitespace = /\s/;
var regex_whitespaces = /\s+/;
var regex_starts_with_newline = /^\r?\n/;
var regex_starts_with_whitespace = /^\s/;
var regex_starts_with_whitespaces = /^[ \t\r\n]+/;
var regex_ends_with_whitespace = /\s$/;
var regex_ends_with_whitespaces = /[ \t\r\n]+$/;
var regex_not_whitespace = /[^ \t\r\n]/;
var regex_whitespaces_strict = /[ \t\n\r\f]+/g;
var regex_only_whitespaces = /^[ \t\n\r\f]+$/;
var regex_not_newline_characters = /[^\n]/g;
var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
var regex_invalid_identifier_chars = /(^[^a-zA-Z_$]|[^a-zA-Z0-9_$])/g;
var regex_starts_with_vowel = /^[aeiou]/;
var regex_heading_tags = /^h[1-6]$/;
var regex_illegal_attribute_character = /(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/;
var regex_bidirectional_control_characters = /[\u202a\u202b\u202c\u202d\u202e\u2066\u2067\u2068\u2069]+/g;

// node_modules/svelte/src/compiler/phases/1-parse/utils/fuzzymatch.js
function fuzzymatch(name, names) {
  if (names.length === 0) return null;
  const set2 = new FuzzySet(names);
  const matches = set2.get(name);
  return matches && matches[0][0] > 0.7 ? matches[0][1] : null;
}
var GRAM_SIZE_LOWER = 2;
var GRAM_SIZE_UPPER = 3;
function _distance(str1, str2) {
  if (str1 === null && str2 === null) {
    throw "Trying to compare two null values";
  }
  if (str1 === null || str2 === null) return 0;
  str1 = String(str1);
  str2 = String(str2);
  const distance = levenshtein(str1, str2);
  return 1 - distance / Math.max(str1.length, str2.length);
}
function levenshtein(str1, str2) {
  const current = [];
  let prev = 0;
  let value = 0;
  for (let i = 0; i <= str2.length; i++) {
    for (let j = 0; j <= str1.length; j++) {
      if (i && j) {
        if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
          value = prev;
        } else {
          value = Math.min(current[j], current[j - 1], prev) + 1;
        }
      } else {
        value = i + j;
      }
      prev = current[j];
      current[j] = value;
    }
  }
  return (
    /** @type {number} */
    current.pop()
  );
}
var non_word_regex = /[^\w, ]+/;
function iterate_grams(value, gram_size = 2) {
  const simplified = "-" + value.toLowerCase().replace(non_word_regex, "") + "-";
  const len_diff = gram_size - simplified.length;
  const results = [];
  if (len_diff > 0) {
    for (let i = 0; i < len_diff; ++i) {
      value += "-";
    }
  }
  for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
    results.push(simplified.slice(i, i + gram_size));
  }
  return results;
}
function gram_counter(value, gram_size = 2) {
  const result = {};
  const grams = iterate_grams(value, gram_size);
  let i = 0;
  for (i; i < grams.length; ++i) {
    if (grams[i] in result) {
      result[grams[i]] += 1;
    } else {
      result[grams[i]] = 1;
    }
  }
  return result;
}
function sort_descending(a, b) {
  return b[0] - a[0];
}
var FuzzySet = class {
  /** @param {string[]} arr */
  constructor(arr) {
    /** @type {Record<string, string>} */
    __publicField(this, "exact_set", {});
    /** @type {Record<string, [number, number][]>} */
    __publicField(this, "match_dict", {});
    /** @type {Record<string, number[]>} */
    __publicField(this, "items", {});
    for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
      this.items[i] = [];
    }
    for (let i = 0; i < arr.length; ++i) {
      this.add(arr[i]);
    }
  }
  /** @param {string} value */
  add(value) {
    const normalized_value = value.toLowerCase();
    if (normalized_value in this.exact_set) {
      return false;
    }
    let i = GRAM_SIZE_LOWER;
    for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
      this._add(value, i);
    }
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   */
  _add(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const items = this.items[gram_size] || [];
    const index = items.length;
    items.push(0);
    const gram_counts = gram_counter(normalized_value, gram_size);
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        this.match_dict[gram].push([index, gram_count]);
      } else {
        this.match_dict[gram] = [[index, gram_count]];
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    items[index] = [vector_normal, normalized_value];
    this.items[gram_size] = items;
    this.exact_set[normalized_value] = value;
  }
  /** @param {string} value */
  get(value) {
    const normalized_value = value.toLowerCase();
    const result = this.exact_set[normalized_value];
    if (result) {
      return (
        /** @type {MatchTuple[]} */
        [[1, result]]
      );
    }
    for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
      const results = this.__get(value, gram_size);
      if (results.length > 0) return results;
    }
    return null;
  }
  /**
   * @param {string} value
   * @param {number} gram_size
   * @returns {MatchTuple[]}
   */
  __get(value, gram_size) {
    const normalized_value = value.toLowerCase();
    const matches = {};
    const gram_counts = gram_counter(normalized_value, gram_size);
    const items = this.items[gram_size];
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    let i;
    let index;
    let other_gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        for (i = 0; i < this.match_dict[gram].length; ++i) {
          index = this.match_dict[gram][i][0];
          other_gram_count = this.match_dict[gram][i][1];
          if (index in matches) {
            matches[index] += gram_count * other_gram_count;
          } else {
            matches[index] = gram_count * other_gram_count;
          }
        }
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    let results = [];
    let match_score;
    for (const match_index in matches) {
      match_score = matches[match_index];
      results.push([match_score / (vector_normal * items[match_index][0]), items[match_index][1]]);
    }
    results.sort(sort_descending);
    let new_results = [];
    const end_index = Math.min(50, results.length);
    for (let i2 = 0; i2 < end_index; ++i2) {
      new_results.push([_distance(results[i2][1], normalized_value), results[i2][1]]);
    }
    results = new_results;
    results.sort(sort_descending);
    new_results = [];
    for (let i2 = 0; i2 < results.length; ++i2) {
      if (results[i2][0] === results[0][0]) {
        new_results.push([results[i2][0], this.exact_set[results[i2][1]]]);
      }
    }
    return new_results;
  }
};

// node_modules/svelte/src/compiler/state.js
var warnings = [];
var filename;
var source;
var dev;
var locator = getLocator("", { offsetLine: 1 });
function locate_node(node) {
  const loc = (
    /** @type {Location} */
    locator(
      /** @type {number} */
      node.start
    )
  );
  return `${sanitize_location(filename)}:${loc == null ? void 0 : loc.line}:${loc.column}`;
}
var warning_filter;
var ignore_stack = [];
var ignore_map = /* @__PURE__ */ new Map();
function push_ignore(ignores) {
  const next2 = /* @__PURE__ */ new Set([...ignore_stack.at(-1) || [], ...ignores]);
  ignore_stack.push(next2);
}
function pop_ignore() {
  ignore_stack.pop();
}
function reset_warning_filter(fn = () => true) {
  warning_filter = fn;
}
function is_ignored(node, code) {
  var _a2;
  return dev && !!((_a2 = ignore_map.get(node)) == null ? void 0 : _a2.some((codes3) => codes3.has(code)));
}
function reset(_source, options) {
  var _a2;
  source = _source;
  const root_dir = (_a2 = options.rootDir) == null ? void 0 : _a2.replace(/\\/g, "/");
  filename = options.filename.replace(/\\/g, "/");
  dev = !!options.dev;
  if (typeof root_dir === "string" && filename.startsWith(root_dir)) {
    filename = filename.replace(root_dir, "").replace(/^[/\\]/, "");
  }
  locator = getLocator(source, { offsetLine: 1 });
  warnings = [];
  ignore_stack = [];
  ignore_map.clear();
}

// node_modules/svelte/src/compiler/utils/compile_diagnostic.js
var regex_tabs = /^\t+/;
function tabs_to_spaces(str) {
  return str.replace(regex_tabs, (match) => match.split("	").join("  "));
}
function get_code_frame(source2, line, column) {
  const lines = source2.split("\n");
  const frame_start = Math.max(0, line - 2);
  const frame_end = Math.min(line + 3, lines.length);
  const digits = String(frame_end + 1).length;
  return lines.slice(frame_start, frame_end).map((str, i) => {
    const is_error_line = frame_start + i === line;
    const line_num = String(i + frame_start + 1).padStart(digits, " ");
    if (is_error_line) {
      const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str.slice(0, column)).length) + "^";
      return `${line_num}: ${tabs_to_spaces(str)}
${indicator}`;
    }
    return `${line_num}: ${tabs_to_spaces(str)}`;
  }).join("\n");
}
var CompileDiagnostic = class {
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    __publicField(this, "name", "CompileDiagnostic");
    this.code = code;
    this.message = message;
    if (filename) {
      this.filename = filename;
    }
    if (position) {
      this.position = position;
      this.start = locator(position[0]);
      this.end = locator(position[1]);
      if (this.start && this.end) {
        this.frame = get_code_frame(source, this.start.line - 1, this.end.column);
      }
    }
  }
  toString() {
    let out = `${this.code}: ${this.message}`;
    if (this.filename) {
      out += `
${this.filename}`;
      if (this.start) {
        out += `:${this.start.line}:${this.start.column}`;
      }
    }
    if (this.frame) {
      out += `
${this.frame}`;
    }
    return out;
  }
  toJSON() {
    return {
      code: this.code,
      message: this.message,
      filename: this.filename,
      start: this.start,
      end: this.end,
      position: this.position,
      frame: this.frame
    };
  }
};

// node_modules/svelte/src/compiler/warnings.js
var InternalCompileWarning = class extends CompileDiagnostic {
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    super(code, message, position);
    __publicField(this, "name", "CompileWarning");
  }
};
function w(node, code, message) {
  var _a2;
  let stack = ignore_stack;
  if (node) {
    stack = ignore_map.get(node) ?? ignore_stack;
  }
  if (stack && ((_a2 = stack.at(-1)) == null ? void 0 : _a2.has(code))) return;
  const warning = new InternalCompileWarning(code, message, node && node.start !== void 0 ? [node.start, node.end ?? node.start] : void 0);
  if (!warning_filter(warning)) return;
  warnings.push(warning);
}
var codes = [
  "a11y_accesskey",
  "a11y_aria_activedescendant_has_tabindex",
  "a11y_aria_attributes",
  "a11y_autocomplete_valid",
  "a11y_autofocus",
  "a11y_click_events_have_key_events",
  "a11y_consider_explicit_label",
  "a11y_distracting_elements",
  "a11y_figcaption_index",
  "a11y_figcaption_parent",
  "a11y_hidden",
  "a11y_img_redundant_alt",
  "a11y_incorrect_aria_attribute_type",
  "a11y_incorrect_aria_attribute_type_boolean",
  "a11y_incorrect_aria_attribute_type_id",
  "a11y_incorrect_aria_attribute_type_idlist",
  "a11y_incorrect_aria_attribute_type_integer",
  "a11y_incorrect_aria_attribute_type_token",
  "a11y_incorrect_aria_attribute_type_tokenlist",
  "a11y_incorrect_aria_attribute_type_tristate",
  "a11y_interactive_supports_focus",
  "a11y_invalid_attribute",
  "a11y_label_has_associated_control",
  "a11y_media_has_caption",
  "a11y_misplaced_role",
  "a11y_misplaced_scope",
  "a11y_missing_attribute",
  "a11y_missing_content",
  "a11y_mouse_events_have_key_events",
  "a11y_no_abstract_role",
  "a11y_no_interactive_element_to_noninteractive_role",
  "a11y_no_noninteractive_element_interactions",
  "a11y_no_noninteractive_element_to_interactive_role",
  "a11y_no_noninteractive_tabindex",
  "a11y_no_redundant_roles",
  "a11y_no_static_element_interactions",
  "a11y_positive_tabindex",
  "a11y_role_has_required_aria_props",
  "a11y_role_supports_aria_props",
  "a11y_role_supports_aria_props_implicit",
  "a11y_unknown_aria_attribute",
  "a11y_unknown_role",
  "bidirectional_control_characters",
  "legacy_code",
  "unknown_code",
  "options_deprecated_accessors",
  "options_deprecated_immutable",
  "options_missing_custom_element",
  "options_removed_enable_sourcemap",
  "options_removed_hydratable",
  "options_removed_loop_guard_timeout",
  "options_renamed_ssr_dom",
  "export_let_unused",
  "legacy_component_creation",
  "non_reactive_update",
  "perf_avoid_inline_class",
  "perf_avoid_nested_class",
  "reactive_declaration_invalid_placement",
  "reactive_declaration_module_script_dependency",
  "state_referenced_locally",
  "store_rune_conflict",
  "css_unused_selector",
  "attribute_avoid_is",
  "attribute_global_event_reference",
  "attribute_illegal_colon",
  "attribute_invalid_property_name",
  "attribute_quoted",
  "bind_invalid_each_rest",
  "block_empty",
  "component_name_lowercase",
  "element_invalid_self_closing_tag",
  "event_directive_deprecated",
  "node_invalid_placement_ssr",
  "script_context_deprecated",
  "script_unknown_attribute",
  "slot_element_deprecated",
  "svelte_component_deprecated",
  "svelte_element_invalid_this",
  "svelte_self_deprecated"
];
function a11y_accesskey(node) {
  w(node, "a11y_accesskey", `Avoid using accesskey
https://svelte.dev/e/a11y_accesskey`);
}
function a11y_aria_activedescendant_has_tabindex(node) {
  w(node, "a11y_aria_activedescendant_has_tabindex", `An element with an aria-activedescendant attribute should have a tabindex value
https://svelte.dev/e/a11y_aria_activedescendant_has_tabindex`);
}
function a11y_aria_attributes(node, name) {
  w(node, "a11y_aria_attributes", `\`<${name}>\` should not have aria-* attributes
https://svelte.dev/e/a11y_aria_attributes`);
}
function a11y_autocomplete_valid(node, value, type) {
  w(node, "a11y_autocomplete_valid", `'${value}' is an invalid value for 'autocomplete' on \`<input type="${type}">\`
https://svelte.dev/e/a11y_autocomplete_valid`);
}
function a11y_autofocus(node) {
  w(node, "a11y_autofocus", `Avoid using autofocus
https://svelte.dev/e/a11y_autofocus`);
}
function a11y_click_events_have_key_events(node) {
  w(node, "a11y_click_events_have_key_events", `Visible, non-interactive elements with a click event must be accompanied by a keyboard event handler. Consider whether an interactive element such as \`<button type="button">\` or \`<a>\` might be more appropriate
https://svelte.dev/e/a11y_click_events_have_key_events`);
}
function a11y_consider_explicit_label(node) {
  w(node, "a11y_consider_explicit_label", `Buttons and links should either contain text or have an \`aria-label\` or \`aria-labelledby\` attribute
https://svelte.dev/e/a11y_consider_explicit_label`);
}
function a11y_distracting_elements(node, name) {
  w(node, "a11y_distracting_elements", `Avoid \`<${name}>\` elements
https://svelte.dev/e/a11y_distracting_elements`);
}
function a11y_figcaption_index(node) {
  w(node, "a11y_figcaption_index", `\`<figcaption>\` must be first or last child of \`<figure>\`
https://svelte.dev/e/a11y_figcaption_index`);
}
function a11y_figcaption_parent(node) {
  w(node, "a11y_figcaption_parent", `\`<figcaption>\` must be an immediate child of \`<figure>\`
https://svelte.dev/e/a11y_figcaption_parent`);
}
function a11y_hidden(node, name) {
  w(node, "a11y_hidden", `\`<${name}>\` element should not be hidden
https://svelte.dev/e/a11y_hidden`);
}
function a11y_img_redundant_alt(node) {
  w(node, "a11y_img_redundant_alt", `Screenreaders already announce \`<img>\` elements as an image
https://svelte.dev/e/a11y_img_redundant_alt`);
}
function a11y_incorrect_aria_attribute_type(node, attribute, type) {
  w(node, "a11y_incorrect_aria_attribute_type", `The value of '${attribute}' must be a ${type}
https://svelte.dev/e/a11y_incorrect_aria_attribute_type`);
}
function a11y_incorrect_aria_attribute_type_boolean(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_boolean", `The value of '${attribute}' must be either 'true' or 'false'. It cannot be empty
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_boolean`);
}
function a11y_incorrect_aria_attribute_type_idlist(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_idlist", `The value of '${attribute}' must be a space-separated list of strings that represent DOM element IDs
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_idlist`);
}
function a11y_incorrect_aria_attribute_type_integer(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_integer", `The value of '${attribute}' must be an integer
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_integer`);
}
function a11y_incorrect_aria_attribute_type_token(node, attribute, values) {
  w(node, "a11y_incorrect_aria_attribute_type_token", `The value of '${attribute}' must be exactly one of ${values}
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_token`);
}
function a11y_incorrect_aria_attribute_type_tokenlist(node, attribute, values) {
  w(node, "a11y_incorrect_aria_attribute_type_tokenlist", `The value of '${attribute}' must be a space-separated list of one or more of ${values}
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_tokenlist`);
}
function a11y_incorrect_aria_attribute_type_tristate(node, attribute) {
  w(node, "a11y_incorrect_aria_attribute_type_tristate", `The value of '${attribute}' must be exactly one of true, false, or mixed
https://svelte.dev/e/a11y_incorrect_aria_attribute_type_tristate`);
}
function a11y_interactive_supports_focus(node, role) {
  w(node, "a11y_interactive_supports_focus", `Elements with the '${role}' interactive role must have a tabindex value
https://svelte.dev/e/a11y_interactive_supports_focus`);
}
function a11y_invalid_attribute(node, href_value, href_attribute) {
  w(node, "a11y_invalid_attribute", `'${href_value}' is not a valid ${href_attribute} attribute
https://svelte.dev/e/a11y_invalid_attribute`);
}
function a11y_label_has_associated_control(node) {
  w(node, "a11y_label_has_associated_control", `A form label must be associated with a control
https://svelte.dev/e/a11y_label_has_associated_control`);
}
function a11y_media_has_caption(node) {
  w(node, "a11y_media_has_caption", `\`<video>\` elements must have a \`<track kind="captions">\`
https://svelte.dev/e/a11y_media_has_caption`);
}
function a11y_misplaced_role(node, name) {
  w(node, "a11y_misplaced_role", `\`<${name}>\` should not have role attribute
https://svelte.dev/e/a11y_misplaced_role`);
}
function a11y_misplaced_scope(node) {
  w(node, "a11y_misplaced_scope", `The scope attribute should only be used with \`<th>\` elements
https://svelte.dev/e/a11y_misplaced_scope`);
}
function a11y_missing_attribute(node, name, article, sequence2) {
  w(node, "a11y_missing_attribute", `\`<${name}>\` element should have ${article} ${sequence2} attribute
https://svelte.dev/e/a11y_missing_attribute`);
}
function a11y_missing_content(node, name) {
  w(node, "a11y_missing_content", `\`<${name}>\` element should contain text
https://svelte.dev/e/a11y_missing_content`);
}
function a11y_mouse_events_have_key_events(node, event, accompanied_by) {
  w(node, "a11y_mouse_events_have_key_events", `'${event}' event must be accompanied by '${accompanied_by}' event
https://svelte.dev/e/a11y_mouse_events_have_key_events`);
}
function a11y_no_abstract_role(node, role) {
  w(node, "a11y_no_abstract_role", `Abstract role '${role}' is forbidden
https://svelte.dev/e/a11y_no_abstract_role`);
}
function a11y_no_interactive_element_to_noninteractive_role(node, element2, role) {
  w(node, "a11y_no_interactive_element_to_noninteractive_role", `\`<${element2}>\` cannot have role '${role}'
https://svelte.dev/e/a11y_no_interactive_element_to_noninteractive_role`);
}
function a11y_no_noninteractive_element_interactions(node, element2) {
  w(node, "a11y_no_noninteractive_element_interactions", `Non-interactive element \`<${element2}>\` should not be assigned mouse or keyboard event listeners
https://svelte.dev/e/a11y_no_noninteractive_element_interactions`);
}
function a11y_no_noninteractive_element_to_interactive_role(node, element2, role) {
  w(node, "a11y_no_noninteractive_element_to_interactive_role", `Non-interactive element \`<${element2}>\` cannot have interactive role '${role}'
https://svelte.dev/e/a11y_no_noninteractive_element_to_interactive_role`);
}
function a11y_no_noninteractive_tabindex(node) {
  w(node, "a11y_no_noninteractive_tabindex", `noninteractive element cannot have nonnegative tabIndex value
https://svelte.dev/e/a11y_no_noninteractive_tabindex`);
}
function a11y_no_redundant_roles(node, role) {
  w(node, "a11y_no_redundant_roles", `Redundant role '${role}'
https://svelte.dev/e/a11y_no_redundant_roles`);
}
function a11y_no_static_element_interactions(node, element2, handler) {
  w(node, "a11y_no_static_element_interactions", `\`<${element2}>\` with a ${handler} handler must have an ARIA role
https://svelte.dev/e/a11y_no_static_element_interactions`);
}
function a11y_positive_tabindex(node) {
  w(node, "a11y_positive_tabindex", `Avoid tabindex values above zero
https://svelte.dev/e/a11y_positive_tabindex`);
}
function a11y_role_has_required_aria_props(node, role, props) {
  w(node, "a11y_role_has_required_aria_props", `Elements with the ARIA role "${role}" must have the following attributes defined: ${props}
https://svelte.dev/e/a11y_role_has_required_aria_props`);
}
function a11y_role_supports_aria_props(node, attribute, role) {
  w(node, "a11y_role_supports_aria_props", `The attribute '${attribute}' is not supported by the role '${role}'
https://svelte.dev/e/a11y_role_supports_aria_props`);
}
function a11y_role_supports_aria_props_implicit(node, attribute, role, name) {
  w(node, "a11y_role_supports_aria_props_implicit", `The attribute '${attribute}' is not supported by the role '${role}'. This role is implicit on the element \`<${name}>\`
https://svelte.dev/e/a11y_role_supports_aria_props_implicit`);
}
function a11y_unknown_aria_attribute(node, attribute, suggestion) {
  w(node, "a11y_unknown_aria_attribute", `${suggestion ? `Unknown aria attribute 'aria-${attribute}'. Did you mean '${suggestion}'?` : `Unknown aria attribute 'aria-${attribute}'`}
https://svelte.dev/e/a11y_unknown_aria_attribute`);
}
function a11y_unknown_role(node, role, suggestion) {
  w(node, "a11y_unknown_role", `${suggestion ? `Unknown role '${role}'. Did you mean '${suggestion}'?` : `Unknown role '${role}'`}
https://svelte.dev/e/a11y_unknown_role`);
}
function bidirectional_control_characters(node) {
  w(node, "bidirectional_control_characters", `A bidirectional control character was detected in your code. These characters can be used to alter the visual direction of your code and could have unintended consequences
https://svelte.dev/e/bidirectional_control_characters`);
}
function legacy_code(node, code, suggestion) {
  w(node, "legacy_code", `\`${code}\` is no longer valid — please use \`${suggestion}\` instead
https://svelte.dev/e/legacy_code`);
}
function unknown_code(node, code, suggestion) {
  w(node, "unknown_code", `${suggestion ? `\`${code}\` is not a recognised code (did you mean \`${suggestion}\`?)` : `\`${code}\` is not a recognised code`}
https://svelte.dev/e/unknown_code`);
}
function options_deprecated_accessors(node) {
  w(node, "options_deprecated_accessors", `The \`accessors\` option has been deprecated. It will have no effect in runes mode
https://svelte.dev/e/options_deprecated_accessors`);
}
function options_deprecated_immutable(node) {
  w(node, "options_deprecated_immutable", `The \`immutable\` option has been deprecated. It will have no effect in runes mode
https://svelte.dev/e/options_deprecated_immutable`);
}
function options_missing_custom_element(node) {
  w(node, "options_missing_custom_element", `The \`customElement\` option is used when generating a custom element. Did you forget the \`customElement: true\` compile option?
https://svelte.dev/e/options_missing_custom_element`);
}
function options_removed_enable_sourcemap(node) {
  w(node, "options_removed_enable_sourcemap", `The \`enableSourcemap\` option has been removed. Source maps are always generated now, and tooling can choose to ignore them
https://svelte.dev/e/options_removed_enable_sourcemap`);
}
function options_removed_hydratable(node) {
  w(node, "options_removed_hydratable", `The \`hydratable\` option has been removed. Svelte components are always hydratable now
https://svelte.dev/e/options_removed_hydratable`);
}
function options_removed_loop_guard_timeout(node) {
  w(node, "options_removed_loop_guard_timeout", `The \`loopGuardTimeout\` option has been removed
https://svelte.dev/e/options_removed_loop_guard_timeout`);
}
function options_renamed_ssr_dom(node) {
  w(node, "options_renamed_ssr_dom", `\`generate: "dom"\` and \`generate: "ssr"\` options have been renamed to "client" and "server" respectively
https://svelte.dev/e/options_renamed_ssr_dom`);
}
function export_let_unused(node, name) {
  w(node, "export_let_unused", `Component has unused export property '${name}'. If it is for external reference only, please consider using \`export const ${name}\`
https://svelte.dev/e/export_let_unused`);
}
function legacy_component_creation(node) {
  w(node, "legacy_component_creation", `Svelte 5 components are no longer classes. Instantiate them using \`mount\` or \`hydrate\` (imported from 'svelte') instead.
https://svelte.dev/e/legacy_component_creation`);
}
function non_reactive_update(node, name) {
  w(node, "non_reactive_update", `\`${name}\` is updated, but is not declared with \`$state(...)\`. Changing its value will not correctly trigger updates
https://svelte.dev/e/non_reactive_update`);
}
function perf_avoid_inline_class(node) {
  w(node, "perf_avoid_inline_class", `Avoid 'new class' — instead, declare the class at the top level scope
https://svelte.dev/e/perf_avoid_inline_class`);
}
function perf_avoid_nested_class(node) {
  w(node, "perf_avoid_nested_class", `Avoid declaring classes below the top level scope
https://svelte.dev/e/perf_avoid_nested_class`);
}
function reactive_declaration_invalid_placement(node) {
  w(node, "reactive_declaration_invalid_placement", `Reactive declarations only exist at the top level of the instance script
https://svelte.dev/e/reactive_declaration_invalid_placement`);
}
function reactive_declaration_module_script_dependency(node) {
  w(node, "reactive_declaration_module_script_dependency", `Reassignments of module-level declarations will not cause reactive statements to update
https://svelte.dev/e/reactive_declaration_module_script_dependency`);
}
function state_referenced_locally(node, name, type) {
  w(node, "state_referenced_locally", `This reference only captures the initial value of \`${name}\`. Did you mean to reference it inside a ${type} instead?
https://svelte.dev/e/state_referenced_locally`);
}
function store_rune_conflict(node, name) {
  w(node, "store_rune_conflict", `It looks like you're using the \`$${name}\` rune, but there is a local binding called \`${name}\`. Referencing a local variable with a \`$\` prefix will create a store subscription. Please rename \`${name}\` to avoid the ambiguity
https://svelte.dev/e/store_rune_conflict`);
}
function css_unused_selector(node, name) {
  w(node, "css_unused_selector", `Unused CSS selector "${name}"
https://svelte.dev/e/css_unused_selector`);
}
function attribute_avoid_is(node) {
  w(node, "attribute_avoid_is", `The "is" attribute is not supported cross-browser and should be avoided
https://svelte.dev/e/attribute_avoid_is`);
}
function attribute_global_event_reference(node, name) {
  w(node, "attribute_global_event_reference", `You are referencing \`globalThis.${name}\`. Did you forget to declare a variable with that name?
https://svelte.dev/e/attribute_global_event_reference`);
}
function attribute_illegal_colon(node) {
  w(node, "attribute_illegal_colon", `Attributes should not contain ':' characters to prevent ambiguity with Svelte directives
https://svelte.dev/e/attribute_illegal_colon`);
}
function attribute_invalid_property_name(node, wrong, right) {
  w(node, "attribute_invalid_property_name", `'${wrong}' is not a valid HTML attribute. Did you mean '${right}'?
https://svelte.dev/e/attribute_invalid_property_name`);
}
function attribute_quoted(node) {
  w(node, "attribute_quoted", `Quoted attributes on components and custom elements will be stringified in a future version of Svelte. If this isn't what you want, remove the quotes
https://svelte.dev/e/attribute_quoted`);
}
function bind_invalid_each_rest(node, name) {
  w(node, "bind_invalid_each_rest", `The rest operator (...) will create a new object and binding '${name}' with the original object will not work
https://svelte.dev/e/bind_invalid_each_rest`);
}
function block_empty(node) {
  w(node, "block_empty", `Empty block
https://svelte.dev/e/block_empty`);
}
function component_name_lowercase(node, name) {
  w(node, "component_name_lowercase", `\`<${name}>\` will be treated as an HTML element unless it begins with a capital letter
https://svelte.dev/e/component_name_lowercase`);
}
function element_invalid_self_closing_tag(node, name) {
  w(node, "element_invalid_self_closing_tag", `Self-closing HTML tags for non-void elements are ambiguous — use \`<${name} ...></${name}>\` rather than \`<${name} ... />\`
https://svelte.dev/e/element_invalid_self_closing_tag`);
}
function event_directive_deprecated(node, name) {
  w(node, "event_directive_deprecated", `Using \`on:${name}\` to listen to the ${name} event is deprecated. Use the event attribute \`on${name}\` instead
https://svelte.dev/e/event_directive_deprecated`);
}
function node_invalid_placement_ssr(node, message) {
  w(node, "node_invalid_placement_ssr", `${message}. When rendering this component on the server, the resulting HTML will be modified by the browser (by moving, removing, or inserting elements), likely resulting in a \`hydration_mismatch\` warning
https://svelte.dev/e/node_invalid_placement_ssr`);
}
function script_context_deprecated(node) {
  w(node, "script_context_deprecated", `\`context="module"\` is deprecated, use the \`module\` attribute instead
https://svelte.dev/e/script_context_deprecated`);
}
function script_unknown_attribute(node) {
  w(node, "script_unknown_attribute", `Unrecognized attribute — should be one of \`generics\`, \`lang\` or \`module\`. If this exists for a preprocessor, ensure that the preprocessor removes it
https://svelte.dev/e/script_unknown_attribute`);
}
function slot_element_deprecated(node) {
  w(node, "slot_element_deprecated", `Using \`<slot>\` to render parent content is deprecated. Use \`{@render ...}\` tags instead
https://svelte.dev/e/slot_element_deprecated`);
}
function svelte_component_deprecated(node) {
  w(node, "svelte_component_deprecated", `\`<svelte:component>\` is deprecated in runes mode — components are dynamic by default
https://svelte.dev/e/svelte_component_deprecated`);
}
function svelte_element_invalid_this(node) {
  w(node, "svelte_element_invalid_this", `\`this\` should be an \`{expression}\`. Using a string attribute value will cause an error in future versions of Svelte
https://svelte.dev/e/svelte_element_invalid_this`);
}
function svelte_self_deprecated(node, name, basename) {
  w(node, "svelte_self_deprecated", `\`<svelte:self>\` is deprecated — use self-imports (e.g. \`import ${name} from './${basename}'\`) instead
https://svelte.dev/e/svelte_self_deprecated`);
}

// node_modules/svelte/src/compiler/utils/extract_svelte_ignore.js
var regex_svelte_ignore = /^\s*svelte-ignore\s/;
var replacements = {
  "non-top-level-reactive-declaration": "reactive_declaration_invalid_placement",
  "module-script-reactive-declaration": "reactive_declaration_module_script",
  "empty-block": "block_empty",
  "avoid-is": "attribute_avoid_is",
  "invalid-html-attribute": "attribute_invalid_property_name",
  "a11y-structure": "a11y_figcaption_parent",
  "illegal-attribute-character": "attribute_illegal_colon",
  "invalid-rest-eachblock-binding": "bind_invalid_each_rest",
  "unused-export-let": "export_let_unused"
};
var codes2 = codes.concat(IGNORABLE_RUNTIME_WARNINGS);
function extract_svelte_ignore(offset, text2, runes) {
  const match = regex_svelte_ignore.exec(text2);
  if (!match) return [];
  let length = match[0].length;
  offset += length;
  const ignores = [];
  if (runes) {
    for (const match2 of text2.slice(length).matchAll(/([\w$-]+)(,)?/gm)) {
      const code = match2[1];
      if (codes2.includes(code)) {
        ignores.push(code);
      } else {
        const replacement = replacements[code] ?? code.replace(/-/g, "_");
        const start = offset + /** @type {number} */
        match2.index;
        const end = start + code.length;
        if (codes2.includes(replacement)) {
          legacy_code({ start, end }, code, replacement);
        } else {
          const suggestion = fuzzymatch(code, codes2);
          unknown_code({ start, end }, code, suggestion);
        }
      }
      if (!match2[2]) {
        break;
      }
    }
  } else {
    for (const match2 of text2.slice(length).matchAll(/[\w$-]+/gm)) {
      const code = match2[0];
      ignores.push(code);
      if (!codes2.includes(code)) {
        const replacement = replacements[code] ?? code.replace(/-/g, "_");
        if (codes2.includes(replacement)) {
          ignores.push(replacement);
        }
      }
    }
  }
  return ignores;
}
function migrate_svelte_ignore(text2) {
  const match = regex_svelte_ignore.exec(text2);
  if (!match) return text2;
  const length = match[0].length;
  return text2.substring(0, length) + text2.substring(length).replace(/\w+-\w+(-\w+)*/g, (code, _, idx) => {
    let replacement = replacements[code] ?? code.replace(/-/g, "_");
    if (/\w+-\w+/.test(text2.substring(length + idx + code.length))) {
      replacement += ",";
    }
    return replacement;
  });
}

// node_modules/svelte/src/compiler/legacy.js
function remove_surrounding_whitespace_nodes(nodes) {
  const first = nodes.at(0);
  const last = nodes.at(-1);
  if ((first == null ? void 0 : first.type) === "Text") {
    if (!regex_not_whitespace.test(first.data)) {
      nodes.shift();
    } else {
      first.data = first.data.replace(regex_starts_with_whitespaces, "");
    }
  }
  if ((last == null ? void 0 : last.type) === "Text") {
    if (!regex_not_whitespace.test(last.data)) {
      nodes.pop();
    } else {
      last.data = last.data.replace(regex_ends_with_whitespaces, "");
    }
  }
}
function convert(source2, ast) {
  const root = (
    /** @type {AST.SvelteNode | Legacy.LegacySvelteNode} */
    ast
  );
  return (
    /** @type {Legacy.LegacyRoot} */
    walk(root, null, {
      _(node, { next: next2 }) {
        delete node.metadata;
        next2();
      },
      // @ts-ignore
      Root(node, { visit }) {
        const { instance, module, options } = node;
        if (
          /** @type {any} */
          options == null ? void 0 : options.__raw__
        ) {
          let idx = node.fragment.nodes.findIndex((node2) => options.end <= node2.start);
          if (idx === -1) {
            idx = node.fragment.nodes.length;
          }
          node.fragment.nodes.splice(
            idx,
            0,
            /** @type {any} */
            options.__raw__
          );
        }
        let start = null;
        let end = null;
        if (node.fragment.nodes.length > 0) {
          const first = (
            /** @type {AST.BaseNode} */
            node.fragment.nodes.at(0)
          );
          const last = (
            /** @type {AST.BaseNode} */
            node.fragment.nodes.at(-1)
          );
          start = first.start;
          end = last.end;
          while (/\s/.test(source2[start])) start += 1;
          while (/\s/.test(source2[end - 1])) end -= 1;
        }
        if (instance) {
          delete instance.attributes;
        }
        if (module) {
          delete module.attributes;
        }
        return {
          html: {
            type: "Fragment",
            start,
            end,
            children: node.fragment.nodes.map((child) => visit(child))
          },
          instance,
          module,
          css: ast.css ? visit(ast.css) : void 0
        };
      },
      AnimateDirective(node) {
        return { ...node, type: "Animation" };
      },
      // @ts-ignore
      AwaitBlock(node, { visit }) {
        var _a2, _b, _c;
        let pendingblock = {
          type: "PendingBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: ((_a2 = node.pending) == null ? void 0 : _a2.nodes.map((child) => visit(child))) ?? [],
          skip: true
        };
        let thenblock = {
          type: "ThenBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: ((_b = node.then) == null ? void 0 : _b.nodes.map((child) => visit(child))) ?? [],
          skip: true
        };
        let catchblock = {
          type: "CatchBlock",
          /** @type {number | null} */
          start: null,
          /** @type {number | null} */
          end: null,
          children: ((_c = node.catch) == null ? void 0 : _c.nodes.map((child) => visit(child))) ?? [],
          skip: true
        };
        if (node.pending) {
          const first = node.pending.nodes.at(0);
          const last = node.pending.nodes.at(-1);
          pendingblock.start = (first == null ? void 0 : first.start) ?? source2.indexOf("}", node.expression.end) + 1;
          pendingblock.end = (last == null ? void 0 : last.end) ?? pendingblock.start;
          pendingblock.skip = false;
        }
        if (node.then) {
          const first = node.then.nodes.at(0);
          const last = node.then.nodes.at(-1);
          thenblock.start = pendingblock.end ?? (first == null ? void 0 : first.start) ?? source2.indexOf("}", node.expression.end) + 1;
          thenblock.end = (last == null ? void 0 : last.end) ?? source2.lastIndexOf("}", pendingblock.end ?? node.expression.end) + 1;
          thenblock.skip = false;
        }
        if (node.catch) {
          const first = node.catch.nodes.at(0);
          const last = node.catch.nodes.at(-1);
          catchblock.start = thenblock.end ?? pendingblock.end ?? (first == null ? void 0 : first.start) ?? source2.indexOf("}", node.expression.end) + 1;
          catchblock.end = (last == null ? void 0 : last.end) ?? source2.lastIndexOf("}", thenblock.end ?? pendingblock.end ?? node.expression.end) + 1;
          catchblock.skip = false;
        }
        return {
          type: "AwaitBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          value: node.value,
          error: node.error,
          pending: pendingblock,
          then: thenblock,
          catch: catchblock
        };
      },
      BindDirective(node) {
        return { ...node, type: "Binding" };
      },
      ClassDirective(node) {
        return { ...node, type: "Class" };
      },
      Comment(node) {
        return {
          ...node,
          ignores: extract_svelte_ignore(node.start, node.data, false)
        };
      },
      ComplexSelector(node, { next: next2 }) {
        next2();
        const children = [];
        for (const child of node.children) {
          if (child.combinator) {
            children.push(child.combinator);
          }
          children.push(...child.selectors);
        }
        return {
          type: "Selector",
          start: node.start,
          end: node.end,
          children
        };
      },
      Component(node, { visit }) {
        return {
          type: "InlineComponent",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      // @ts-ignore
      ConstTag(node) {
        if (
          /** @type {Legacy.LegacyConstTag} */
          node.expression !== void 0
        ) {
          return node;
        }
        const modern_node = (
          /** @type {AST.ConstTag} */
          node
        );
        const { id: left } = { ...modern_node.declaration.declarations[0] };
        delete left.typeAnnotation;
        return {
          type: "ConstTag",
          start: modern_node.start,
          end: node.end,
          expression: {
            type: "AssignmentExpression",
            start: (modern_node.declaration.start ?? 0) + "const ".length,
            end: modern_node.declaration.end ?? 0,
            operator: "=",
            left,
            right: modern_node.declaration.declarations[0].init
          }
        };
      },
      // @ts-ignore
      KeyBlock(node, { visit }) {
        remove_surrounding_whitespace_nodes(node.fragment.nodes);
        return {
          type: "KeyBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      // @ts-ignore
      EachBlock(node, { visit }) {
        let elseblock = void 0;
        if (node.fallback) {
          const first = node.fallback.nodes.at(0);
          const end = source2.lastIndexOf(
            "{",
            /** @type {number} */
            node.end - 1
          );
          const start = (first == null ? void 0 : first.start) ?? end;
          remove_surrounding_whitespace_nodes(node.fallback.nodes);
          elseblock = {
            type: "ElseBlock",
            start,
            end,
            children: node.fallback.nodes.map((child) => visit(child))
          };
        }
        remove_surrounding_whitespace_nodes(node.body.nodes);
        return {
          type: "EachBlock",
          start: node.start,
          end: node.end,
          children: node.body.nodes.map((child) => visit(child)),
          context: node.context,
          expression: node.expression,
          index: node.index,
          key: node.key,
          else: elseblock
        };
      },
      ExpressionTag(node, { path }) {
        const parent = path.at(-1);
        if ((parent == null ? void 0 : parent.type) === "Attribute") {
          if (source2[parent.start] === "{") {
            return {
              type: "AttributeShorthand",
              start: node.start,
              end: node.end,
              expression: node.expression
            };
          }
        }
        return {
          type: "MustacheTag",
          start: node.start,
          end: node.end,
          expression: node.expression
        };
      },
      HtmlTag(node) {
        return { ...node, type: "RawMustacheTag" };
      },
      // @ts-ignore
      IfBlock(node, { visit }) {
        var _a2, _b;
        let elseblock = void 0;
        if (node.alternate) {
          let nodes = node.alternate.nodes;
          if (nodes.length === 1 && nodes[0].type === "IfBlock" && nodes[0].elseif) {
            nodes = nodes[0].consequent.nodes;
          }
          const end = source2.lastIndexOf(
            "{",
            /** @type {number} */
            node.end - 1
          );
          const start2 = ((_a2 = nodes.at(0)) == null ? void 0 : _a2.start) ?? end;
          remove_surrounding_whitespace_nodes(node.alternate.nodes);
          elseblock = {
            type: "ElseBlock",
            start: start2,
            end,
            children: node.alternate.nodes.map(
              (child) => (
                /** @type {Legacy.LegacyElementLike} */
                visit(child)
              )
            )
          };
        }
        const start = node.elseif ? ((_b = node.consequent.nodes[0]) == null ? void 0 : _b.start) ?? source2.lastIndexOf(
          "{",
          /** @type {number} */
          node.end - 1
        ) : node.start;
        remove_surrounding_whitespace_nodes(node.consequent.nodes);
        return {
          type: "IfBlock",
          start,
          end: node.end,
          expression: node.test,
          children: node.consequent.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          ),
          else: elseblock,
          elseif: node.elseif ? true : void 0
        };
      },
      OnDirective(node) {
        return { ...node, type: "EventHandler" };
      },
      // @ts-expect-error
      SnippetBlock(node, { visit }) {
        remove_surrounding_whitespace_nodes(node.body.nodes);
        return {
          type: "SnippetBlock",
          start: node.start,
          end: node.end,
          expression: node.expression,
          parameters: node.parameters,
          children: node.body.nodes.map((child) => visit(child))
        };
      },
      // @ts-expect-error
      SvelteBoundary(node, { visit }) {
        remove_surrounding_whitespace_nodes(node.fragment.nodes);
        return {
          type: "SvelteBoundary",
          name: "svelte:boundary",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map((child) => visit(child))
        };
      },
      RegularElement(node, { visit }) {
        return {
          type: "Element",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map((child) => visit(child)),
          children: node.fragment.nodes.map((child) => visit(child))
        };
      },
      SlotElement(node, { visit }) {
        return {
          type: "Slot",
          start: node.start,
          end: node.end,
          name: node.name,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      Attribute(node, { visit, next: next2, path }) {
        if (node.value !== true && !Array.isArray(node.value)) {
          path.push(node);
          const value = (
            /** @type {Legacy.LegacyAttribute['value']} */
            [visit(node.value)]
          );
          path.pop();
          return {
            ...node,
            value
          };
        } else {
          return next2();
        }
      },
      StyleDirective(node, { visit, next: next2, path }) {
        if (node.value !== true && !Array.isArray(node.value)) {
          path.push(node);
          const value = (
            /** @type {Legacy.LegacyStyleDirective['value']} */
            [visit(node.value)]
          );
          path.pop();
          return {
            ...node,
            value
          };
        } else {
          return next2();
        }
      },
      SpreadAttribute(node) {
        return { ...node, type: "Spread" };
      },
      StyleSheet(node, context) {
        return {
          ...node,
          ...context.next(),
          type: "Style"
        };
      },
      SvelteBody(node, { visit }) {
        return {
          type: "Body",
          name: "svelte:body",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteComponent(node, { visit }) {
        return {
          type: "InlineComponent",
          name: "svelte:component",
          start: node.start,
          end: node.end,
          expression: node.expression,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteDocument(node, { visit }) {
        return {
          type: "Document",
          name: "svelte:document",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteElement(node, { visit }) {
        let tag2 = node.tag;
        if (tag2.type === "Literal" && typeof tag2.value === "string" && source2[
          /** @type {number} */
          node.tag.start - 1
        ] !== "{") {
          tag2 = tag2.value;
        }
        return {
          type: "Element",
          name: "svelte:element",
          start: node.start,
          end: node.end,
          tag: tag2,
          attributes: node.attributes.map((child) => visit(child)),
          children: node.fragment.nodes.map((child) => visit(child))
        };
      },
      SvelteFragment(node, { visit }) {
        return {
          type: "SlotTemplate",
          name: "svelte:fragment",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (a) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(a)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteHead(node, { visit }) {
        return {
          type: "Head",
          name: "svelte:head",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteOptions(node, { visit }) {
        return {
          type: "Options",
          name: "svelte:options",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          )
        };
      },
      SvelteSelf(node, { visit }) {
        return {
          type: "InlineComponent",
          name: "svelte:self",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      SvelteWindow(node, { visit }) {
        return {
          type: "Window",
          name: "svelte:window",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      Text(node, { path }) {
        const parent = path.at(-1);
        if ((parent == null ? void 0 : parent.type) === "RegularElement" && parent.name === "style") {
          return (
            /** @type {AST.Text} */
            {
              type: "Text",
              start: node.start,
              end: node.end,
              data: node.data
            }
          );
        }
      },
      TitleElement(node, { visit }) {
        return {
          type: "Title",
          name: "title",
          start: node.start,
          end: node.end,
          attributes: node.attributes.map(
            (child) => (
              /** @type {Legacy.LegacyAttributeLike} */
              visit(child)
            )
          ),
          children: node.fragment.nodes.map(
            (child) => (
              /** @type {Legacy.LegacyElementLike} */
              visit(child)
            )
          )
        };
      },
      TransitionDirective(node) {
        return { ...node, type: "Transition" };
      },
      UseDirective(node) {
        return { ...node, type: "Action" };
      },
      LetDirective(node) {
        return { ...node, type: "Let" };
      }
    })
  );
}

// node_modules/svelte/src/compiler/phases/1-parse/acorn.js
var ParserWithTS = Parser.extend(tsPlugin());
function parse(source2, typescript, is_script) {
  const parser = typescript ? ParserWithTS : Parser;
  const { onComment, add_comments } = get_comment_handlers(source2);
  const parse_statement = parser.prototype.parseStatement;
  if (is_script) {
    parser.prototype.parseStatement = function(...args) {
      const v = parse_statement.call(this, ...args);
      this.undefinedExports = {};
      return v;
    };
  }
  let ast;
  try {
    ast = parser.parse(source2, {
      onComment,
      sourceType: "module",
      ecmaVersion: 13,
      locations: true
    });
  } finally {
    if (is_script) {
      parser.prototype.parseStatement = parse_statement;
    }
  }
  add_comments(ast);
  return (
    /** @type {Program} */
    ast
  );
}
function parse_expression_at(source2, typescript, index) {
  const parser = typescript ? ParserWithTS : Parser;
  const { onComment, add_comments } = get_comment_handlers(source2);
  const ast = parser.parseExpressionAt(source2, index, {
    onComment,
    sourceType: "module",
    ecmaVersion: 13,
    locations: true
  });
  add_comments(ast);
  return ast;
}
function get_comment_handlers(source2) {
  const comments = [];
  return {
    /**
     * @param {boolean} block
     * @param {string} value
     * @param {number} start
     * @param {number} end
     */
    onComment: (block2, value, start, end) => {
      if (block2 && /\n/.test(value)) {
        let a = start;
        while (a > 0 && source2[a - 1] !== "\n") a -= 1;
        let b = a;
        while (/[ \t]/.test(source2[b])) b += 1;
        const indentation = source2.slice(a, b);
        value = value.replace(new RegExp(`^${indentation}`, "gm"), "");
      }
      comments.push({ type: block2 ? "Block" : "Line", value, start, end });
    },
    /** @param {acorn.Node & { leadingComments?: CommentWithLocation[]; trailingComments?: CommentWithLocation[]; }} ast */
    add_comments(ast) {
      if (comments.length === 0) return;
      walk(ast, null, {
        _(node, { next: next2, path }) {
          let comment;
          while (comments[0] && comments[0].start < node.start) {
            comment = /** @type {CommentWithLocation} */
            comments.shift();
            (node.leadingComments || (node.leadingComments = [])).push(comment);
          }
          next2();
          if (comments[0]) {
            const parent = (
              /** @type {any} */
              path.at(-1)
            );
            if (parent === void 0 || node.end !== parent.end) {
              const slice = source2.slice(node.end, comments[0].start);
              const is_last_in_body = ((parent == null ? void 0 : parent.type) === "BlockStatement" || (parent == null ? void 0 : parent.type) === "Program") && parent.body.indexOf(node) === parent.body.length - 1 || (parent == null ? void 0 : parent.type) === "ArrayExpression" && parent.elements.indexOf(node) === parent.elements.length - 1 || (parent == null ? void 0 : parent.type) === "ObjectExpression" && parent.properties.indexOf(node) === parent.properties.length - 1;
              if (is_last_in_body) {
                let end = node.end;
                while (comments.length) {
                  const comment2 = comments[0];
                  if (parent && comment2.start >= parent.end) break;
                  (node.trailingComments || (node.trailingComments = [])).push(comment2);
                  comments.shift();
                  end = comment2.end;
                }
              } else if (node.end <= comments[0].start && /^[,) \t]*$/.test(slice)) {
                node.trailingComments = [
                  /** @type {CommentWithLocation} */
                  comments.shift()
                ];
              }
            }
          }
        }
      });
      if (comments.length > 0 && (comments[0].start >= ast.end || ast.type === "Program")) {
        (ast.trailingComments || (ast.trailingComments = [])).push(...comments.splice(0));
      }
    }
  };
}

// node_modules/svelte/src/compiler/errors.js
var _diagnostic;
var InternalCompileError = class extends Error {
  /**
   * @param {string} code
   * @param {string} message
   * @param {[number, number] | undefined} position
   */
  constructor(code, message, position) {
    super(message);
    __publicField(this, "message", "");
    // ensure this property is enumerable
    __privateAdd(this, _diagnostic);
    this.stack = "";
    __privateSet(this, _diagnostic, new CompileDiagnostic(code, message, position));
    Object.assign(this, __privateGet(this, _diagnostic));
    this.name = "CompileError";
  }
  toString() {
    return __privateGet(this, _diagnostic).toString();
  }
  toJSON() {
    return __privateGet(this, _diagnostic).toJSON();
  }
};
_diagnostic = new WeakMap();
function e(node, code, message) {
  const start = typeof node === "number" ? node : node == null ? void 0 : node.start;
  const end = typeof node === "number" ? node : node == null ? void 0 : node.end;
  throw new InternalCompileError(code, message, start !== void 0 ? [start, end ?? start] : void 0);
}
function options_invalid_value(node, details) {
  e(node, "options_invalid_value", `Invalid compiler option: ${details}
https://svelte.dev/e/options_invalid_value`);
}
function options_removed(node, details) {
  e(node, "options_removed", `Invalid compiler option: ${details}
https://svelte.dev/e/options_removed`);
}
function options_unrecognised(node, keypath) {
  e(node, "options_unrecognised", `Unrecognised compiler option ${keypath}
https://svelte.dev/e/options_unrecognised`);
}
function bindable_invalid_location(node) {
  e(node, "bindable_invalid_location", `\`$bindable()\` can only be used inside a \`$props()\` declaration
https://svelte.dev/e/bindable_invalid_location`);
}
function constant_assignment(node, thing) {
  e(node, "constant_assignment", `Cannot assign to ${thing}
https://svelte.dev/e/constant_assignment`);
}
function constant_binding(node, thing) {
  e(node, "constant_binding", `Cannot bind to ${thing}
https://svelte.dev/e/constant_binding`);
}
function declaration_duplicate(node, name) {
  e(node, "declaration_duplicate", `\`${name}\` has already been declared
https://svelte.dev/e/declaration_duplicate`);
}
function declaration_duplicate_module_import(node) {
  e(node, "declaration_duplicate_module_import", `Cannot declare a variable with the same name as an import inside \`<script module>\`
https://svelte.dev/e/declaration_duplicate_module_import`);
}
function derived_invalid_export(node) {
  e(node, "derived_invalid_export", `Cannot export derived state from a module. To expose the current derived value, export a function returning its value
https://svelte.dev/e/derived_invalid_export`);
}
function dollar_binding_invalid(node) {
  e(node, "dollar_binding_invalid", `The $ name is reserved, and cannot be used for variables and imports
https://svelte.dev/e/dollar_binding_invalid`);
}
function dollar_prefix_invalid(node) {
  e(node, "dollar_prefix_invalid", `The $ prefix is reserved, and cannot be used for variables and imports
https://svelte.dev/e/dollar_prefix_invalid`);
}
function each_item_invalid_assignment(node) {
  e(node, "each_item_invalid_assignment", `Cannot reassign or bind to each block argument in runes mode. Use the array and index variables instead (e.g. \`array[i] = value\` instead of \`entry = value\`, or \`bind:value={array[i]}\` instead of \`bind:value={entry}\`)
https://svelte.dev/e/each_item_invalid_assignment`);
}
function effect_invalid_placement(node) {
  e(node, "effect_invalid_placement", `\`$effect()\` can only be used as an expression statement
https://svelte.dev/e/effect_invalid_placement`);
}
function export_undefined(node, name) {
  e(node, "export_undefined", `\`${name}\` is not defined
https://svelte.dev/e/export_undefined`);
}
function global_reference_invalid(node, name) {
  e(node, "global_reference_invalid", `\`${name}\` is an illegal variable name. To reference a global variable called \`${name}\`, use \`globalThis.${name}\`
https://svelte.dev/e/global_reference_invalid`);
}
function host_invalid_placement(node) {
  e(node, "host_invalid_placement", `\`$host()\` can only be used inside custom element component instances
https://svelte.dev/e/host_invalid_placement`);
}
function import_svelte_internal_forbidden(node) {
  e(node, "import_svelte_internal_forbidden", `Imports of \`svelte/internal/*\` are forbidden. It contains private runtime code which is subject to change without notice. If you're importing from \`svelte/internal/*\` to work around a limitation of Svelte, please open an issue at https://github.com/sveltejs/svelte and explain your use case
https://svelte.dev/e/import_svelte_internal_forbidden`);
}
function inspect_trace_generator(node) {
  e(node, "inspect_trace_generator", `\`$inspect.trace(...)\` cannot be used inside a generator function
https://svelte.dev/e/inspect_trace_generator`);
}
function inspect_trace_invalid_placement(node) {
  e(node, "inspect_trace_invalid_placement", `\`$inspect.trace(...)\` must be the first statement of a function body
https://svelte.dev/e/inspect_trace_invalid_placement`);
}
function invalid_arguments_usage(node) {
  e(node, "invalid_arguments_usage", `The arguments keyword cannot be used within the template or at the top level of a component
https://svelte.dev/e/invalid_arguments_usage`);
}
function legacy_export_invalid(node) {
  e(node, "legacy_export_invalid", `Cannot use \`export let\` in runes mode — use \`$props()\` instead
https://svelte.dev/e/legacy_export_invalid`);
}
function legacy_props_invalid(node) {
  e(node, "legacy_props_invalid", `Cannot use \`$$props\` in runes mode
https://svelte.dev/e/legacy_props_invalid`);
}
function legacy_reactive_statement_invalid(node) {
  e(node, "legacy_reactive_statement_invalid", `\`$:\` is not allowed in runes mode, use \`$derived\` or \`$effect\` instead
https://svelte.dev/e/legacy_reactive_statement_invalid`);
}
function legacy_rest_props_invalid(node) {
  e(node, "legacy_rest_props_invalid", `Cannot use \`$$restProps\` in runes mode
https://svelte.dev/e/legacy_rest_props_invalid`);
}
function module_illegal_default_export(node) {
  e(node, "module_illegal_default_export", `A component cannot have a default export
https://svelte.dev/e/module_illegal_default_export`);
}
function props_duplicate(node, rune) {
  e(node, "props_duplicate", `Cannot use \`${rune}()\` more than once
https://svelte.dev/e/props_duplicate`);
}
function props_id_invalid_placement(node) {
  e(node, "props_id_invalid_placement", `\`$props.id()\` can only be used at the top level of components as a variable declaration initializer
https://svelte.dev/e/props_id_invalid_placement`);
}
function props_illegal_name(node) {
  e(node, "props_illegal_name", `Declaring or accessing a prop starting with \`$$\` is illegal (they are reserved for Svelte internals)
https://svelte.dev/e/props_illegal_name`);
}
function props_invalid_identifier(node) {
  e(node, "props_invalid_identifier", `\`$props()\` can only be used with an object destructuring pattern
https://svelte.dev/e/props_invalid_identifier`);
}
function props_invalid_pattern(node) {
  e(node, "props_invalid_pattern", `\`$props()\` assignment must not contain nested properties or computed keys
https://svelte.dev/e/props_invalid_pattern`);
}
function props_invalid_placement(node) {
  e(node, "props_invalid_placement", `\`$props()\` can only be used at the top level of components as a variable declaration initializer
https://svelte.dev/e/props_invalid_placement`);
}
function reactive_declaration_cycle(node, cycle) {
  e(node, "reactive_declaration_cycle", `Cyclical dependency detected: ${cycle}
https://svelte.dev/e/reactive_declaration_cycle`);
}
function rune_invalid_arguments(node, rune) {
  e(node, "rune_invalid_arguments", `\`${rune}\` cannot be called with arguments
https://svelte.dev/e/rune_invalid_arguments`);
}
function rune_invalid_arguments_length(node, rune, args) {
  e(node, "rune_invalid_arguments_length", `\`${rune}\` must be called with ${args}
https://svelte.dev/e/rune_invalid_arguments_length`);
}
function rune_invalid_computed_property(node) {
  e(node, "rune_invalid_computed_property", `Cannot access a computed property of a rune
https://svelte.dev/e/rune_invalid_computed_property`);
}
function rune_invalid_name(node, name) {
  e(node, "rune_invalid_name", `\`${name}\` is not a valid rune
https://svelte.dev/e/rune_invalid_name`);
}
function rune_invalid_spread(node, rune) {
  e(node, "rune_invalid_spread", `\`${rune}\` cannot be called with a spread argument
https://svelte.dev/e/rune_invalid_spread`);
}
function rune_invalid_usage(node, rune) {
  e(node, "rune_invalid_usage", `Cannot use \`${rune}\` rune in non-runes mode
https://svelte.dev/e/rune_invalid_usage`);
}
function rune_missing_parentheses(node) {
  e(node, "rune_missing_parentheses", `Cannot use rune without parentheses
https://svelte.dev/e/rune_missing_parentheses`);
}
function rune_removed(node, name) {
  e(node, "rune_removed", `The \`${name}\` rune has been removed
https://svelte.dev/e/rune_removed`);
}
function rune_renamed(node, name, replacement) {
  e(node, "rune_renamed", `\`${name}\` is now \`${replacement}\`
https://svelte.dev/e/rune_renamed`);
}
function runes_mode_invalid_import(node, name) {
  e(node, "runes_mode_invalid_import", `${name} cannot be used in runes mode
https://svelte.dev/e/runes_mode_invalid_import`);
}
function snippet_invalid_export(node) {
  e(node, "snippet_invalid_export", `An exported snippet can only reference things declared in a \`<script module>\`, or other exportable snippets
https://svelte.dev/e/snippet_invalid_export`);
}
function snippet_parameter_assignment(node) {
  e(node, "snippet_parameter_assignment", `Cannot reassign or bind to snippet parameter
https://svelte.dev/e/snippet_parameter_assignment`);
}
function state_invalid_export(node) {
  e(node, "state_invalid_export", `Cannot export state from a module if it is reassigned. Either export a function returning the state value or only mutate the state value's properties
https://svelte.dev/e/state_invalid_export`);
}
function state_invalid_placement(node, rune) {
  e(node, "state_invalid_placement", `\`${rune}(...)\` can only be used as a variable declaration initializer or a class field
https://svelte.dev/e/state_invalid_placement`);
}
function store_invalid_scoped_subscription(node) {
  e(node, "store_invalid_scoped_subscription", `Cannot subscribe to stores that are not declared at the top level of the component
https://svelte.dev/e/store_invalid_scoped_subscription`);
}
function store_invalid_subscription(node) {
  e(node, "store_invalid_subscription", `Cannot reference store value inside \`<script module>\`
https://svelte.dev/e/store_invalid_subscription`);
}
function store_invalid_subscription_module(node) {
  e(node, "store_invalid_subscription_module", `Cannot reference store value outside a \`.svelte\` file
https://svelte.dev/e/store_invalid_subscription_module`);
}
function typescript_invalid_feature(node, feature) {
  e(node, "typescript_invalid_feature", `TypeScript language features like ${feature} are not natively supported, and their use is generally discouraged. Outside of \`<script>\` tags, these features are not supported. For use within \`<script>\` tags, you will need to use a preprocessor to convert it to JavaScript before it gets passed to the Svelte compiler. If you are using \`vitePreprocess\`, make sure to specifically enable preprocessing script tags (\`vitePreprocess({ script: true })\`)
https://svelte.dev/e/typescript_invalid_feature`);
}
function css_empty_declaration(node) {
  e(node, "css_empty_declaration", `Declaration cannot be empty
https://svelte.dev/e/css_empty_declaration`);
}
function css_expected_identifier(node) {
  e(node, "css_expected_identifier", `Expected a valid CSS identifier
https://svelte.dev/e/css_expected_identifier`);
}
function css_global_block_invalid_combinator(node, name) {
  e(node, "css_global_block_invalid_combinator", `A \`:global\` selector cannot follow a \`${name}\` combinator
https://svelte.dev/e/css_global_block_invalid_combinator`);
}
function css_global_block_invalid_declaration(node) {
  e(node, "css_global_block_invalid_declaration", `A top-level \`:global {...}\` block can only contain rules, not declarations
https://svelte.dev/e/css_global_block_invalid_declaration`);
}
function css_global_block_invalid_list(node) {
  e(node, "css_global_block_invalid_list", `A \`:global\` selector cannot be part of a selector list with entries that don't contain \`:global\`
https://svelte.dev/e/css_global_block_invalid_list`);
}
function css_global_block_invalid_modifier(node) {
  e(node, "css_global_block_invalid_modifier", `A \`:global\` selector cannot modify an existing selector
https://svelte.dev/e/css_global_block_invalid_modifier`);
}
function css_global_block_invalid_modifier_start(node) {
  e(node, "css_global_block_invalid_modifier_start", `A \`:global\` selector can only be modified if it is a descendant of other selectors
https://svelte.dev/e/css_global_block_invalid_modifier_start`);
}
function css_global_block_invalid_placement(node) {
  e(node, "css_global_block_invalid_placement", `A \`:global\` selector cannot be inside a pseudoclass
https://svelte.dev/e/css_global_block_invalid_placement`);
}
function css_global_invalid_placement(node) {
  e(node, "css_global_invalid_placement", `\`:global(...)\` can be at the start or end of a selector sequence, but not in the middle
https://svelte.dev/e/css_global_invalid_placement`);
}
function css_global_invalid_selector(node) {
  e(node, "css_global_invalid_selector", `\`:global(...)\` must contain exactly one selector
https://svelte.dev/e/css_global_invalid_selector`);
}
function css_global_invalid_selector_list(node) {
  e(node, "css_global_invalid_selector_list", `\`:global(...)\` must not contain type or universal selectors when used in a compound selector
https://svelte.dev/e/css_global_invalid_selector_list`);
}
function css_nesting_selector_invalid_placement(node) {
  e(node, "css_nesting_selector_invalid_placement", `Nesting selectors can only be used inside a rule or as the first selector inside a lone \`:global(...)\`
https://svelte.dev/e/css_nesting_selector_invalid_placement`);
}
function css_selector_invalid(node) {
  e(node, "css_selector_invalid", `Invalid selector
https://svelte.dev/e/css_selector_invalid`);
}
function css_type_selector_invalid_placement(node) {
  e(node, "css_type_selector_invalid_placement", `\`:global(...)\` must not be followed by a type selector
https://svelte.dev/e/css_type_selector_invalid_placement`);
}
function animation_duplicate(node) {
  e(node, "animation_duplicate", `An element can only have one 'animate' directive
https://svelte.dev/e/animation_duplicate`);
}
function animation_invalid_placement(node) {
  e(node, "animation_invalid_placement", `An element that uses the \`animate:\` directive must be the only child of a keyed \`{#each ...}\` block
https://svelte.dev/e/animation_invalid_placement`);
}
function animation_missing_key(node) {
  e(node, "animation_missing_key", `An element that uses the \`animate:\` directive must be the only child of a keyed \`{#each ...}\` block. Did you forget to add a key to your each block?
https://svelte.dev/e/animation_missing_key`);
}
function attribute_contenteditable_dynamic(node) {
  e(node, "attribute_contenteditable_dynamic", `'contenteditable' attribute cannot be dynamic if element uses two-way binding
https://svelte.dev/e/attribute_contenteditable_dynamic`);
}
function attribute_contenteditable_missing(node) {
  e(node, "attribute_contenteditable_missing", `'contenteditable' attribute is required for textContent, innerHTML and innerText two-way bindings
https://svelte.dev/e/attribute_contenteditable_missing`);
}
function attribute_duplicate(node) {
  e(node, "attribute_duplicate", `Attributes need to be unique
https://svelte.dev/e/attribute_duplicate`);
}
function attribute_empty_shorthand(node) {
  e(node, "attribute_empty_shorthand", `Attribute shorthand cannot be empty
https://svelte.dev/e/attribute_empty_shorthand`);
}
function attribute_invalid_event_handler(node) {
  e(node, "attribute_invalid_event_handler", `Event attribute must be a JavaScript expression, not a string
https://svelte.dev/e/attribute_invalid_event_handler`);
}
function attribute_invalid_multiple(node) {
  e(node, "attribute_invalid_multiple", `'multiple' attribute must be static if select uses two-way binding
https://svelte.dev/e/attribute_invalid_multiple`);
}
function attribute_invalid_name(node, name) {
  e(node, "attribute_invalid_name", `'${name}' is not a valid attribute name
https://svelte.dev/e/attribute_invalid_name`);
}
function attribute_invalid_sequence_expression(node) {
  e(node, "attribute_invalid_sequence_expression", `Sequence expressions are not allowed as attribute/directive values in runes mode, unless wrapped in parentheses
https://svelte.dev/e/attribute_invalid_sequence_expression`);
}
function attribute_invalid_type(node) {
  e(node, "attribute_invalid_type", `'type' attribute must be a static text value if input uses two-way binding
https://svelte.dev/e/attribute_invalid_type`);
}
function attribute_unquoted_sequence(node) {
  e(node, "attribute_unquoted_sequence", `Attribute values containing \`{...}\` must be enclosed in quote marks, unless the value only contains the expression
https://svelte.dev/e/attribute_unquoted_sequence`);
}
function bind_group_invalid_expression(node) {
  e(node, "bind_group_invalid_expression", `\`bind:group\` can only bind to an Identifier or MemberExpression
https://svelte.dev/e/bind_group_invalid_expression`);
}
function bind_group_invalid_snippet_parameter(node) {
  e(node, "bind_group_invalid_snippet_parameter", `Cannot \`bind:group\` to a snippet parameter
https://svelte.dev/e/bind_group_invalid_snippet_parameter`);
}
function bind_invalid_expression(node) {
  e(node, "bind_invalid_expression", `Can only bind to an Identifier or MemberExpression or a \`{get, set}\` pair
https://svelte.dev/e/bind_invalid_expression`);
}
function bind_invalid_name(node, name, explanation) {
  e(node, "bind_invalid_name", `${explanation ? `\`bind:${name}\` is not a valid binding. ${explanation}` : `\`bind:${name}\` is not a valid binding`}
https://svelte.dev/e/bind_invalid_name`);
}
function bind_invalid_parens(node, name) {
  e(node, "bind_invalid_parens", `\`bind:${name}={get, set}\` must not have surrounding parentheses
https://svelte.dev/e/bind_invalid_parens`);
}
function bind_invalid_target(node, name, elements) {
  e(node, "bind_invalid_target", `\`bind:${name}\` can only be used with ${elements}
https://svelte.dev/e/bind_invalid_target`);
}
function bind_invalid_value(node) {
  e(node, "bind_invalid_value", `Can only bind to state or props
https://svelte.dev/e/bind_invalid_value`);
}
function block_duplicate_clause(node, name) {
  e(node, "block_duplicate_clause", `${name} cannot appear more than once within a block
https://svelte.dev/e/block_duplicate_clause`);
}
function block_invalid_continuation_placement(node) {
  e(node, "block_invalid_continuation_placement", `{:...} block is invalid at this position (did you forget to close the preceding element or block?)
https://svelte.dev/e/block_invalid_continuation_placement`);
}
function block_invalid_elseif(node) {
  e(node, "block_invalid_elseif", `'elseif' should be 'else if'
https://svelte.dev/e/block_invalid_elseif`);
}
function block_invalid_placement(node, name, location) {
  e(node, "block_invalid_placement", `{#${name} ...} block cannot be ${location}
https://svelte.dev/e/block_invalid_placement`);
}
function block_unclosed(node) {
  e(node, "block_unclosed", `Block was left open
https://svelte.dev/e/block_unclosed`);
}
function block_unexpected_character(node, character) {
  e(node, "block_unexpected_character", `Expected a \`${character}\` character immediately following the opening bracket
https://svelte.dev/e/block_unexpected_character`);
}
function block_unexpected_close(node) {
  e(node, "block_unexpected_close", `Unexpected block closing tag
https://svelte.dev/e/block_unexpected_close`);
}
function component_invalid_directive(node) {
  e(node, "component_invalid_directive", `This type of directive is not valid on components
https://svelte.dev/e/component_invalid_directive`);
}
function const_tag_cycle(node, cycle) {
  e(node, "const_tag_cycle", `Cyclical dependency detected: ${cycle}
https://svelte.dev/e/const_tag_cycle`);
}
function const_tag_invalid_expression(node) {
  e(node, "const_tag_invalid_expression", `{@const ...} must consist of a single variable declaration
https://svelte.dev/e/const_tag_invalid_expression`);
}
function const_tag_invalid_placement(node) {
  e(node, "const_tag_invalid_placement", `\`{@const}\` must be the immediate child of \`{#snippet}\`, \`{#if}\`, \`{:else if}\`, \`{:else}\`, \`{#each}\`, \`{:then}\`, \`{:catch}\`, \`<svelte:fragment>\`, \`<svelte:boundary\` or \`<Component>\`
https://svelte.dev/e/const_tag_invalid_placement`);
}
function debug_tag_invalid_arguments(node) {
  e(node, "debug_tag_invalid_arguments", `{@debug ...} arguments must be identifiers, not arbitrary expressions
https://svelte.dev/e/debug_tag_invalid_arguments`);
}
function directive_invalid_value(node) {
  e(node, "directive_invalid_value", `Directive value must be a JavaScript expression enclosed in curly braces
https://svelte.dev/e/directive_invalid_value`);
}
function directive_missing_name(node, type) {
  e(node, "directive_missing_name", `\`${type}\` name cannot be empty
https://svelte.dev/e/directive_missing_name`);
}
function element_invalid_closing_tag(node, name) {
  e(node, "element_invalid_closing_tag", `\`</${name}>\` attempted to close an element that was not open
https://svelte.dev/e/element_invalid_closing_tag`);
}
function element_invalid_closing_tag_autoclosed(node, name, reason) {
  e(node, "element_invalid_closing_tag_autoclosed", `\`</${name}>\` attempted to close element that was already automatically closed by \`<${reason}>\` (cannot nest \`<${reason}>\` inside \`<${name}>\`)
https://svelte.dev/e/element_invalid_closing_tag_autoclosed`);
}
function element_unclosed(node, name) {
  e(node, "element_unclosed", `\`<${name}>\` was left open
https://svelte.dev/e/element_unclosed`);
}
function event_handler_invalid_component_modifier(node) {
  e(node, "event_handler_invalid_component_modifier", `Event modifiers other than 'once' can only be used on DOM elements
https://svelte.dev/e/event_handler_invalid_component_modifier`);
}
function event_handler_invalid_modifier(node, list3) {
  e(node, "event_handler_invalid_modifier", `Valid event modifiers are ${list3}
https://svelte.dev/e/event_handler_invalid_modifier`);
}
function event_handler_invalid_modifier_combination(node, modifier1, modifier2) {
  e(node, "event_handler_invalid_modifier_combination", `The '${modifier1}' and '${modifier2}' modifiers cannot be used together
https://svelte.dev/e/event_handler_invalid_modifier_combination`);
}
function expected_attribute_value(node) {
  e(node, "expected_attribute_value", `Expected attribute value
https://svelte.dev/e/expected_attribute_value`);
}
function expected_block_type(node) {
  e(node, "expected_block_type", `Expected 'if', 'each', 'await', 'key' or 'snippet'
https://svelte.dev/e/expected_block_type`);
}
function expected_identifier(node) {
  e(node, "expected_identifier", `Expected an identifier
https://svelte.dev/e/expected_identifier`);
}
function expected_pattern(node) {
  e(node, "expected_pattern", `Expected identifier or destructure pattern
https://svelte.dev/e/expected_pattern`);
}
function expected_token(node, token) {
  e(node, "expected_token", `Expected token ${token}
https://svelte.dev/e/expected_token`);
}
function expected_whitespace(node) {
  e(node, "expected_whitespace", `Expected whitespace
https://svelte.dev/e/expected_whitespace`);
}
function illegal_element_attribute(node, name) {
  e(node, "illegal_element_attribute", `\`<${name}>\` does not support non-event attributes or spread attributes
https://svelte.dev/e/illegal_element_attribute`);
}
function js_parse_error(node, message) {
  e(node, "js_parse_error", `${message}
https://svelte.dev/e/js_parse_error`);
}
function let_directive_invalid_placement(node) {
  e(node, "let_directive_invalid_placement", `\`let:\` directive at invalid position
https://svelte.dev/e/let_directive_invalid_placement`);
}
function mixed_event_handler_syntaxes(node, name) {
  e(node, "mixed_event_handler_syntaxes", `Mixing old (on:${name}) and new syntaxes for event handling is not allowed. Use only the on${name} syntax
https://svelte.dev/e/mixed_event_handler_syntaxes`);
}
function node_invalid_placement(node, message) {
  e(node, "node_invalid_placement", `${message}. The browser will 'repair' the HTML (by moving, removing, or inserting elements) which breaks Svelte's assumptions about the structure of your components.
https://svelte.dev/e/node_invalid_placement`);
}
function render_tag_invalid_call_expression(node) {
  e(node, "render_tag_invalid_call_expression", `Calling a snippet function using apply, bind or call is not allowed
https://svelte.dev/e/render_tag_invalid_call_expression`);
}
function render_tag_invalid_expression(node) {
  e(node, "render_tag_invalid_expression", `\`{@render ...}\` tags can only contain call expressions
https://svelte.dev/e/render_tag_invalid_expression`);
}
function render_tag_invalid_spread_argument(node) {
  e(node, "render_tag_invalid_spread_argument", `cannot use spread arguments in \`{@render ...}\` tags
https://svelte.dev/e/render_tag_invalid_spread_argument`);
}
function script_duplicate(node) {
  e(node, "script_duplicate", `A component can have a single top-level \`<script>\` element and/or a single top-level \`<script module>\` element
https://svelte.dev/e/script_duplicate`);
}
function script_invalid_attribute_value(node, name) {
  e(node, "script_invalid_attribute_value", `If the \`${name}\` attribute is supplied, it must be a boolean attribute
https://svelte.dev/e/script_invalid_attribute_value`);
}
function script_invalid_context(node) {
  e(node, "script_invalid_context", `If the context attribute is supplied, its value must be "module"
https://svelte.dev/e/script_invalid_context`);
}
function script_reserved_attribute(node, name) {
  e(node, "script_reserved_attribute", `The \`${name}\` attribute is reserved and cannot be used
https://svelte.dev/e/script_reserved_attribute`);
}
function slot_attribute_duplicate(node, name, component) {
  e(node, "slot_attribute_duplicate", `Duplicate slot name '${name}' in <${component}>
https://svelte.dev/e/slot_attribute_duplicate`);
}
function slot_attribute_invalid(node) {
  e(node, "slot_attribute_invalid", `slot attribute must be a static value
https://svelte.dev/e/slot_attribute_invalid`);
}
function slot_attribute_invalid_placement(node) {
  e(node, "slot_attribute_invalid_placement", `Element with a slot='...' attribute must be a child of a component or a descendant of a custom element
https://svelte.dev/e/slot_attribute_invalid_placement`);
}
function slot_default_duplicate(node) {
  e(node, "slot_default_duplicate", `Found default slot content alongside an explicit slot="default"
https://svelte.dev/e/slot_default_duplicate`);
}
function slot_element_invalid_attribute(node) {
  e(node, "slot_element_invalid_attribute", `\`<slot>\` can only receive attributes and (optionally) let directives
https://svelte.dev/e/slot_element_invalid_attribute`);
}
function slot_element_invalid_name(node) {
  e(node, "slot_element_invalid_name", `slot attribute must be a static value
https://svelte.dev/e/slot_element_invalid_name`);
}
function slot_element_invalid_name_default(node) {
  e(node, "slot_element_invalid_name_default", `\`default\` is a reserved word — it cannot be used as a slot name
https://svelte.dev/e/slot_element_invalid_name_default`);
}
function slot_snippet_conflict(node) {
  e(node, "slot_snippet_conflict", `Cannot use \`<slot>\` syntax and \`{@render ...}\` tags in the same component. Migrate towards \`{@render ...}\` tags completely
https://svelte.dev/e/slot_snippet_conflict`);
}
function snippet_conflict(node) {
  e(node, "snippet_conflict", `Cannot use explicit children snippet at the same time as implicit children content. Remove either the non-whitespace content or the children snippet block
https://svelte.dev/e/snippet_conflict`);
}
function snippet_invalid_rest_parameter(node) {
  e(node, "snippet_invalid_rest_parameter", `Snippets do not support rest parameters; use an array instead
https://svelte.dev/e/snippet_invalid_rest_parameter`);
}
function snippet_shadowing_prop(node, prop2) {
  e(node, "snippet_shadowing_prop", `This snippet is shadowing the prop \`${prop2}\` with the same name
https://svelte.dev/e/snippet_shadowing_prop`);
}
function style_directive_invalid_modifier(node) {
  e(node, "style_directive_invalid_modifier", `\`style:\` directive can only use the \`important\` modifier
https://svelte.dev/e/style_directive_invalid_modifier`);
}
function style_duplicate(node) {
  e(node, "style_duplicate", `A component can have a single top-level \`<style>\` element
https://svelte.dev/e/style_duplicate`);
}
function svelte_body_illegal_attribute(node) {
  e(node, "svelte_body_illegal_attribute", `\`<svelte:body>\` does not support non-event attributes or spread attributes
https://svelte.dev/e/svelte_body_illegal_attribute`);
}
function svelte_boundary_invalid_attribute(node) {
  e(node, "svelte_boundary_invalid_attribute", `Valid attributes on \`<svelte:boundary>\` are \`onerror\` and \`failed\`
https://svelte.dev/e/svelte_boundary_invalid_attribute`);
}
function svelte_boundary_invalid_attribute_value(node) {
  e(node, "svelte_boundary_invalid_attribute_value", `Attribute value must be a non-string expression
https://svelte.dev/e/svelte_boundary_invalid_attribute_value`);
}
function svelte_component_invalid_this(node) {
  e(node, "svelte_component_invalid_this", `Invalid component definition — must be an \`{expression}\`
https://svelte.dev/e/svelte_component_invalid_this`);
}
function svelte_component_missing_this(node) {
  e(node, "svelte_component_missing_this", `\`<svelte:component>\` must have a 'this' attribute
https://svelte.dev/e/svelte_component_missing_this`);
}
function svelte_element_missing_this(node) {
  e(node, "svelte_element_missing_this", `\`<svelte:element>\` must have a 'this' attribute with a value
https://svelte.dev/e/svelte_element_missing_this`);
}
function svelte_fragment_invalid_attribute(node) {
  e(node, "svelte_fragment_invalid_attribute", `\`<svelte:fragment>\` can only have a slot attribute and (optionally) a let: directive
https://svelte.dev/e/svelte_fragment_invalid_attribute`);
}
function svelte_fragment_invalid_placement(node) {
  e(node, "svelte_fragment_invalid_placement", `\`<svelte:fragment>\` must be the direct child of a component
https://svelte.dev/e/svelte_fragment_invalid_placement`);
}
function svelte_head_illegal_attribute(node) {
  e(node, "svelte_head_illegal_attribute", `\`<svelte:head>\` cannot have attributes nor directives
https://svelte.dev/e/svelte_head_illegal_attribute`);
}
function svelte_meta_duplicate(node, name) {
  e(node, "svelte_meta_duplicate", `A component can only have one \`<${name}>\` element
https://svelte.dev/e/svelte_meta_duplicate`);
}
function svelte_meta_invalid_content(node, name) {
  e(node, "svelte_meta_invalid_content", `<${name}> cannot have children
https://svelte.dev/e/svelte_meta_invalid_content`);
}
function svelte_meta_invalid_placement(node, name) {
  e(node, "svelte_meta_invalid_placement", `\`<${name}>\` tags cannot be inside elements or blocks
https://svelte.dev/e/svelte_meta_invalid_placement`);
}
function svelte_meta_invalid_tag(node, list3) {
  e(node, "svelte_meta_invalid_tag", `Valid \`<svelte:...>\` tag names are ${list3}
https://svelte.dev/e/svelte_meta_invalid_tag`);
}
function svelte_options_deprecated_tag(node) {
  e(node, "svelte_options_deprecated_tag", `"tag" option is deprecated — use "customElement" instead
https://svelte.dev/e/svelte_options_deprecated_tag`);
}
function svelte_options_invalid_attribute(node) {
  e(node, "svelte_options_invalid_attribute", `\`<svelte:options>\` can only receive static attributes
https://svelte.dev/e/svelte_options_invalid_attribute`);
}
function svelte_options_invalid_attribute_value(node, list3) {
  e(node, "svelte_options_invalid_attribute_value", `Value must be ${list3}, if specified
https://svelte.dev/e/svelte_options_invalid_attribute_value`);
}
function svelte_options_invalid_customelement(node) {
  e(node, "svelte_options_invalid_customelement", `"customElement" must be a string literal defining a valid custom element name or an object of the form { tag?: string; shadow?: "open" | "none"; props?: { [key: string]: { attribute?: string; reflect?: boolean; type: .. } } }
https://svelte.dev/e/svelte_options_invalid_customelement`);
}
function svelte_options_invalid_customelement_props(node) {
  e(node, "svelte_options_invalid_customelement_props", `"props" must be a statically analyzable object literal of the form "{ [key: string]: { attribute?: string; reflect?: boolean; type?: "String" | "Boolean" | "Number" | "Array" | "Object" }"
https://svelte.dev/e/svelte_options_invalid_customelement_props`);
}
function svelte_options_invalid_customelement_shadow(node) {
  e(node, "svelte_options_invalid_customelement_shadow", `"shadow" must be either "open" or "none"
https://svelte.dev/e/svelte_options_invalid_customelement_shadow`);
}
function svelte_options_invalid_tagname(node) {
  e(node, "svelte_options_invalid_tagname", `Tag name must be lowercase and hyphenated
https://svelte.dev/e/svelte_options_invalid_tagname`);
}
function svelte_options_reserved_tagname(node) {
  e(node, "svelte_options_reserved_tagname", `Tag name is reserved
https://svelte.dev/e/svelte_options_reserved_tagname`);
}
function svelte_options_unknown_attribute(node, name) {
  e(node, "svelte_options_unknown_attribute", `\`<svelte:options>\` unknown attribute '${name}'
https://svelte.dev/e/svelte_options_unknown_attribute`);
}
function svelte_self_invalid_placement(node) {
  e(node, "svelte_self_invalid_placement", `\`<svelte:self>\` components can only exist inside \`{#if}\` blocks, \`{#each}\` blocks, \`{#snippet}\` blocks or slots passed to components
https://svelte.dev/e/svelte_self_invalid_placement`);
}
function tag_invalid_name(node) {
  e(node, "tag_invalid_name", `Expected a valid element or component name. Components must have a valid variable name or dot notation expression
https://svelte.dev/e/tag_invalid_name`);
}
function tag_invalid_placement(node, name, location) {
  e(node, "tag_invalid_placement", `{@${name} ...} tag cannot be ${location}
https://svelte.dev/e/tag_invalid_placement`);
}
function textarea_invalid_content(node) {
  e(node, "textarea_invalid_content", `A \`<textarea>\` can have either a value attribute or (equivalently) child content, but not both
https://svelte.dev/e/textarea_invalid_content`);
}
function title_illegal_attribute(node) {
  e(node, "title_illegal_attribute", `\`<title>\` cannot have attributes nor directives
https://svelte.dev/e/title_illegal_attribute`);
}
function title_invalid_content(node) {
  e(node, "title_invalid_content", `\`<title>\` can only contain text and {tags}
https://svelte.dev/e/title_invalid_content`);
}
function transition_conflict(node, type, existing) {
  e(node, "transition_conflict", `Cannot use \`${type}:\` alongside existing \`${existing}:\` directive
https://svelte.dev/e/transition_conflict`);
}
function transition_duplicate(node, type) {
  e(node, "transition_duplicate", `Cannot use multiple \`${type}:\` directives on a single element
https://svelte.dev/e/transition_duplicate`);
}
function unexpected_eof(node) {
  e(node, "unexpected_eof", `Unexpected end of input
https://svelte.dev/e/unexpected_eof`);
}
function unexpected_reserved_word(node, word) {
  e(node, "unexpected_reserved_word", `'${word}' is a reserved word in JavaScript and cannot be used here
https://svelte.dev/e/unexpected_reserved_word`);
}
function unterminated_string_constant(node) {
  e(node, "unterminated_string_constant", `Unterminated string constant
https://svelte.dev/e/unterminated_string_constant`);
}
function void_element_invalid_content(node) {
  e(node, "void_element_invalid_content", `Void elements cannot have children or closing tags
https://svelte.dev/e/void_element_invalid_content`);
}

// node_modules/svelte/src/compiler/phases/1-parse/utils/bracket.js
var SQUARE_BRACKET_OPEN = "[";
var SQUARE_BRACKET_CLOSE = "]";
var CURLY_BRACKET_OPEN = "{";
var CURLY_BRACKET_CLOSE = "}";
var PARENTHESES_OPEN = "(";
var PARENTHESES_CLOSE = ")";
function is_bracket_open(char) {
  return char === SQUARE_BRACKET_OPEN || char === CURLY_BRACKET_OPEN;
}
function is_bracket_close(char) {
  return char === SQUARE_BRACKET_CLOSE || char === CURLY_BRACKET_CLOSE;
}
function get_bracket_close(open2) {
  if (open2 === SQUARE_BRACKET_OPEN) {
    return SQUARE_BRACKET_CLOSE;
  }
  if (open2 === CURLY_BRACKET_OPEN) {
    return CURLY_BRACKET_CLOSE;
  }
  if (open2 === PARENTHESES_OPEN) {
    return PARENTHESES_CLOSE;
  }
}
function infinity_if_negative(num) {
  if (num < 0) {
    return Infinity;
  }
  return num;
}
function find_string_end(string2, search_start_index, string_start_char) {
  let string_to_search;
  if (string_start_char === "`") {
    string_to_search = string2;
  } else {
    string_to_search = string2.slice(
      0,
      infinity_if_negative(string2.indexOf("\n", search_start_index))
    );
  }
  return find_unescaped_char(string_to_search, search_start_index, string_start_char);
}
function find_regex_end(string2, search_start_index) {
  return find_unescaped_char(string2, search_start_index, "/");
}
function find_unescaped_char(string2, search_start_index, char) {
  let i = search_start_index;
  while (true) {
    const found_index = string2.indexOf(char, i);
    if (found_index === -1) {
      return Infinity;
    }
    if (count_leading_backslashes(string2, found_index - 1) % 2 === 0) {
      return found_index;
    }
    i = found_index + 1;
  }
}
function count_leading_backslashes(string2, search_start_index) {
  let i = search_start_index;
  let count = 0;
  while (string2[i] === "\\") {
    count++;
    i--;
  }
  return count;
}
function find_matching_bracket(template3, index, open2) {
  const close2 = get_bracket_close(open2);
  let brackets = 1;
  let i = index;
  while (brackets > 0 && i < template3.length) {
    const char = template3[i];
    switch (char) {
      case "'":
      case '"':
      case "`":
        i = find_string_end(template3, i + 1, char) + 1;
        continue;
      case "/": {
        const next_char = template3[i + 1];
        if (!next_char) continue;
        if (next_char === "/") {
          i = infinity_if_negative(template3.indexOf("\n", i + 1)) + "\n".length;
          continue;
        }
        if (next_char === "*") {
          i = infinity_if_negative(template3.indexOf("*/", i + 1)) + "*/".length;
          continue;
        }
        i = find_regex_end(template3, i + 1) + "/".length;
        continue;
      }
      default: {
        const char2 = template3[i];
        if (char2 === open2) {
          brackets++;
        } else if (char2 === close2) {
          brackets--;
        }
        if (brackets === 0) {
          return i;
        }
        i++;
      }
    }
  }
  return void 0;
}

// node_modules/svelte/src/compiler/phases/1-parse/read/expression.js
function get_loose_identifier(parser, opening_token) {
  const end = find_matching_bracket(parser.template, parser.index, opening_token ?? "{");
  if (end) {
    const start = parser.index;
    parser.index = end;
    return {
      type: "Identifier",
      start,
      end,
      name: ""
    };
  }
}
function read_expression(parser, opening_token, disallow_loose) {
  try {
    const node = parse_expression_at(parser.template, parser.ts, parser.index);
    let num_parens = 0;
    if (node.leadingComments !== void 0 && node.leadingComments.length > 0) {
      parser.index = node.leadingComments.at(-1).end;
    }
    for (let i = parser.index; i < /** @type {number} */
    node.start; i += 1) {
      if (parser.template[i] === "(") num_parens += 1;
    }
    let index = (
      /** @type {number} */
      node.end
    );
    if (node.trailingComments !== void 0 && node.trailingComments.length > 0) {
      index = node.trailingComments.at(-1).end;
    }
    while (num_parens > 0) {
      const char = parser.template[index];
      if (char === ")") {
        num_parens -= 1;
      } else if (!regex_whitespace.test(char)) {
        expected_token(index, ")");
      }
      index += 1;
    }
    parser.index = index;
    return (
      /** @type {Expression} */
      node
    );
  } catch (err) {
    if (parser.loose && !disallow_loose) {
      const expression = get_loose_identifier(parser, opening_token);
      if (expression) {
        return expression;
      }
    }
    parser.acorn_error(err);
  }
}

// node_modules/svelte/src/compiler/utils/sanitize_template_string.js
function sanitize_template_string(str) {
  return str.replace(/(`|\${|\\)/g, "\\$1");
}

// node_modules/svelte/src/compiler/utils/builders.js
function array(elements = []) {
  return { type: "ArrayExpression", elements };
}
function array_pattern(elements) {
  return { type: "ArrayPattern", elements };
}
function assignment_pattern(left, right) {
  return { type: "AssignmentPattern", left, right };
}
function arrow(params, body) {
  return {
    type: "ArrowFunctionExpression",
    params,
    body,
    expression: body.type !== "BlockStatement",
    generator: false,
    async: false,
    metadata: (
      /** @type {any} */
      null
    )
    // should not be used by codegen
  };
}
function assignment(operator, left, right) {
  return { type: "AssignmentExpression", operator, left, right };
}
function async(func) {
  return { ...func, async: true };
}
function await_builder(argument) {
  return { type: "AwaitExpression", argument };
}
function binary(operator, left, right) {
  return { type: "BinaryExpression", operator, left, right };
}
function block(body) {
  return { type: "BlockStatement", body };
}
function labeled(name, body) {
  return { type: "LabeledStatement", label: id(name), body };
}
function call(callee, ...args) {
  if (typeof callee === "string") callee = id(callee);
  args = args.slice();
  let i = args.length;
  let popping = true;
  while (i--) {
    if (!args[i]) {
      if (popping) {
        args.pop();
      } else {
        args[i] = id("undefined");
      }
    } else {
      popping = false;
    }
  }
  return {
    type: "CallExpression",
    callee,
    arguments: (
      /** @type {Array<ESTree.Expression | ESTree.SpreadElement>} */
      args
    ),
    optional: false
  };
}
function maybe_call(callee, ...args) {
  const expression = (
    /** @type {ESTree.SimpleCallExpression} */
    call(callee, ...args)
  );
  expression.optional = true;
  return {
    type: "ChainExpression",
    expression
  };
}
function unary(operator, argument) {
  return { type: "UnaryExpression", argument, operator, prefix: true };
}
var void0 = unary("void", literal(0));
function logical(operator, left, right) {
  return { type: "LogicalExpression", operator, left, right };
}
function declaration(kind, declarations) {
  return {
    type: "VariableDeclaration",
    kind,
    declarations
  };
}
function declarator(pattern, init2) {
  if (typeof pattern === "string") pattern = id(pattern);
  return { type: "VariableDeclarator", id: pattern, init: init2 };
}
var empty = {
  type: "EmptyStatement"
};
function export_default(declaration2) {
  return { type: "ExportDefaultDeclaration", declaration: declaration2 };
}
function function_declaration(id2, params, body) {
  return {
    type: "FunctionDeclaration",
    id: id2,
    params,
    body,
    generator: false,
    async: false,
    metadata: (
      /** @type {any} */
      null
    )
    // should not be used by codegen
  };
}
function get(name, body) {
  return prop("get", key(name), function_builder(null, [], block(body)));
}
function id(name) {
  return { type: "Identifier", name };
}
function private_id(name) {
  return { type: "PrivateIdentifier", name };
}
function import_namespace(local) {
  return {
    type: "ImportNamespaceSpecifier",
    local: id(local)
  };
}
function init(name, value) {
  return prop("init", key(name), value);
}
function literal(value) {
  return { type: "Literal", value };
}
function member(object4, property, computed = false, optional = false) {
  if (typeof property === "string") {
    property = id(property);
  }
  return { type: "MemberExpression", object: object4, property, computed, optional };
}
function member_id(path) {
  const parts = path.split(".");
  let expression = id(parts[0]);
  for (let i = 1; i < parts.length; i += 1) {
    expression = member(expression, id(parts[i]));
  }
  return expression;
}
function object(properties) {
  return { type: "ObjectExpression", properties };
}
function object_pattern(properties) {
  return { type: "ObjectPattern", properties };
}
function prop(kind, key2, value, computed = false) {
  return { type: "Property", kind, key: key2, value, method: false, shorthand: false, computed };
}
function prop_def(key2, value, computed = false, is_static = false) {
  return { type: "PropertyDefinition", key: key2, value, computed, static: is_static };
}
function quasi(cooked, tail = false) {
  const raw = sanitize_template_string(cooked);
  return { type: "TemplateElement", value: { raw, cooked }, tail };
}
function rest(argument) {
  return { type: "RestElement", argument };
}
function sequence(expressions) {
  return { type: "SequenceExpression", expressions };
}
function set(name, body) {
  return prop("set", key(name), function_builder(null, [id("$$value")], block(body)));
}
function spread(argument) {
  return { type: "SpreadElement", argument };
}
function stmt(expression) {
  return { type: "ExpressionStatement", expression };
}
function template(elements, expressions) {
  return { type: "TemplateLiteral", quasis: elements, expressions };
}
function thunk(expression, async2 = false) {
  const fn = arrow([], expression);
  if (async2) fn.async = true;
  return unthunk(fn);
}
function unthunk(expression) {
  if (expression.type === "ArrowFunctionExpression" && expression.async === false && expression.body.type === "CallExpression" && expression.body.callee.type === "Identifier" && expression.params.length === expression.body.arguments.length && expression.params.every((param, index) => {
    const arg = (
      /** @type {ESTree.SimpleCallExpression} */
      expression.body.arguments[index]
    );
    return param.type === "Identifier" && arg.type === "Identifier" && param.name === arg.name;
  })) {
    return expression.body.callee;
  }
  return expression;
}
function new_builder(expression, ...args) {
  if (typeof expression === "string") expression = id(expression);
  return {
    callee: expression,
    arguments: args,
    type: "NewExpression"
  };
}
function update(operator, argument, prefix = false) {
  return { type: "UpdateExpression", operator, argument, prefix };
}
function do_while(test, body) {
  return { type: "DoWhileStatement", test, body };
}
var true_instance = literal(true);
var false_instance = literal(false);
var null_instance = literal(null);
var debugger_builder = {
  type: "DebuggerStatement"
};
var this_instance = {
  type: "ThisExpression"
};
function let_builder(pattern, init2) {
  return declaration("let", [declarator(pattern, init2)]);
}
function const_builder(pattern, init2) {
  return declaration("const", [declarator(pattern, init2)]);
}
function var_builder(pattern, init2) {
  return declaration("var", [declarator(pattern, init2)]);
}
function for_builder(init2, test, update2, body) {
  return { type: "ForStatement", init: init2, test, update: update2, body };
}
function method(kind, key2, params, body, computed = false, is_static = false) {
  return {
    type: "MethodDefinition",
    key: key2,
    kind,
    value: function_builder(null, params, block(body)),
    computed,
    static: is_static
  };
}
function function_builder(id2, params, body) {
  return {
    type: "FunctionExpression",
    id: id2,
    params,
    body,
    generator: false,
    async: false,
    metadata: (
      /** @type {any} */
      null
    )
    // should not be used by codegen
  };
}
function if_builder(test, consequent, alternate) {
  return { type: "IfStatement", test, consequent, alternate };
}
function import_all(as, source2) {
  return {
    type: "ImportDeclaration",
    source: literal(source2),
    specifiers: [import_namespace(as)]
  };
}
function imports(parts, source2) {
  return {
    type: "ImportDeclaration",
    source: literal(source2),
    specifiers: parts.map((p) => ({
      type: "ImportSpecifier",
      imported: id(p[0]),
      local: id(p[1])
    }))
  };
}
function return_builder(argument = null) {
  return { type: "ReturnStatement", argument };
}
function throw_error(str) {
  return {
    type: "ThrowStatement",
    argument: new_builder("Error", literal(str))
  };
}
function key(name) {
  return regex_is_valid_identifier.test(name) ? id(name) : literal(name);
}

// node_modules/svelte/src/compiler/utils/ast.js
function object2(expression) {
  while (expression.type === "MemberExpression") {
    expression = /** @type {ESTree.MemberExpression | ESTree.Identifier} */
    expression.object;
  }
  if (expression.type !== "Identifier") {
    return null;
  }
  return expression;
}
function is_text_attribute(attribute) {
  return Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === "Text";
}
function is_expression_attribute(attribute) {
  return attribute.value !== true && !Array.isArray(attribute.value) || Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === "ExpressionTag";
}
function get_attribute_expression(attribute) {
  return Array.isArray(attribute.value) ? (
    /** @type {AST.ExpressionTag} */
    attribute.value[0].expression
  ) : attribute.value.expression;
}
function get_attribute_chunks(value) {
  return Array.isArray(value) ? value : typeof value === "boolean" ? [] : [value];
}
function is_event_attribute(attribute) {
  return is_expression_attribute(attribute) && attribute.name.startsWith("on");
}
function unwrap_pattern(pattern, nodes = []) {
  switch (pattern.type) {
    case "Identifier":
      nodes.push(pattern);
      break;
    case "MemberExpression":
      nodes.push(pattern);
      break;
    case "ObjectPattern":
      for (const prop2 of pattern.properties) {
        if (prop2.type === "RestElement") {
          unwrap_pattern(prop2.argument, nodes);
        } else {
          unwrap_pattern(prop2.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      for (const element2 of pattern.elements) {
        if (element2) unwrap_pattern(element2, nodes);
      }
      break;
    case "RestElement":
      unwrap_pattern(pattern.argument, nodes);
      break;
    case "AssignmentPattern":
      unwrap_pattern(pattern.left, nodes);
      break;
  }
  return nodes;
}
function extract_identifiers(pattern) {
  return unwrap_pattern(pattern, []).filter((node) => node.type === "Identifier");
}
function extract_all_identifiers_from_expression(expr) {
  let nodes = [];
  let keypath = [];
  walk(
    expr,
    {},
    {
      Identifier(node, { path }) {
        const parent = path.at(-1);
        if ((parent == null ? void 0 : parent.type) !== "MemberExpression" || parent.property !== node || parent.computed) {
          nodes.push(node);
        }
        if ((parent == null ? void 0 : parent.type) === "MemberExpression" && parent.computed && parent.property === node) {
          keypath.push(`[${node.name}]`);
        } else {
          keypath.push(node.name);
        }
      },
      Literal(node, { path }) {
        const value = typeof node.value === "string" ? `"${node.value}"` : String(node.value);
        const parent = path.at(-1);
        if ((parent == null ? void 0 : parent.type) === "MemberExpression" && parent.computed && parent.property === node) {
          keypath.push(`[${value}]`);
        } else {
          keypath.push(value);
        }
      },
      ThisExpression(_, { next: next2 }) {
        keypath.push("this");
        next2();
      }
    }
  );
  return [keypath.join("."), nodes];
}
function extract_identifiers_from_destructuring(node, nodes = []) {
  switch (node.type) {
    case "Identifier":
      nodes.push(node);
      break;
    case "ObjectExpression":
      for (const prop2 of node.properties) {
        if (prop2.type === "Property") {
          extract_identifiers_from_destructuring(
            /** @type {any} */
            prop2.value,
            nodes
          );
        } else {
          extract_identifiers_from_destructuring(
            /** @type {any} */
            prop2.argument,
            nodes
          );
        }
      }
      break;
    case "ArrayExpression":
      for (const element2 of node.elements) {
        if (element2) extract_identifiers_from_destructuring(
          /** @type {any} */
          element2,
          nodes
        );
      }
      break;
  }
  return nodes;
}
function extract_paths(param) {
  return _extract_paths(
    [],
    param,
    (node) => (
      /** @type {ESTree.Identifier | ESTree.MemberExpression} */
      node
    ),
    (node) => (
      /** @type {ESTree.Identifier | ESTree.MemberExpression} */
      node
    ),
    false
  );
}
function _extract_paths(assignments = [], param, expression, update_expression, has_default_value) {
  switch (param.type) {
    case "Identifier":
    case "MemberExpression":
      assignments.push({
        node: param,
        is_rest: false,
        has_default_value,
        expression,
        update_expression
      });
      break;
    case "ObjectPattern":
      for (const prop2 of param.properties) {
        if (prop2.type === "RestElement") {
          const rest_expression = (object4) => {
            const props = [];
            for (const p of param.properties) {
              if (p.type === "Property" && p.key.type !== "PrivateIdentifier") {
                if (p.key.type === "Identifier" && !p.computed) {
                  props.push(literal(p.key.name));
                } else if (p.key.type === "Literal") {
                  props.push(literal(String(p.key.value)));
                } else {
                  props.push(call("String", p.key));
                }
              }
            }
            return call("$.exclude_from_object", expression(object4), array(props));
          };
          if (prop2.argument.type === "Identifier") {
            assignments.push({
              node: prop2.argument,
              is_rest: true,
              has_default_value,
              expression: rest_expression,
              update_expression: rest_expression
            });
          } else {
            _extract_paths(
              assignments,
              prop2.argument,
              rest_expression,
              rest_expression,
              has_default_value
            );
          }
        } else {
          const object_expression = (object4) => member(expression(object4), prop2.key, prop2.computed || prop2.key.type !== "Identifier");
          _extract_paths(
            assignments,
            prop2.value,
            object_expression,
            object_expression,
            has_default_value
          );
        }
      }
      break;
    case "ArrayPattern":
      for (let i = 0; i < param.elements.length; i += 1) {
        const element2 = param.elements[i];
        if (element2) {
          if (element2.type === "RestElement") {
            const rest_expression = (object4) => call(member(expression(object4), "slice"), literal(i));
            if (element2.argument.type === "Identifier") {
              assignments.push({
                node: element2.argument,
                is_rest: true,
                has_default_value,
                expression: rest_expression,
                update_expression: rest_expression
              });
            } else {
              _extract_paths(
                assignments,
                element2.argument,
                rest_expression,
                rest_expression,
                has_default_value
              );
            }
          } else {
            const array_expression = (object4) => member(expression(object4), literal(i), true);
            _extract_paths(
              assignments,
              element2,
              array_expression,
              array_expression,
              has_default_value
            );
          }
        }
      }
      break;
    case "AssignmentPattern": {
      const fallback_expression = (object4) => build_fallback(expression(object4), param.right);
      if (param.left.type === "Identifier") {
        assignments.push({
          node: param.left,
          is_rest: false,
          has_default_value: true,
          expression: fallback_expression,
          update_expression
        });
      } else {
        _extract_paths(assignments, param.left, fallback_expression, update_expression, true);
      }
      break;
    }
  }
  return assignments;
}
function get_parent(path, at) {
  let node = path.at(at);
  if (node.type === "TSNonNullExpression" || node.type === "TSAsExpression") {
    return (
      /** @type {T} */
      path.at(at < 0 ? at - 1 : at + 1)
    );
  }
  return (
    /** @type {T} */
    node
  );
}
function is_simple_expression(node) {
  if (node.type === "Literal" || node.type === "Identifier" || node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression") {
    return true;
  }
  if (node.type === "ConditionalExpression") {
    return is_simple_expression(node.test) && is_simple_expression(node.consequent) && is_simple_expression(node.alternate);
  }
  if (node.type === "BinaryExpression" || node.type === "LogicalExpression") {
    return node.left.type !== "PrivateIdentifier" && is_simple_expression(node.left) && is_simple_expression(node.right);
  }
  return false;
}
function unwrap_optional(node) {
  return node.type === "ChainExpression" ? node.expression : node;
}
function is_expression_async(expression) {
  switch (expression.type) {
    case "AwaitExpression": {
      return true;
    }
    case "ArrayPattern": {
      return expression.elements.some((element2) => element2 && is_expression_async(element2));
    }
    case "ArrayExpression": {
      return expression.elements.some((element2) => {
        if (!element2) {
          return false;
        } else if (element2.type === "SpreadElement") {
          return is_expression_async(element2.argument);
        } else {
          return is_expression_async(element2);
        }
      });
    }
    case "AssignmentPattern":
    case "AssignmentExpression":
    case "BinaryExpression":
    case "LogicalExpression": {
      return expression.left.type !== "PrivateIdentifier" && is_expression_async(expression.left) || is_expression_async(expression.right);
    }
    case "CallExpression":
    case "NewExpression": {
      return expression.callee.type !== "Super" && is_expression_async(expression.callee) || expression.arguments.some((element2) => {
        if (element2.type === "SpreadElement") {
          return is_expression_async(element2.argument);
        } else {
          return is_expression_async(element2);
        }
      });
    }
    case "ChainExpression": {
      return is_expression_async(expression.expression);
    }
    case "ConditionalExpression": {
      return is_expression_async(expression.test) || is_expression_async(expression.alternate) || is_expression_async(expression.consequent);
    }
    case "ImportExpression": {
      return is_expression_async(expression.source);
    }
    case "MemberExpression": {
      return expression.object.type !== "Super" && is_expression_async(expression.object) || expression.property.type !== "PrivateIdentifier" && is_expression_async(expression.property);
    }
    case "ObjectPattern":
    case "ObjectExpression": {
      return expression.properties.some((property) => {
        if (property.type === "SpreadElement") {
          return is_expression_async(property.argument);
        } else if (property.type === "Property") {
          return property.key.type !== "PrivateIdentifier" && is_expression_async(property.key) || is_expression_async(property.value);
        }
      });
    }
    case "RestElement": {
      return is_expression_async(expression.argument);
    }
    case "SequenceExpression":
    case "TemplateLiteral": {
      return expression.expressions.some((subexpression) => is_expression_async(subexpression));
    }
    case "TaggedTemplateExpression": {
      return is_expression_async(expression.tag) || is_expression_async(expression.quasi);
    }
    case "UnaryExpression":
    case "UpdateExpression": {
      return is_expression_async(expression.argument);
    }
    case "YieldExpression": {
      return expression.argument ? is_expression_async(expression.argument) : false;
    }
    default:
      return false;
  }
}
function build_fallback(expression, fallback) {
  if (is_simple_expression(fallback)) {
    return call("$.fallback", expression, fallback);
  }
  if (fallback.type === "AwaitExpression" && is_simple_expression(fallback.argument)) {
    return await_builder(call("$.fallback", expression, fallback.argument));
  }
  return is_expression_async(fallback) ? await_builder(call("$.fallback", expression, thunk(fallback, true), true_instance)) : call("$.fallback", expression, thunk(fallback), true_instance);
}
function build_assignment_value(operator, left, right) {
  return operator === "=" ? right : (
    // turn something like x += 1 into x = x + 1
    ["||=", "&&=", "??="].includes(operator) ? logical(
      /** @type {ESTree.LogicalOperator} */
      operator.slice(0, -1),
      left,
      right
    ) : binary(
      /** @type {ESTree.BinaryOperator} */
      operator.slice(0, -1),
      left,
      right
    )
  );
}

// node_modules/svelte/src/compiler/phases/1-parse/read/script.js
var regex_closing_script_tag = /<\/script\s*>/;
var regex_starts_with_closing_script_tag = /^<\/script\s*>/;
var RESERVED_ATTRIBUTES = ["server", "client", "worker", "test", "default"];
var ALLOWED_ATTRIBUTES = ["context", "generics", "lang", "module"];
function read_script(parser, start, attributes) {
  const script_start = parser.index;
  const data = parser.read_until(regex_closing_script_tag);
  if (parser.index >= parser.template.length) {
    element_unclosed(parser.template.length, "script");
  }
  const source2 = parser.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data;
  parser.read(regex_starts_with_closing_script_tag);
  let ast;
  try {
    ast = parse(source2, parser.ts, true);
  } catch (err) {
    parser.acorn_error(err);
  }
  ast.start = script_start;
  let context = "default";
  for (
    const attribute of
    /** @type {AST.Attribute[]} */
    attributes
  ) {
    if (RESERVED_ATTRIBUTES.includes(attribute.name)) {
      script_reserved_attribute(attribute, attribute.name);
    }
    if (!ALLOWED_ATTRIBUTES.includes(attribute.name)) {
      script_unknown_attribute(attribute);
    }
    if (attribute.name === "module") {
      if (attribute.value !== true) {
        script_invalid_attribute_value(attribute, attribute.name);
      }
      context = "module";
    }
    if (attribute.name === "context") {
      if (attribute.value === true || !is_text_attribute(attribute)) {
        script_invalid_context(attribute);
      }
      const value = attribute.value[0].data;
      if (value !== "module") {
        script_invalid_context(attribute);
      }
      context = "module";
    }
  }
  return {
    type: "Script",
    start,
    end: parser.index,
    context,
    content: ast,
    // @ts-ignore
    attributes
  };
}

// node_modules/svelte/src/compiler/phases/1-parse/read/style.js
var REGEX_MATCHER = /^[~^$*|]?=/;
var REGEX_CLOSING_BRACKET = /[\s\]]/;
var REGEX_ATTRIBUTE_FLAGS = /^[a-zA-Z]+/;
var REGEX_COMBINATOR = /^(\+|~|>|\|\|)/;
var REGEX_PERCENTAGE = /^\d+(\.\d+)?%/;
var REGEX_NTH_OF = /^(even|odd|\+?(\d+|\d*n(\s*[+-]\s*\d+)?)|-\d*n(\s*\+\s*\d+))((?=\s*[,)])|\s+of\s+)/;
var REGEX_WHITESPACE_OR_COLON = /[\s:]/;
var REGEX_LEADING_HYPHEN_OR_DIGIT = /-?\d/;
var REGEX_VALID_IDENTIFIER_CHAR = /[a-zA-Z0-9_-]/;
var REGEX_COMMENT_CLOSE = /\*\//;
var REGEX_HTML_COMMENT_CLOSE = /-->/;
function read_style(parser, start, attributes) {
  const content_start = parser.index;
  const children = read_body(parser, "</style");
  const content_end = parser.index;
  parser.read(/^<\/style\s*>/);
  return {
    type: "StyleSheet",
    start,
    end: parser.index,
    attributes,
    children,
    content: {
      start: content_start,
      end: content_end,
      styles: parser.template.slice(content_start, content_end),
      comment: null
    }
  };
}
function read_body(parser, close2) {
  const children = [];
  while (parser.index < parser.template.length) {
    allow_comment_or_whitespace(parser);
    if (parser.match(close2)) {
      return children;
    }
    if (parser.match("@")) {
      children.push(read_at_rule(parser));
    } else {
      children.push(read_rule(parser));
    }
  }
  expected_token(parser.template.length, close2);
}
function read_at_rule(parser) {
  const start = parser.index;
  parser.eat("@", true);
  const name = read_identifier(parser);
  const prelude = read_value(parser);
  let block2 = null;
  if (parser.match("{")) {
    block2 = read_block(parser);
  } else {
    parser.eat(";", true);
  }
  return {
    type: "Atrule",
    start,
    end: parser.index,
    name,
    prelude,
    block: block2
  };
}
function read_rule(parser) {
  const start = parser.index;
  return {
    type: "Rule",
    prelude: read_selector_list(parser),
    block: read_block(parser),
    start,
    end: parser.index,
    metadata: {
      parent_rule: null,
      has_local_selectors: false,
      has_global_selectors: false,
      is_global_block: false
    }
  };
}
function read_selector_list(parser, inside_pseudo_class = false) {
  const children = [];
  allow_comment_or_whitespace(parser);
  const start = parser.index;
  while (parser.index < parser.template.length) {
    children.push(read_selector(parser, inside_pseudo_class));
    const end = parser.index;
    allow_comment_or_whitespace(parser);
    if (inside_pseudo_class ? parser.match(")") : parser.match("{")) {
      return {
        type: "SelectorList",
        start,
        end,
        children
      };
    } else {
      parser.eat(",", true);
      allow_comment_or_whitespace(parser);
    }
  }
  unexpected_eof(parser.template.length);
}
function read_selector(parser, inside_pseudo_class = false) {
  const list_start = parser.index;
  const children = [];
  function create_selector(combinator, start) {
    return {
      type: "RelativeSelector",
      combinator,
      selectors: [],
      start,
      end: -1,
      metadata: {
        is_global: false,
        is_global_like: false,
        scoped: false
      }
    };
  }
  let relative_selector = create_selector(null, parser.index);
  while (parser.index < parser.template.length) {
    let start = parser.index;
    if (parser.eat("&")) {
      relative_selector.selectors.push({
        type: "NestingSelector",
        name: "&",
        start,
        end: parser.index
      });
    } else if (parser.eat("*")) {
      let name = "*";
      if (parser.eat("|")) {
        name = read_identifier(parser);
      }
      relative_selector.selectors.push({
        type: "TypeSelector",
        name,
        start,
        end: parser.index
      });
    } else if (parser.eat("#")) {
      relative_selector.selectors.push({
        type: "IdSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
    } else if (parser.eat(".")) {
      relative_selector.selectors.push({
        type: "ClassSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
    } else if (parser.eat("::")) {
      relative_selector.selectors.push({
        type: "PseudoElementSelector",
        name: read_identifier(parser),
        start,
        end: parser.index
      });
      if (parser.eat("(")) {
        read_selector_list(parser, true);
        parser.eat(")", true);
      }
    } else if (parser.eat(":")) {
      const name = read_identifier(parser);
      let args = null;
      if (parser.eat("(")) {
        args = read_selector_list(parser, true);
        parser.eat(")", true);
      }
      relative_selector.selectors.push({
        type: "PseudoClassSelector",
        name,
        args,
        start,
        end: parser.index
      });
    } else if (parser.eat("[")) {
      parser.allow_whitespace();
      const name = read_identifier(parser);
      parser.allow_whitespace();
      let value = null;
      const matcher = parser.read(REGEX_MATCHER);
      if (matcher) {
        parser.allow_whitespace();
        value = read_attribute_value(parser);
      }
      parser.allow_whitespace();
      const flags = parser.read(REGEX_ATTRIBUTE_FLAGS);
      parser.allow_whitespace();
      parser.eat("]", true);
      relative_selector.selectors.push({
        type: "AttributeSelector",
        start,
        end: parser.index,
        name,
        matcher,
        value,
        flags
      });
    } else if (inside_pseudo_class && parser.match_regex(REGEX_NTH_OF)) {
      relative_selector.selectors.push({
        type: "Nth",
        value: (
          /**@type {string} */
          parser.read(REGEX_NTH_OF)
        ),
        start,
        end: parser.index
      });
    } else if (parser.match_regex(REGEX_PERCENTAGE)) {
      relative_selector.selectors.push({
        type: "Percentage",
        value: (
          /** @type {string} */
          parser.read(REGEX_PERCENTAGE)
        ),
        start,
        end: parser.index
      });
    } else if (!parser.match_regex(REGEX_COMBINATOR)) {
      let name = read_identifier(parser);
      if (parser.eat("|")) {
        name = read_identifier(parser);
      }
      relative_selector.selectors.push({
        type: "TypeSelector",
        name,
        start,
        end: parser.index
      });
    }
    const index = parser.index;
    allow_comment_or_whitespace(parser);
    if (parser.match(",") || (inside_pseudo_class ? parser.match(")") : parser.match("{"))) {
      parser.index = index;
      relative_selector.end = index;
      children.push(relative_selector);
      return {
        type: "ComplexSelector",
        start: list_start,
        end: index,
        children,
        metadata: {
          rule: null,
          is_global: false,
          used: false
        }
      };
    }
    parser.index = index;
    const combinator = read_combinator(parser);
    if (combinator) {
      if (relative_selector.selectors.length > 0) {
        relative_selector.end = index;
        children.push(relative_selector);
      }
      relative_selector = create_selector(combinator, combinator.start);
      parser.allow_whitespace();
      if (parser.match(",") || (inside_pseudo_class ? parser.match(")") : parser.match("{"))) {
        css_selector_invalid(parser.index);
      }
    }
  }
  unexpected_eof(parser.template.length);
}
function read_combinator(parser) {
  const start = parser.index;
  parser.allow_whitespace();
  const index = parser.index;
  const name = parser.read(REGEX_COMBINATOR);
  if (name) {
    const end = parser.index;
    parser.allow_whitespace();
    return {
      type: "Combinator",
      name,
      start: index,
      end
    };
  }
  if (parser.index !== start) {
    return {
      type: "Combinator",
      name: " ",
      start,
      end: parser.index
    };
  }
  return null;
}
function read_block(parser) {
  const start = parser.index;
  parser.eat("{", true);
  const children = [];
  while (parser.index < parser.template.length) {
    allow_comment_or_whitespace(parser);
    if (parser.match("}")) {
      break;
    } else {
      children.push(read_block_item(parser));
    }
  }
  parser.eat("}", true);
  return {
    type: "Block",
    start,
    end: parser.index,
    children
  };
}
function read_block_item(parser) {
  if (parser.match("@")) {
    return read_at_rule(parser);
  }
  const start = parser.index;
  read_value(parser);
  const char = parser.template[parser.index];
  parser.index = start;
  return char === "{" ? read_rule(parser) : read_declaration(parser);
}
function read_declaration(parser) {
  const start = parser.index;
  const property = parser.read_until(REGEX_WHITESPACE_OR_COLON);
  parser.allow_whitespace();
  parser.eat(":");
  let index = parser.index;
  parser.allow_whitespace();
  const value = read_value(parser);
  if (!value && !property.startsWith("--")) {
    css_empty_declaration({ start, end: index });
  }
  const end = parser.index;
  if (!parser.match("}")) {
    parser.eat(";", true);
  }
  return {
    type: "Declaration",
    start,
    end,
    property,
    value
  };
}
function read_value(parser) {
  let value = "";
  let escaped = false;
  let in_url = false;
  let quote_mark = null;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      value += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (char === quote_mark) {
      quote_mark = null;
    } else if (char === ")") {
      in_url = false;
    } else if (quote_mark === null && (char === '"' || char === "'")) {
      quote_mark = char;
    } else if (char === "(" && value.slice(-3) === "url") {
      in_url = true;
    } else if ((char === ";" || char === "{" || char === "}") && !in_url && !quote_mark) {
      return value.trim();
    }
    value += char;
    parser.index++;
  }
  unexpected_eof(parser.template.length);
}
function read_attribute_value(parser) {
  let value = "";
  let escaped = false;
  const quote_mark = parser.eat('"') ? '"' : parser.eat("'") ? "'" : null;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      value += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (quote_mark ? char === quote_mark : REGEX_CLOSING_BRACKET.test(char)) {
      if (quote_mark) {
        parser.eat(quote_mark, true);
      }
      return value.trim();
    } else {
      value += char;
    }
    parser.index++;
  }
  unexpected_eof(parser.template.length);
}
function read_identifier(parser) {
  const start = parser.index;
  let identifier = "";
  if (parser.match_regex(REGEX_LEADING_HYPHEN_OR_DIGIT)) {
    css_expected_identifier(start);
  }
  let escaped = false;
  while (parser.index < parser.template.length) {
    const char = parser.template[parser.index];
    if (escaped) {
      identifier += "\\" + char;
      escaped = false;
    } else if (char === "\\") {
      escaped = true;
    } else if (
      /** @type {number} */
      char.codePointAt(0) >= 160 || REGEX_VALID_IDENTIFIER_CHAR.test(char)
    ) {
      identifier += char;
    } else {
      break;
    }
    parser.index++;
  }
  if (identifier === "") {
    css_expected_identifier(start);
  }
  return identifier;
}
function allow_comment_or_whitespace(parser) {
  parser.allow_whitespace();
  while (parser.match("/*") || parser.match("<!--")) {
    if (parser.eat("/*")) {
      parser.read_until(REGEX_COMMENT_CLOSE);
      parser.eat("*/", true);
    }
    if (parser.eat("<!--")) {
      parser.read_until(REGEX_HTML_COMMENT_CLOSE);
      parser.eat("-->", true);
    }
    parser.allow_whitespace();
  }
}

// node_modules/svelte/src/compiler/phases/1-parse/utils/entities.js
var entities_default = {
  "CounterClockwiseContourIntegral;": 8755,
  "ClockwiseContourIntegral;": 8754,
  "DoubleLongLeftRightArrow;": 10234,
  "NotNestedGreaterGreater;": 10914,
  "DiacriticalDoubleAcute;": 733,
  "NotSquareSupersetEqual;": 8931,
  "CloseCurlyDoubleQuote;": 8221,
  "DoubleContourIntegral;": 8751,
  "FilledVerySmallSquare;": 9642,
  "NegativeVeryThinSpace;": 8203,
  "NotPrecedesSlantEqual;": 8928,
  "NotRightTriangleEqual;": 8941,
  "NotSucceedsSlantEqual;": 8929,
  "CapitalDifferentialD;": 8517,
  "DoubleLeftRightArrow;": 8660,
  "DoubleLongRightArrow;": 10233,
  "EmptyVerySmallSquare;": 9643,
  "NestedGreaterGreater;": 8811,
  "NotDoubleVerticalBar;": 8742,
  "NotGreaterSlantEqual;": 10878,
  "NotLeftTriangleEqual;": 8940,
  "NotSquareSubsetEqual;": 8930,
  "OpenCurlyDoubleQuote;": 8220,
  "ReverseUpEquilibrium;": 10607,
  "DoubleLongLeftArrow;": 10232,
  "DownLeftRightVector;": 10576,
  "LeftArrowRightArrow;": 8646,
  "NegativeMediumSpace;": 8203,
  "NotGreaterFullEqual;": 8807,
  "NotRightTriangleBar;": 10704,
  "RightArrowLeftArrow;": 8644,
  "SquareSupersetEqual;": 8850,
  "leftrightsquigarrow;": 8621,
  "DownRightTeeVector;": 10591,
  "DownRightVectorBar;": 10583,
  "LongLeftRightArrow;": 10231,
  "Longleftrightarrow;": 10234,
  "NegativeThickSpace;": 8203,
  "NotLeftTriangleBar;": 10703,
  "PrecedesSlantEqual;": 8828,
  "ReverseEquilibrium;": 8651,
  "RightDoubleBracket;": 10215,
  "RightDownTeeVector;": 10589,
  "RightDownVectorBar;": 10581,
  "RightTriangleEqual;": 8885,
  "SquareIntersection;": 8851,
  "SucceedsSlantEqual;": 8829,
  "blacktriangleright;": 9656,
  "longleftrightarrow;": 10231,
  "DoubleUpDownArrow;": 8661,
  "DoubleVerticalBar;": 8741,
  "DownLeftTeeVector;": 10590,
  "DownLeftVectorBar;": 10582,
  "FilledSmallSquare;": 9724,
  "GreaterSlantEqual;": 10878,
  "LeftDoubleBracket;": 10214,
  "LeftDownTeeVector;": 10593,
  "LeftDownVectorBar;": 10585,
  "LeftTriangleEqual;": 8884,
  "NegativeThinSpace;": 8203,
  "NotGreaterGreater;": 8811,
  "NotLessSlantEqual;": 10877,
  "NotNestedLessLess;": 10913,
  "NotReverseElement;": 8716,
  "NotSquareSuperset;": 8848,
  "NotTildeFullEqual;": 8775,
  "RightAngleBracket;": 10217,
  "RightUpDownVector;": 10575,
  "SquareSubsetEqual;": 8849,
  "VerticalSeparator;": 10072,
  "blacktriangledown;": 9662,
  "blacktriangleleft;": 9666,
  "leftrightharpoons;": 8651,
  "rightleftharpoons;": 8652,
  "twoheadrightarrow;": 8608,
  "DiacriticalAcute;": 180,
  "DiacriticalGrave;": 96,
  "DiacriticalTilde;": 732,
  "DoubleRightArrow;": 8658,
  "DownArrowUpArrow;": 8693,
  "EmptySmallSquare;": 9723,
  "GreaterEqualLess;": 8923,
  "GreaterFullEqual;": 8807,
  "LeftAngleBracket;": 10216,
  "LeftUpDownVector;": 10577,
  "LessEqualGreater;": 8922,
  "NonBreakingSpace;": 160,
  "NotPrecedesEqual;": 10927,
  "NotRightTriangle;": 8939,
  "NotSucceedsEqual;": 10928,
  "NotSucceedsTilde;": 8831,
  "NotSupersetEqual;": 8841,
  "RightTriangleBar;": 10704,
  "RightUpTeeVector;": 10588,
  "RightUpVectorBar;": 10580,
  "UnderParenthesis;": 9181,
  "UpArrowDownArrow;": 8645,
  "circlearrowright;": 8635,
  "downharpoonright;": 8642,
  "ntrianglerighteq;": 8941,
  "rightharpoondown;": 8641,
  "rightrightarrows;": 8649,
  "twoheadleftarrow;": 8606,
  "vartriangleright;": 8883,
  "CloseCurlyQuote;": 8217,
  "ContourIntegral;": 8750,
  "DoubleDownArrow;": 8659,
  "DoubleLeftArrow;": 8656,
  "DownRightVector;": 8641,
  "LeftRightVector;": 10574,
  "LeftTriangleBar;": 10703,
  "LeftUpTeeVector;": 10592,
  "LeftUpVectorBar;": 10584,
  "LowerRightArrow;": 8600,
  "NotGreaterEqual;": 8817,
  "NotGreaterTilde;": 8821,
  "NotHumpDownHump;": 8782,
  "NotLeftTriangle;": 8938,
  "NotSquareSubset;": 8847,
  "OverParenthesis;": 9180,
  "RightDownVector;": 8642,
  "ShortRightArrow;": 8594,
  "UpperRightArrow;": 8599,
  "bigtriangledown;": 9661,
  "circlearrowleft;": 8634,
  "curvearrowright;": 8631,
  "downharpoonleft;": 8643,
  "leftharpoondown;": 8637,
  "leftrightarrows;": 8646,
  "nLeftrightarrow;": 8654,
  "nleftrightarrow;": 8622,
  "ntrianglelefteq;": 8940,
  "rightleftarrows;": 8644,
  "rightsquigarrow;": 8605,
  "rightthreetimes;": 8908,
  "straightepsilon;": 1013,
  "trianglerighteq;": 8885,
  "vartriangleleft;": 8882,
  "DiacriticalDot;": 729,
  "DoubleRightTee;": 8872,
  "DownLeftVector;": 8637,
  "GreaterGreater;": 10914,
  "HorizontalLine;": 9472,
  "InvisibleComma;": 8291,
  "InvisibleTimes;": 8290,
  "LeftDownVector;": 8643,
  "LeftRightArrow;": 8596,
  "Leftrightarrow;": 8660,
  "LessSlantEqual;": 10877,
  "LongRightArrow;": 10230,
  "Longrightarrow;": 10233,
  "LowerLeftArrow;": 8601,
  "NestedLessLess;": 8810,
  "NotGreaterLess;": 8825,
  "NotLessGreater;": 8824,
  "NotSubsetEqual;": 8840,
  "NotVerticalBar;": 8740,
  "OpenCurlyQuote;": 8216,
  "ReverseElement;": 8715,
  "RightTeeVector;": 10587,
  "RightVectorBar;": 10579,
  "ShortDownArrow;": 8595,
  "ShortLeftArrow;": 8592,
  "SquareSuperset;": 8848,
  "TildeFullEqual;": 8773,
  "UpperLeftArrow;": 8598,
  "ZeroWidthSpace;": 8203,
  "curvearrowleft;": 8630,
  "doublebarwedge;": 8966,
  "downdownarrows;": 8650,
  "hookrightarrow;": 8618,
  "leftleftarrows;": 8647,
  "leftrightarrow;": 8596,
  "leftthreetimes;": 8907,
  "longrightarrow;": 10230,
  "looparrowright;": 8620,
  "nshortparallel;": 8742,
  "ntriangleright;": 8939,
  "rightarrowtail;": 8611,
  "rightharpoonup;": 8640,
  "trianglelefteq;": 8884,
  "upharpoonright;": 8638,
  "ApplyFunction;": 8289,
  "DifferentialD;": 8518,
  "DoubleLeftTee;": 10980,
  "DoubleUpArrow;": 8657,
  "LeftTeeVector;": 10586,
  "LeftVectorBar;": 10578,
  "LessFullEqual;": 8806,
  "LongLeftArrow;": 10229,
  "Longleftarrow;": 10232,
  "NotEqualTilde;": 8770,
  "NotTildeEqual;": 8772,
  "NotTildeTilde;": 8777,
  "Poincareplane;": 8460,
  "PrecedesEqual;": 10927,
  "PrecedesTilde;": 8830,
  "RightArrowBar;": 8677,
  "RightTeeArrow;": 8614,
  "RightTriangle;": 8883,
  "RightUpVector;": 8638,
  "SucceedsEqual;": 10928,
  "SucceedsTilde;": 8831,
  "SupersetEqual;": 8839,
  "UpEquilibrium;": 10606,
  "VerticalTilde;": 8768,
  "VeryThinSpace;": 8202,
  "bigtriangleup;": 9651,
  "blacktriangle;": 9652,
  "divideontimes;": 8903,
  "fallingdotseq;": 8786,
  "hookleftarrow;": 8617,
  "leftarrowtail;": 8610,
  "leftharpoonup;": 8636,
  "longleftarrow;": 10229,
  "looparrowleft;": 8619,
  "measuredangle;": 8737,
  "ntriangleleft;": 8938,
  "shortparallel;": 8741,
  "smallsetminus;": 8726,
  "triangleright;": 9657,
  "upharpoonleft;": 8639,
  "varsubsetneqq;": 10955,
  "varsupsetneqq;": 10956,
  "DownArrowBar;": 10515,
  "DownTeeArrow;": 8615,
  "ExponentialE;": 8519,
  "GreaterEqual;": 8805,
  "GreaterTilde;": 8819,
  "HilbertSpace;": 8459,
  "HumpDownHump;": 8782,
  "Intersection;": 8898,
  "LeftArrowBar;": 8676,
  "LeftTeeArrow;": 8612,
  "LeftTriangle;": 8882,
  "LeftUpVector;": 8639,
  "NotCongruent;": 8802,
  "NotHumpEqual;": 8783,
  "NotLessEqual;": 8816,
  "NotLessTilde;": 8820,
  "Proportional;": 8733,
  "RightCeiling;": 8969,
  "RoundImplies;": 10608,
  "ShortUpArrow;": 8593,
  "SquareSubset;": 8847,
  "UnderBracket;": 9141,
  "VerticalLine;": 124,
  "blacklozenge;": 10731,
  "exponentiale;": 8519,
  "risingdotseq;": 8787,
  "triangledown;": 9663,
  "triangleleft;": 9667,
  "varsubsetneq;": 8842,
  "varsupsetneq;": 8843,
  "CircleMinus;": 8854,
  "CircleTimes;": 8855,
  "Equilibrium;": 8652,
  "GreaterLess;": 8823,
  "LeftCeiling;": 8968,
  "LessGreater;": 8822,
  "MediumSpace;": 8287,
  "NotLessLess;": 8810,
  "NotPrecedes;": 8832,
  "NotSucceeds;": 8833,
  "NotSuperset;": 8835,
  "OverBracket;": 9140,
  "RightVector;": 8640,
  "Rrightarrow;": 8667,
  "RuleDelayed;": 10740,
  "SmallCircle;": 8728,
  "SquareUnion;": 8852,
  "SubsetEqual;": 8838,
  "UpDownArrow;": 8597,
  "Updownarrow;": 8661,
  "VerticalBar;": 8739,
  "backepsilon;": 1014,
  "blacksquare;": 9642,
  "circledcirc;": 8858,
  "circleddash;": 8861,
  "curlyeqprec;": 8926,
  "curlyeqsucc;": 8927,
  "diamondsuit;": 9830,
  "eqslantless;": 10901,
  "expectation;": 8496,
  "nRightarrow;": 8655,
  "nrightarrow;": 8603,
  "preccurlyeq;": 8828,
  "precnapprox;": 10937,
  "quaternions;": 8461,
  "straightphi;": 981,
  "succcurlyeq;": 8829,
  "succnapprox;": 10938,
  "thickapprox;": 8776,
  "updownarrow;": 8597,
  "Bernoullis;": 8492,
  "CirclePlus;": 8853,
  "EqualTilde;": 8770,
  "Fouriertrf;": 8497,
  "ImaginaryI;": 8520,
  "Laplacetrf;": 8466,
  "LeftVector;": 8636,
  "Lleftarrow;": 8666,
  "NotElement;": 8713,
  "NotGreater;": 8815,
  "Proportion;": 8759,
  "RightArrow;": 8594,
  "RightFloor;": 8971,
  "Rightarrow;": 8658,
  "ThickSpace;": 8287,
  "TildeEqual;": 8771,
  "TildeTilde;": 8776,
  "UnderBrace;": 9183,
  "UpArrowBar;": 10514,
  "UpTeeArrow;": 8613,
  "circledast;": 8859,
  "complement;": 8705,
  "curlywedge;": 8911,
  "eqslantgtr;": 10902,
  "gtreqqless;": 10892,
  "lessapprox;": 10885,
  "lesseqqgtr;": 10891,
  "lmoustache;": 9136,
  "longmapsto;": 10236,
  "mapstodown;": 8615,
  "mapstoleft;": 8612,
  "nLeftarrow;": 8653,
  "nleftarrow;": 8602,
  "nsubseteqq;": 10949,
  "nsupseteqq;": 10950,
  "precapprox;": 10935,
  "rightarrow;": 8594,
  "rmoustache;": 9137,
  "sqsubseteq;": 8849,
  "sqsupseteq;": 8850,
  "subsetneqq;": 10955,
  "succapprox;": 10936,
  "supsetneqq;": 10956,
  "upuparrows;": 8648,
  "varepsilon;": 1013,
  "varnothing;": 8709,
  "Backslash;": 8726,
  "CenterDot;": 183,
  "CircleDot;": 8857,
  "Congruent;": 8801,
  "Coproduct;": 8720,
  "DoubleDot;": 168,
  "DownArrow;": 8595,
  "DownBreve;": 785,
  "Downarrow;": 8659,
  "HumpEqual;": 8783,
  "LeftArrow;": 8592,
  "LeftFloor;": 8970,
  "Leftarrow;": 8656,
  "LessTilde;": 8818,
  "Mellintrf;": 8499,
  "MinusPlus;": 8723,
  "NotCupCap;": 8813,
  "NotExists;": 8708,
  "NotSubset;": 8834,
  "OverBrace;": 9182,
  "PlusMinus;": 177,
  "Therefore;": 8756,
  "ThinSpace;": 8201,
  "TripleDot;": 8411,
  "UnionPlus;": 8846,
  "backprime;": 8245,
  "backsimeq;": 8909,
  "bigotimes;": 10754,
  "centerdot;": 183,
  "checkmark;": 10003,
  "complexes;": 8450,
  "dotsquare;": 8865,
  "downarrow;": 8595,
  "gtrapprox;": 10886,
  "gtreqless;": 8923,
  "gvertneqq;": 8809,
  "heartsuit;": 9829,
  "leftarrow;": 8592,
  "lesseqgtr;": 8922,
  "lvertneqq;": 8808,
  "ngeqslant;": 10878,
  "nleqslant;": 10877,
  "nparallel;": 8742,
  "nshortmid;": 8740,
  "nsubseteq;": 8840,
  "nsupseteq;": 8841,
  "pitchfork;": 8916,
  "rationals;": 8474,
  "spadesuit;": 9824,
  "subseteqq;": 10949,
  "subsetneq;": 8842,
  "supseteqq;": 10950,
  "supsetneq;": 8843,
  "therefore;": 8756,
  "triangleq;": 8796,
  "varpropto;": 8733,
  "DDotrahd;": 10513,
  "DotEqual;": 8784,
  "Integral;": 8747,
  "LessLess;": 10913,
  "NotEqual;": 8800,
  "NotTilde;": 8769,
  "PartialD;": 8706,
  "Precedes;": 8826,
  "RightTee;": 8866,
  "Succeeds;": 8827,
  "SuchThat;": 8715,
  "Superset;": 8835,
  "Uarrocir;": 10569,
  "UnderBar;": 95,
  "andslope;": 10840,
  "angmsdaa;": 10664,
  "angmsdab;": 10665,
  "angmsdac;": 10666,
  "angmsdad;": 10667,
  "angmsdae;": 10668,
  "angmsdaf;": 10669,
  "angmsdag;": 10670,
  "angmsdah;": 10671,
  "angrtvbd;": 10653,
  "approxeq;": 8778,
  "awconint;": 8755,
  "backcong;": 8780,
  "barwedge;": 8965,
  "bbrktbrk;": 9142,
  "bigoplus;": 10753,
  "bigsqcup;": 10758,
  "biguplus;": 10756,
  "bigwedge;": 8896,
  "boxminus;": 8863,
  "boxtimes;": 8864,
  "bsolhsub;": 10184,
  "capbrcup;": 10825,
  "circledR;": 174,
  "circledS;": 9416,
  "cirfnint;": 10768,
  "clubsuit;": 9827,
  "cupbrcap;": 10824,
  "curlyvee;": 8910,
  "cwconint;": 8754,
  "doteqdot;": 8785,
  "dotminus;": 8760,
  "drbkarow;": 10512,
  "dzigrarr;": 10239,
  "elinters;": 9191,
  "emptyset;": 8709,
  "eqvparsl;": 10725,
  "fpartint;": 10765,
  "geqslant;": 10878,
  "gesdotol;": 10884,
  "gnapprox;": 10890,
  "hksearow;": 10533,
  "hkswarow;": 10534,
  "imagline;": 8464,
  "imagpart;": 8465,
  "infintie;": 10717,
  "integers;": 8484,
  "intercal;": 8890,
  "intlarhk;": 10775,
  "laemptyv;": 10676,
  "ldrushar;": 10571,
  "leqslant;": 10877,
  "lesdotor;": 10883,
  "llcorner;": 8990,
  "lnapprox;": 10889,
  "lrcorner;": 8991,
  "lurdshar;": 10570,
  "mapstoup;": 8613,
  "multimap;": 8888,
  "naturals;": 8469,
  "ncongdot;": 10861,
  "notindot;": 8949,
  "otimesas;": 10806,
  "parallel;": 8741,
  "plusacir;": 10787,
  "pointint;": 10773,
  "precneqq;": 10933,
  "precnsim;": 8936,
  "profalar;": 9006,
  "profline;": 8978,
  "profsurf;": 8979,
  "raemptyv;": 10675,
  "realpart;": 8476,
  "rppolint;": 10770,
  "rtriltri;": 10702,
  "scpolint;": 10771,
  "setminus;": 8726,
  "shortmid;": 8739,
  "smeparsl;": 10724,
  "sqsubset;": 8847,
  "sqsupset;": 8848,
  "subseteq;": 8838,
  "succneqq;": 10934,
  "succnsim;": 8937,
  "supseteq;": 8839,
  "thetasym;": 977,
  "thicksim;": 8764,
  "timesbar;": 10801,
  "triangle;": 9653,
  "triminus;": 10810,
  "trpezium;": 9186,
  "ulcorner;": 8988,
  "urcorner;": 8989,
  "varkappa;": 1008,
  "varsigma;": 962,
  "vartheta;": 977,
  "Because;": 8757,
  "Cayleys;": 8493,
  "Cconint;": 8752,
  "Cedilla;": 184,
  "Diamond;": 8900,
  "DownTee;": 8868,
  "Element;": 8712,
  "Epsilon;": 917,
  "Implies;": 8658,
  "LeftTee;": 8867,
  "NewLine;": 10,
  "NoBreak;": 8288,
  "NotLess;": 8814,
  "Omicron;": 927,
  "OverBar;": 8254,
  "Product;": 8719,
  "UpArrow;": 8593,
  "Uparrow;": 8657,
  "Upsilon;": 933,
  "alefsym;": 8501,
  "angrtvb;": 8894,
  "angzarr;": 9084,
  "asympeq;": 8781,
  "backsim;": 8765,
  "because;": 8757,
  "bemptyv;": 10672,
  "between;": 8812,
  "bigcirc;": 9711,
  "bigodot;": 10752,
  "bigstar;": 9733,
  "bnequiv;": 8801,
  "boxplus;": 8862,
  "ccupssm;": 10832,
  "cemptyv;": 10674,
  "cirscir;": 10690,
  "coloneq;": 8788,
  "congdot;": 10861,
  "cudarrl;": 10552,
  "cudarrr;": 10549,
  "cularrp;": 10557,
  "curarrm;": 10556,
  "dbkarow;": 10511,
  "ddagger;": 8225,
  "ddotseq;": 10871,
  "demptyv;": 10673,
  "diamond;": 8900,
  "digamma;": 989,
  "dotplus;": 8724,
  "dwangle;": 10662,
  "epsilon;": 949,
  "eqcolon;": 8789,
  "equivDD;": 10872,
  "gesdoto;": 10882,
  "gtquest;": 10876,
  "gtrless;": 8823,
  "harrcir;": 10568,
  "intprod;": 10812,
  "isindot;": 8949,
  "larrbfs;": 10527,
  "larrsim;": 10611,
  "lbrksld;": 10639,
  "lbrkslu;": 10637,
  "ldrdhar;": 10599,
  "lesdoto;": 10881,
  "lessdot;": 8918,
  "lessgtr;": 8822,
  "lesssim;": 8818,
  "lotimes;": 10804,
  "lozenge;": 9674,
  "ltquest;": 10875,
  "luruhar;": 10598,
  "maltese;": 10016,
  "minusdu;": 10794,
  "napprox;": 8777,
  "natural;": 9838,
  "nearrow;": 8599,
  "nexists;": 8708,
  "notinva;": 8713,
  "notinvb;": 8951,
  "notinvc;": 8950,
  "notniva;": 8716,
  "notnivb;": 8958,
  "notnivc;": 8957,
  "npolint;": 10772,
  "npreceq;": 10927,
  "nsqsube;": 8930,
  "nsqsupe;": 8931,
  "nsubset;": 8834,
  "nsucceq;": 10928,
  "nsupset;": 8835,
  "nvinfin;": 10718,
  "nvltrie;": 8884,
  "nvrtrie;": 8885,
  "nwarrow;": 8598,
  "olcross;": 10683,
  "omicron;": 959,
  "orderof;": 8500,
  "orslope;": 10839,
  "pertenk;": 8241,
  "planckh;": 8462,
  "pluscir;": 10786,
  "plussim;": 10790,
  "plustwo;": 10791,
  "precsim;": 8830,
  "quatint;": 10774,
  "questeq;": 8799,
  "rarrbfs;": 10528,
  "rarrsim;": 10612,
  "rbrksld;": 10638,
  "rbrkslu;": 10640,
  "rdldhar;": 10601,
  "realine;": 8475,
  "rotimes;": 10805,
  "ruluhar;": 10600,
  "searrow;": 8600,
  "simplus;": 10788,
  "simrarr;": 10610,
  "subedot;": 10947,
  "submult;": 10945,
  "subplus;": 10943,
  "subrarr;": 10617,
  "succsim;": 8831,
  "supdsub;": 10968,
  "supedot;": 10948,
  "suphsol;": 10185,
  "suphsub;": 10967,
  "suplarr;": 10619,
  "supmult;": 10946,
  "supplus;": 10944,
  "swarrow;": 8601,
  "topfork;": 10970,
  "triplus;": 10809,
  "tritime;": 10811,
  "uparrow;": 8593,
  "upsilon;": 965,
  "uwangle;": 10663,
  "vzigzag;": 10650,
  "zigrarr;": 8669,
  "Aacute;": 193,
  "Abreve;": 258,
  "Agrave;": 192,
  "Assign;": 8788,
  "Atilde;": 195,
  "Barwed;": 8966,
  "Bumpeq;": 8782,
  "Cacute;": 262,
  "Ccaron;": 268,
  "Ccedil;": 199,
  "Colone;": 10868,
  "Conint;": 8751,
  "CupCap;": 8781,
  "Dagger;": 8225,
  "Dcaron;": 270,
  "DotDot;": 8412,
  "Dstrok;": 272,
  "Eacute;": 201,
  "Ecaron;": 282,
  "Egrave;": 200,
  "Exists;": 8707,
  "ForAll;": 8704,
  "Gammad;": 988,
  "Gbreve;": 286,
  "Gcedil;": 290,
  "HARDcy;": 1066,
  "Hstrok;": 294,
  "Iacute;": 205,
  "Igrave;": 204,
  "Itilde;": 296,
  "Jsercy;": 1032,
  "Kcedil;": 310,
  "Lacute;": 313,
  "Lambda;": 923,
  "Lcaron;": 317,
  "Lcedil;": 315,
  "Lmidot;": 319,
  "Lstrok;": 321,
  "Nacute;": 323,
  "Ncaron;": 327,
  "Ncedil;": 325,
  "Ntilde;": 209,
  "Oacute;": 211,
  "Odblac;": 336,
  "Ograve;": 210,
  "Oslash;": 216,
  "Otilde;": 213,
  "Otimes;": 10807,
  "Racute;": 340,
  "Rarrtl;": 10518,
  "Rcaron;": 344,
  "Rcedil;": 342,
  "SHCHcy;": 1065,
  "SOFTcy;": 1068,
  "Sacute;": 346,
  "Scaron;": 352,
  "Scedil;": 350,
  "Square;": 9633,
  "Subset;": 8912,
  "Supset;": 8913,
  "Tcaron;": 356,
  "Tcedil;": 354,
  "Tstrok;": 358,
  "Uacute;": 218,
  "Ubreve;": 364,
  "Udblac;": 368,
  "Ugrave;": 217,
  "Utilde;": 360,
  "Vdashl;": 10982,
  "Verbar;": 8214,
  "Vvdash;": 8874,
  "Yacute;": 221,
  "Zacute;": 377,
  "Zcaron;": 381,
  "aacute;": 225,
  "abreve;": 259,
  "agrave;": 224,
  "andand;": 10837,
  "angmsd;": 8737,
  "angsph;": 8738,
  "apacir;": 10863,
  "approx;": 8776,
  "atilde;": 227,
  "barvee;": 8893,
  "barwed;": 8965,
  "becaus;": 8757,
  "bernou;": 8492,
  "bigcap;": 8898,
  "bigcup;": 8899,
  "bigvee;": 8897,
  "bkarow;": 10509,
  "bottom;": 8869,
  "bowtie;": 8904,
  "boxbox;": 10697,
  "bprime;": 8245,
  "brvbar;": 166,
  "bullet;": 8226,
  "bumpeq;": 8783,
  "cacute;": 263,
  "capand;": 10820,
  "capcap;": 10827,
  "capcup;": 10823,
  "capdot;": 10816,
  "ccaron;": 269,
  "ccedil;": 231,
  "circeq;": 8791,
  "cirmid;": 10991,
  "colone;": 8788,
  "commat;": 64,
  "compfn;": 8728,
  "conint;": 8750,
  "coprod;": 8720,
  "copysr;": 8471,
  "cularr;": 8630,
  "cupcap;": 10822,
  "cupcup;": 10826,
  "cupdot;": 8845,
  "curarr;": 8631,
  "curren;": 164,
  "cylcty;": 9005,
  "dagger;": 8224,
  "daleth;": 8504,
  "dcaron;": 271,
  "dfisht;": 10623,
  "divide;": 247,
  "divonx;": 8903,
  "dlcorn;": 8990,
  "dlcrop;": 8973,
  "dollar;": 36,
  "drcorn;": 8991,
  "drcrop;": 8972,
  "dstrok;": 273,
  "eacute;": 233,
  "easter;": 10862,
  "ecaron;": 283,
  "ecolon;": 8789,
  "egrave;": 232,
  "egsdot;": 10904,
  "elsdot;": 10903,
  "emptyv;": 8709,
  "emsp13;": 8196,
  "emsp14;": 8197,
  "eparsl;": 10723,
  "eqcirc;": 8790,
  "equals;": 61,
  "equest;": 8799,
  "female;": 9792,
  "ffilig;": 64259,
  "ffllig;": 64260,
  "forall;": 8704,
  "frac12;": 189,
  "frac13;": 8531,
  "frac14;": 188,
  "frac15;": 8533,
  "frac16;": 8537,
  "frac18;": 8539,
  "frac23;": 8532,
  "frac25;": 8534,
  "frac34;": 190,
  "frac35;": 8535,
  "frac38;": 8540,
  "frac45;": 8536,
  "frac56;": 8538,
  "frac58;": 8541,
  "frac78;": 8542,
  "gacute;": 501,
  "gammad;": 989,
  "gbreve;": 287,
  "gesdot;": 10880,
  "gesles;": 10900,
  "gtlPar;": 10645,
  "gtrarr;": 10616,
  "gtrdot;": 8919,
  "gtrsim;": 8819,
  "hairsp;": 8202,
  "hamilt;": 8459,
  "hardcy;": 1098,
  "hearts;": 9829,
  "hellip;": 8230,
  "hercon;": 8889,
  "homtht;": 8763,
  "horbar;": 8213,
  "hslash;": 8463,
  "hstrok;": 295,
  "hybull;": 8259,
  "hyphen;": 8208,
  "iacute;": 237,
  "igrave;": 236,
  "iiiint;": 10764,
  "iinfin;": 10716,
  "incare;": 8453,
  "inodot;": 305,
  "intcal;": 8890,
  "iquest;": 191,
  "isinsv;": 8947,
  "itilde;": 297,
  "jsercy;": 1112,
  "kappav;": 1008,
  "kcedil;": 311,
  "kgreen;": 312,
  "lAtail;": 10523,
  "lacute;": 314,
  "lagran;": 8466,
  "lambda;": 955,
  "langle;": 10216,
  "larrfs;": 10525,
  "larrhk;": 8617,
  "larrlp;": 8619,
  "larrpl;": 10553,
  "larrtl;": 8610,
  "latail;": 10521,
  "lbrace;": 123,
  "lbrack;": 91,
  "lcaron;": 318,
  "lcedil;": 316,
  "ldquor;": 8222,
  "lesdot;": 10879,
  "lesges;": 10899,
  "lfisht;": 10620,
  "lfloor;": 8970,
  "lharul;": 10602,
  "llhard;": 10603,
  "lmidot;": 320,
  "lmoust;": 9136,
  "loplus;": 10797,
  "lowast;": 8727,
  "lowbar;": 95,
  "lparlt;": 10643,
  "lrhard;": 10605,
  "lsaquo;": 8249,
  "lsquor;": 8218,
  "lstrok;": 322,
  "lthree;": 8907,
  "ltimes;": 8905,
  "ltlarr;": 10614,
  "ltrPar;": 10646,
  "mapsto;": 8614,
  "marker;": 9646,
  "mcomma;": 10793,
  "midast;": 42,
  "midcir;": 10992,
  "middot;": 183,
  "minusb;": 8863,
  "minusd;": 8760,
  "mnplus;": 8723,
  "models;": 8871,
  "mstpos;": 8766,
  "nVDash;": 8879,
  "nVdash;": 8878,
  "nacute;": 324,
  "nbumpe;": 8783,
  "ncaron;": 328,
  "ncedil;": 326,
  "nearhk;": 10532,
  "nequiv;": 8802,
  "nesear;": 10536,
  "nexist;": 8708,
  "nltrie;": 8940,
  "notinE;": 8953,
  "nparsl;": 11005,
  "nprcue;": 8928,
  "nrarrc;": 10547,
  "nrarrw;": 8605,
  "nrtrie;": 8941,
  "nsccue;": 8929,
  "nsimeq;": 8772,
  "ntilde;": 241,
  "numero;": 8470,
  "nvDash;": 8877,
  "nvHarr;": 10500,
  "nvdash;": 8876,
  "nvlArr;": 10498,
  "nvrArr;": 10499,
  "nwarhk;": 10531,
  "nwnear;": 10535,
  "oacute;": 243,
  "odblac;": 337,
  "odsold;": 10684,
  "ograve;": 242,
  "ominus;": 8854,
  "origof;": 8886,
  "oslash;": 248,
  "otilde;": 245,
  "otimes;": 8855,
  "parsim;": 10995,
  "percnt;": 37,
  "period;": 46,
  "permil;": 8240,
  "phmmat;": 8499,
  "planck;": 8463,
  "plankv;": 8463,
  "plusdo;": 8724,
  "plusdu;": 10789,
  "plusmn;": 177,
  "preceq;": 10927,
  "primes;": 8473,
  "prnsim;": 8936,
  "propto;": 8733,
  "prurel;": 8880,
  "puncsp;": 8200,
  "qprime;": 8279,
  "rAtail;": 10524,
  "racute;": 341,
  "rangle;": 10217,
  "rarrap;": 10613,
  "rarrfs;": 10526,
  "rarrhk;": 8618,
  "rarrlp;": 8620,
  "rarrpl;": 10565,
  "rarrtl;": 8611,
  "ratail;": 10522,
  "rbrace;": 125,
  "rbrack;": 93,
  "rcaron;": 345,
  "rcedil;": 343,
  "rdquor;": 8221,
  "rfisht;": 10621,
  "rfloor;": 8971,
  "rharul;": 10604,
  "rmoust;": 9137,
  "roplus;": 10798,
  "rpargt;": 10644,
  "rsaquo;": 8250,
  "rsquor;": 8217,
  "rthree;": 8908,
  "rtimes;": 8906,
  "sacute;": 347,
  "scaron;": 353,
  "scedil;": 351,
  "scnsim;": 8937,
  "searhk;": 10533,
  "seswar;": 10537,
  "sfrown;": 8994,
  "shchcy;": 1097,
  "sigmaf;": 962,
  "sigmav;": 962,
  "simdot;": 10858,
  "smashp;": 10803,
  "softcy;": 1100,
  "solbar;": 9023,
  "spades;": 9824,
  "sqcaps;": 8851,
  "sqcups;": 8852,
  "sqsube;": 8849,
  "sqsupe;": 8850,
  "square;": 9633,
  "squarf;": 9642,
  "ssetmn;": 8726,
  "ssmile;": 8995,
  "sstarf;": 8902,
  "subdot;": 10941,
  "subset;": 8834,
  "subsim;": 10951,
  "subsub;": 10965,
  "subsup;": 10963,
  "succeq;": 10928,
  "supdot;": 10942,
  "supset;": 8835,
  "supsim;": 10952,
  "supsub;": 10964,
  "supsup;": 10966,
  "swarhk;": 10534,
  "swnwar;": 10538,
  "target;": 8982,
  "tcaron;": 357,
  "tcedil;": 355,
  "telrec;": 8981,
  "there4;": 8756,
  "thetav;": 977,
  "thinsp;": 8201,
  "thksim;": 8764,
  "timesb;": 8864,
  "timesd;": 10800,
  "topbot;": 9014,
  "topcir;": 10993,
  "tprime;": 8244,
  "tridot;": 9708,
  "tstrok;": 359,
  "uacute;": 250,
  "ubreve;": 365,
  "udblac;": 369,
  "ufisht;": 10622,
  "ugrave;": 249,
  "ulcorn;": 8988,
  "ulcrop;": 8975,
  "urcorn;": 8989,
  "urcrop;": 8974,
  "utilde;": 361,
  "vangrt;": 10652,
  "varphi;": 981,
  "varrho;": 1009,
  "veebar;": 8891,
  "vellip;": 8942,
  "verbar;": 124,
  "vsubnE;": 10955,
  "vsubne;": 8842,
  "vsupnE;": 10956,
  "vsupne;": 8843,
  "wedbar;": 10847,
  "wedgeq;": 8793,
  "weierp;": 8472,
  "wreath;": 8768,
  "xoplus;": 10753,
  "xotime;": 10754,
  "xsqcup;": 10758,
  "xuplus;": 10756,
  "xwedge;": 8896,
  "yacute;": 253,
  "zacute;": 378,
  "zcaron;": 382,
  "zeetrf;": 8488,
  "AElig;": 198,
  Aacute: 193,
  "Acirc;": 194,
  Agrave: 192,
  "Alpha;": 913,
  "Amacr;": 256,
  "Aogon;": 260,
  "Aring;": 197,
  Atilde: 195,
  "Breve;": 728,
  Ccedil: 199,
  "Ccirc;": 264,
  "Colon;": 8759,
  "Cross;": 10799,
  "Dashv;": 10980,
  "Delta;": 916,
  Eacute: 201,
  "Ecirc;": 202,
  Egrave: 200,
  "Emacr;": 274,
  "Eogon;": 280,
  "Equal;": 10869,
  "Gamma;": 915,
  "Gcirc;": 284,
  "Hacek;": 711,
  "Hcirc;": 292,
  "IJlig;": 306,
  Iacute: 205,
  "Icirc;": 206,
  Igrave: 204,
  "Imacr;": 298,
  "Iogon;": 302,
  "Iukcy;": 1030,
  "Jcirc;": 308,
  "Jukcy;": 1028,
  "Kappa;": 922,
  Ntilde: 209,
  "OElig;": 338,
  Oacute: 211,
  "Ocirc;": 212,
  Ograve: 210,
  "Omacr;": 332,
  "Omega;": 937,
  Oslash: 216,
  Otilde: 213,
  "Prime;": 8243,
  "RBarr;": 10512,
  "Scirc;": 348,
  "Sigma;": 931,
  "THORN;": 222,
  "TRADE;": 8482,
  "TSHcy;": 1035,
  "Theta;": 920,
  "Tilde;": 8764,
  Uacute: 218,
  "Ubrcy;": 1038,
  "Ucirc;": 219,
  Ugrave: 217,
  "Umacr;": 362,
  "Union;": 8899,
  "Uogon;": 370,
  "UpTee;": 8869,
  "Uring;": 366,
  "VDash;": 8875,
  "Vdash;": 8873,
  "Wcirc;": 372,
  "Wedge;": 8896,
  Yacute: 221,
  "Ycirc;": 374,
  aacute: 225,
  "acirc;": 226,
  "acute;": 180,
  "aelig;": 230,
  agrave: 224,
  "aleph;": 8501,
  "alpha;": 945,
  "amacr;": 257,
  "amalg;": 10815,
  "angle;": 8736,
  "angrt;": 8735,
  "angst;": 197,
  "aogon;": 261,
  "aring;": 229,
  "asymp;": 8776,
  atilde: 227,
  "awint;": 10769,
  "bcong;": 8780,
  "bdquo;": 8222,
  "bepsi;": 1014,
  "blank;": 9251,
  "blk12;": 9618,
  "blk14;": 9617,
  "blk34;": 9619,
  "block;": 9608,
  "boxDL;": 9559,
  "boxDR;": 9556,
  "boxDl;": 9558,
  "boxDr;": 9555,
  "boxHD;": 9574,
  "boxHU;": 9577,
  "boxHd;": 9572,
  "boxHu;": 9575,
  "boxUL;": 9565,
  "boxUR;": 9562,
  "boxUl;": 9564,
  "boxUr;": 9561,
  "boxVH;": 9580,
  "boxVL;": 9571,
  "boxVR;": 9568,
  "boxVh;": 9579,
  "boxVl;": 9570,
  "boxVr;": 9567,
  "boxdL;": 9557,
  "boxdR;": 9554,
  "boxdl;": 9488,
  "boxdr;": 9484,
  "boxhD;": 9573,
  "boxhU;": 9576,
  "boxhd;": 9516,
  "boxhu;": 9524,
  "boxuL;": 9563,
  "boxuR;": 9560,
  "boxul;": 9496,
  "boxur;": 9492,
  "boxvH;": 9578,
  "boxvL;": 9569,
  "boxvR;": 9566,
  "boxvh;": 9532,
  "boxvl;": 9508,
  "boxvr;": 9500,
  "breve;": 728,
  brvbar: 166,
  "bsemi;": 8271,
  "bsime;": 8909,
  "bsolb;": 10693,
  "bumpE;": 10926,
  "bumpe;": 8783,
  "caret;": 8257,
  "caron;": 711,
  "ccaps;": 10829,
  ccedil: 231,
  "ccirc;": 265,
  "ccups;": 10828,
  "cedil;": 184,
  "check;": 10003,
  "clubs;": 9827,
  "colon;": 58,
  "comma;": 44,
  "crarr;": 8629,
  "cross;": 10007,
  "csube;": 10961,
  "csupe;": 10962,
  "ctdot;": 8943,
  "cuepr;": 8926,
  "cuesc;": 8927,
  "cupor;": 10821,
  curren: 164,
  "cuvee;": 8910,
  "cuwed;": 8911,
  "cwint;": 8753,
  "dashv;": 8867,
  "dblac;": 733,
  "ddarr;": 8650,
  "delta;": 948,
  "dharl;": 8643,
  "dharr;": 8642,
  "diams;": 9830,
  "disin;": 8946,
  divide: 247,
  "doteq;": 8784,
  "dtdot;": 8945,
  "dtrif;": 9662,
  "duarr;": 8693,
  "duhar;": 10607,
  "eDDot;": 10871,
  eacute: 233,
  "ecirc;": 234,
  "efDot;": 8786,
  egrave: 232,
  "emacr;": 275,
  "empty;": 8709,
  "eogon;": 281,
  "eplus;": 10865,
  "epsiv;": 1013,
  "eqsim;": 8770,
  "equiv;": 8801,
  "erDot;": 8787,
  "erarr;": 10609,
  "esdot;": 8784,
  "exist;": 8707,
  "fflig;": 64256,
  "filig;": 64257,
  "fjlig;": 102,
  "fllig;": 64258,
  "fltns;": 9649,
  "forkv;": 10969,
  frac12: 189,
  frac14: 188,
  frac34: 190,
  "frasl;": 8260,
  "frown;": 8994,
  "gamma;": 947,
  "gcirc;": 285,
  "gescc;": 10921,
  "gimel;": 8503,
  "gneqq;": 8809,
  "gnsim;": 8935,
  "grave;": 96,
  "gsime;": 10894,
  "gsiml;": 10896,
  "gtcir;": 10874,
  "gtdot;": 8919,
  "harrw;": 8621,
  "hcirc;": 293,
  "hoarr;": 8703,
  iacute: 237,
  "icirc;": 238,
  "iexcl;": 161,
  igrave: 236,
  "iiint;": 8749,
  "iiota;": 8489,
  "ijlig;": 307,
  "imacr;": 299,
  "image;": 8465,
  "imath;": 305,
  "imped;": 437,
  "infin;": 8734,
  "iogon;": 303,
  "iprod;": 10812,
  iquest: 191,
  "isinE;": 8953,
  "isins;": 8948,
  "isinv;": 8712,
  "iukcy;": 1110,
  "jcirc;": 309,
  "jmath;": 567,
  "jukcy;": 1108,
  "kappa;": 954,
  "lAarr;": 8666,
  "lBarr;": 10510,
  "langd;": 10641,
  "laquo;": 171,
  "larrb;": 8676,
  "lates;": 10925,
  "lbarr;": 10508,
  "lbbrk;": 10098,
  "lbrke;": 10635,
  "lceil;": 8968,
  "ldquo;": 8220,
  "lescc;": 10920,
  "lhard;": 8637,
  "lharu;": 8636,
  "lhblk;": 9604,
  "llarr;": 8647,
  "lltri;": 9722,
  "lneqq;": 8808,
  "lnsim;": 8934,
  "loang;": 10220,
  "loarr;": 8701,
  "lobrk;": 10214,
  "lopar;": 10629,
  "lrarr;": 8646,
  "lrhar;": 8651,
  "lrtri;": 8895,
  "lsime;": 10893,
  "lsimg;": 10895,
  "lsquo;": 8216,
  "ltcir;": 10873,
  "ltdot;": 8918,
  "ltrie;": 8884,
  "ltrif;": 9666,
  "mDDot;": 8762,
  "mdash;": 8212,
  "micro;": 181,
  middot: 183,
  "minus;": 8722,
  "mumap;": 8888,
  "nabla;": 8711,
  "napid;": 8779,
  "napos;": 329,
  "natur;": 9838,
  "nbump;": 8782,
  "ncong;": 8775,
  "ndash;": 8211,
  "neArr;": 8663,
  "nearr;": 8599,
  "nedot;": 8784,
  "nesim;": 8770,
  "ngeqq;": 8807,
  "ngsim;": 8821,
  "nhArr;": 8654,
  "nharr;": 8622,
  "nhpar;": 10994,
  "nlArr;": 8653,
  "nlarr;": 8602,
  "nleqq;": 8806,
  "nless;": 8814,
  "nlsim;": 8820,
  "nltri;": 8938,
  "notin;": 8713,
  "notni;": 8716,
  "npart;": 8706,
  "nprec;": 8832,
  "nrArr;": 8655,
  "nrarr;": 8603,
  "nrtri;": 8939,
  "nsime;": 8772,
  "nsmid;": 8740,
  "nspar;": 8742,
  "nsubE;": 10949,
  "nsube;": 8840,
  "nsucc;": 8833,
  "nsupE;": 10950,
  "nsupe;": 8841,
  ntilde: 241,
  "numsp;": 8199,
  "nvsim;": 8764,
  "nwArr;": 8662,
  "nwarr;": 8598,
  oacute: 243,
  "ocirc;": 244,
  "odash;": 8861,
  "oelig;": 339,
  "ofcir;": 10687,
  ograve: 242,
  "ohbar;": 10677,
  "olarr;": 8634,
  "olcir;": 10686,
  "oline;": 8254,
  "omacr;": 333,
  "omega;": 969,
  "operp;": 10681,
  "oplus;": 8853,
  "orarr;": 8635,
  "order;": 8500,
  oslash: 248,
  otilde: 245,
  "ovbar;": 9021,
  "parsl;": 11005,
  "phone;": 9742,
  "plusb;": 8862,
  "pluse;": 10866,
  plusmn: 177,
  "pound;": 163,
  "prcue;": 8828,
  "prime;": 8242,
  "prnap;": 10937,
  "prsim;": 8830,
  "quest;": 63,
  "rAarr;": 8667,
  "rBarr;": 10511,
  "radic;": 8730,
  "rangd;": 10642,
  "range;": 10661,
  "raquo;": 187,
  "rarrb;": 8677,
  "rarrc;": 10547,
  "rarrw;": 8605,
  "ratio;": 8758,
  "rbarr;": 10509,
  "rbbrk;": 10099,
  "rbrke;": 10636,
  "rceil;": 8969,
  "rdquo;": 8221,
  "reals;": 8477,
  "rhard;": 8641,
  "rharu;": 8640,
  "rlarr;": 8644,
  "rlhar;": 8652,
  "rnmid;": 10990,
  "roang;": 10221,
  "roarr;": 8702,
  "robrk;": 10215,
  "ropar;": 10630,
  "rrarr;": 8649,
  "rsquo;": 8217,
  "rtrie;": 8885,
  "rtrif;": 9656,
  "sbquo;": 8218,
  "sccue;": 8829,
  "scirc;": 349,
  "scnap;": 10938,
  "scsim;": 8831,
  "sdotb;": 8865,
  "sdote;": 10854,
  "seArr;": 8664,
  "searr;": 8600,
  "setmn;": 8726,
  "sharp;": 9839,
  "sigma;": 963,
  "simeq;": 8771,
  "simgE;": 10912,
  "simlE;": 10911,
  "simne;": 8774,
  "slarr;": 8592,
  "smile;": 8995,
  "smtes;": 10924,
  "sqcap;": 8851,
  "sqcup;": 8852,
  "sqsub;": 8847,
  "sqsup;": 8848,
  "srarr;": 8594,
  "starf;": 9733,
  "strns;": 175,
  "subnE;": 10955,
  "subne;": 8842,
  "supnE;": 10956,
  "supne;": 8843,
  "swArr;": 8665,
  "swarr;": 8601,
  "szlig;": 223,
  "theta;": 952,
  "thkap;": 8776,
  "thorn;": 254,
  "tilde;": 732,
  "times;": 215,
  "trade;": 8482,
  "trisb;": 10701,
  "tshcy;": 1115,
  "twixt;": 8812,
  uacute: 250,
  "ubrcy;": 1118,
  "ucirc;": 251,
  "udarr;": 8645,
  "udhar;": 10606,
  ugrave: 249,
  "uharl;": 8639,
  "uharr;": 8638,
  "uhblk;": 9600,
  "ultri;": 9720,
  "umacr;": 363,
  "uogon;": 371,
  "uplus;": 8846,
  "upsih;": 978,
  "uring;": 367,
  "urtri;": 9721,
  "utdot;": 8944,
  "utrif;": 9652,
  "uuarr;": 8648,
  "vBarv;": 10985,
  "vDash;": 8872,
  "varpi;": 982,
  "vdash;": 8866,
  "veeeq;": 8794,
  "vltri;": 8882,
  "vnsub;": 8834,
  "vnsup;": 8835,
  "vprop;": 8733,
  "vrtri;": 8883,
  "wcirc;": 373,
  "wedge;": 8743,
  "xcirc;": 9711,
  "xdtri;": 9661,
  "xhArr;": 10234,
  "xharr;": 10231,
  "xlArr;": 10232,
  "xlarr;": 10229,
  "xodot;": 10752,
  "xrArr;": 10233,
  "xrarr;": 10230,
  "xutri;": 9651,
  yacute: 253,
  "ycirc;": 375,
  AElig: 198,
  Acirc: 194,
  "Aopf;": 120120,
  Aring: 197,
  "Ascr;": 119964,
  "Auml;": 196,
  "Barv;": 10983,
  "Beta;": 914,
  "Bopf;": 120121,
  "Bscr;": 8492,
  "CHcy;": 1063,
  "COPY;": 169,
  "Cdot;": 266,
  "Copf;": 8450,
  "Cscr;": 119966,
  "DJcy;": 1026,
  "DScy;": 1029,
  "DZcy;": 1039,
  "Darr;": 8609,
  "Dopf;": 120123,
  "Dscr;": 119967,
  Ecirc: 202,
  "Edot;": 278,
  "Eopf;": 120124,
  "Escr;": 8496,
  "Esim;": 10867,
  "Euml;": 203,
  "Fopf;": 120125,
  "Fscr;": 8497,
  "GJcy;": 1027,
  "Gdot;": 288,
  "Gopf;": 120126,
  "Gscr;": 119970,
  "Hopf;": 8461,
  "Hscr;": 8459,
  "IEcy;": 1045,
  "IOcy;": 1025,
  Icirc: 206,
  "Idot;": 304,
  "Iopf;": 120128,
  "Iota;": 921,
  "Iscr;": 8464,
  "Iuml;": 207,
  "Jopf;": 120129,
  "Jscr;": 119973,
  "KHcy;": 1061,
  "KJcy;": 1036,
  "Kopf;": 120130,
  "Kscr;": 119974,
  "LJcy;": 1033,
  "Lang;": 10218,
  "Larr;": 8606,
  "Lopf;": 120131,
  "Lscr;": 8466,
  "Mopf;": 120132,
  "Mscr;": 8499,
  "NJcy;": 1034,
  "Nopf;": 8469,
  "Nscr;": 119977,
  Ocirc: 212,
  "Oopf;": 120134,
  "Oscr;": 119978,
  "Ouml;": 214,
  "Popf;": 8473,
  "Pscr;": 119979,
  "QUOT;": 34,
  "Qopf;": 8474,
  "Qscr;": 119980,
  "Rang;": 10219,
  "Rarr;": 8608,
  "Ropf;": 8477,
  "Rscr;": 8475,
  "SHcy;": 1064,
  "Sopf;": 120138,
  "Sqrt;": 8730,
  "Sscr;": 119982,
  "Star;": 8902,
  THORN: 222,
  "TScy;": 1062,
  "Topf;": 120139,
  "Tscr;": 119983,
  "Uarr;": 8607,
  Ucirc: 219,
  "Uopf;": 120140,
  "Upsi;": 978,
  "Uscr;": 119984,
  "Uuml;": 220,
  "Vbar;": 10987,
  "Vert;": 8214,
  "Vopf;": 120141,
  "Vscr;": 119985,
  "Wopf;": 120142,
  "Wscr;": 119986,
  "Xopf;": 120143,
  "Xscr;": 119987,
  "YAcy;": 1071,
  "YIcy;": 1031,
  "YUcy;": 1070,
  "Yopf;": 120144,
  "Yscr;": 119988,
  "Yuml;": 376,
  "ZHcy;": 1046,
  "Zdot;": 379,
  "Zeta;": 918,
  "Zopf;": 8484,
  "Zscr;": 119989,
  acirc: 226,
  acute: 180,
  aelig: 230,
  "andd;": 10844,
  "andv;": 10842,
  "ange;": 10660,
  "aopf;": 120146,
  "apid;": 8779,
  "apos;": 39,
  aring: 229,
  "ascr;": 119990,
  "auml;": 228,
  "bNot;": 10989,
  "bbrk;": 9141,
  "beta;": 946,
  "beth;": 8502,
  "bnot;": 8976,
  "bopf;": 120147,
  "boxH;": 9552,
  "boxV;": 9553,
  "boxh;": 9472,
  "boxv;": 9474,
  "bscr;": 119991,
  "bsim;": 8765,
  "bsol;": 92,
  "bull;": 8226,
  "bump;": 8782,
  "caps;": 8745,
  "cdot;": 267,
  cedil: 184,
  "cent;": 162,
  "chcy;": 1095,
  "cirE;": 10691,
  "circ;": 710,
  "cire;": 8791,
  "comp;": 8705,
  "cong;": 8773,
  "copf;": 120148,
  "copy;": 169,
  "cscr;": 119992,
  "csub;": 10959,
  "csup;": 10960,
  "cups;": 8746,
  "dArr;": 8659,
  "dHar;": 10597,
  "darr;": 8595,
  "dash;": 8208,
  "diam;": 8900,
  "djcy;": 1106,
  "dopf;": 120149,
  "dscr;": 119993,
  "dscy;": 1109,
  "dsol;": 10742,
  "dtri;": 9663,
  "dzcy;": 1119,
  "eDot;": 8785,
  "ecir;": 8790,
  ecirc: 234,
  "edot;": 279,
  "emsp;": 8195,
  "ensp;": 8194,
  "eopf;": 120150,
  "epar;": 8917,
  "epsi;": 949,
  "escr;": 8495,
  "esim;": 8770,
  "euml;": 235,
  "euro;": 8364,
  "excl;": 33,
  "flat;": 9837,
  "fnof;": 402,
  "fopf;": 120151,
  "fork;": 8916,
  "fscr;": 119995,
  "gdot;": 289,
  "geqq;": 8807,
  "gesl;": 8923,
  "gjcy;": 1107,
  "gnap;": 10890,
  "gneq;": 10888,
  "gopf;": 120152,
  "gscr;": 8458,
  "gsim;": 8819,
  "gtcc;": 10919,
  "gvnE;": 8809,
  "hArr;": 8660,
  "half;": 189,
  "harr;": 8596,
  "hbar;": 8463,
  "hopf;": 120153,
  "hscr;": 119997,
  icirc: 238,
  "iecy;": 1077,
  iexcl: 161,
  "imof;": 8887,
  "iocy;": 1105,
  "iopf;": 120154,
  "iota;": 953,
  "iscr;": 119998,
  "isin;": 8712,
  "iuml;": 239,
  "jopf;": 120155,
  "jscr;": 119999,
  "khcy;": 1093,
  "kjcy;": 1116,
  "kopf;": 120156,
  "kscr;": 12e4,
  "lArr;": 8656,
  "lHar;": 10594,
  "lang;": 10216,
  laquo: 171,
  "larr;": 8592,
  "late;": 10925,
  "lcub;": 123,
  "ldca;": 10550,
  "ldsh;": 8626,
  "leqq;": 8806,
  "lesg;": 8922,
  "ljcy;": 1113,
  "lnap;": 10889,
  "lneq;": 10887,
  "lopf;": 120157,
  "lozf;": 10731,
  "lpar;": 40,
  "lscr;": 120001,
  "lsim;": 8818,
  "lsqb;": 91,
  "ltcc;": 10918,
  "ltri;": 9667,
  "lvnE;": 8808,
  "macr;": 175,
  "male;": 9794,
  "malt;": 10016,
  micro: 181,
  "mlcp;": 10971,
  "mldr;": 8230,
  "mopf;": 120158,
  "mscr;": 120002,
  "nGtv;": 8811,
  "nLtv;": 8810,
  "nang;": 8736,
  "napE;": 10864,
  "nbsp;": 160,
  "ncap;": 10819,
  "ncup;": 10818,
  "ngeq;": 8817,
  "nges;": 10878,
  "ngtr;": 8815,
  "nisd;": 8954,
  "njcy;": 1114,
  "nldr;": 8229,
  "nleq;": 8816,
  "nles;": 10877,
  "nmid;": 8740,
  "nopf;": 120159,
  "npar;": 8742,
  "npre;": 10927,
  "nsce;": 10928,
  "nscr;": 120003,
  "nsim;": 8769,
  "nsub;": 8836,
  "nsup;": 8837,
  "ntgl;": 8825,
  "ntlg;": 8824,
  "nvap;": 8781,
  "nvge;": 8805,
  "nvgt;": 62,
  "nvle;": 8804,
  "nvlt;": 60,
  "oast;": 8859,
  "ocir;": 8858,
  ocirc: 244,
  "odiv;": 10808,
  "odot;": 8857,
  "ogon;": 731,
  "oint;": 8750,
  "omid;": 10678,
  "oopf;": 120160,
  "opar;": 10679,
  "ordf;": 170,
  "ordm;": 186,
  "oror;": 10838,
  "oscr;": 8500,
  "osol;": 8856,
  "ouml;": 246,
  "para;": 182,
  "part;": 8706,
  "perp;": 8869,
  "phiv;": 981,
  "plus;": 43,
  "popf;": 120161,
  pound: 163,
  "prap;": 10935,
  "prec;": 8826,
  "prnE;": 10933,
  "prod;": 8719,
  "prop;": 8733,
  "pscr;": 120005,
  "qint;": 10764,
  "qopf;": 120162,
  "qscr;": 120006,
  "quot;": 34,
  "rArr;": 8658,
  "rHar;": 10596,
  "race;": 8765,
  "rang;": 10217,
  raquo: 187,
  "rarr;": 8594,
  "rcub;": 125,
  "rdca;": 10551,
  "rdsh;": 8627,
  "real;": 8476,
  "rect;": 9645,
  "rhov;": 1009,
  "ring;": 730,
  "ropf;": 120163,
  "rpar;": 41,
  "rscr;": 120007,
  "rsqb;": 93,
  "rtri;": 9657,
  "scap;": 10936,
  "scnE;": 10934,
  "sdot;": 8901,
  "sect;": 167,
  "semi;": 59,
  "sext;": 10038,
  "shcy;": 1096,
  "sime;": 8771,
  "simg;": 10910,
  "siml;": 10909,
  "smid;": 8739,
  "smte;": 10924,
  "solb;": 10692,
  "sopf;": 120164,
  "spar;": 8741,
  "squf;": 9642,
  "sscr;": 120008,
  "star;": 9734,
  "subE;": 10949,
  "sube;": 8838,
  "succ;": 8827,
  "sung;": 9834,
  "sup1;": 185,
  "sup2;": 178,
  "sup3;": 179,
  "supE;": 10950,
  "supe;": 8839,
  szlig: 223,
  "tbrk;": 9140,
  "tdot;": 8411,
  thorn: 254,
  times: 215,
  "tint;": 8749,
  "toea;": 10536,
  "topf;": 120165,
  "tosa;": 10537,
  "trie;": 8796,
  "tscr;": 120009,
  "tscy;": 1094,
  "uArr;": 8657,
  "uHar;": 10595,
  "uarr;": 8593,
  ucirc: 251,
  "uopf;": 120166,
  "upsi;": 965,
  "uscr;": 120010,
  "utri;": 9653,
  "uuml;": 252,
  "vArr;": 8661,
  "vBar;": 10984,
  "varr;": 8597,
  "vert;": 124,
  "vopf;": 120167,
  "vscr;": 120011,
  "wopf;": 120168,
  "wscr;": 120012,
  "xcap;": 8898,
  "xcup;": 8899,
  "xmap;": 10236,
  "xnis;": 8955,
  "xopf;": 120169,
  "xscr;": 120013,
  "xvee;": 8897,
  "yacy;": 1103,
  "yicy;": 1111,
  "yopf;": 120170,
  "yscr;": 120014,
  "yucy;": 1102,
  "yuml;": 255,
  "zdot;": 380,
  "zeta;": 950,
  "zhcy;": 1078,
  "zopf;": 120171,
  "zscr;": 120015,
  "zwnj;": 8204,
  "AMP;": 38,
  "Acy;": 1040,
  "Afr;": 120068,
  "And;": 10835,
  Auml: 196,
  "Bcy;": 1041,
  "Bfr;": 120069,
  COPY: 169,
  "Cap;": 8914,
  "Cfr;": 8493,
  "Chi;": 935,
  "Cup;": 8915,
  "Dcy;": 1044,
  "Del;": 8711,
  "Dfr;": 120071,
  "Dot;": 168,
  "ENG;": 330,
  "ETH;": 208,
  "Ecy;": 1069,
  "Efr;": 120072,
  "Eta;": 919,
  Euml: 203,
  "Fcy;": 1060,
  "Ffr;": 120073,
  "Gcy;": 1043,
  "Gfr;": 120074,
  "Hat;": 94,
  "Hfr;": 8460,
  "Icy;": 1048,
  "Ifr;": 8465,
  "Int;": 8748,
  Iuml: 207,
  "Jcy;": 1049,
  "Jfr;": 120077,
  "Kcy;": 1050,
  "Kfr;": 120078,
  "Lcy;": 1051,
  "Lfr;": 120079,
  "Lsh;": 8624,
  "Map;": 10501,
  "Mcy;": 1052,
  "Mfr;": 120080,
  "Ncy;": 1053,
  "Nfr;": 120081,
  "Not;": 10988,
  "Ocy;": 1054,
  "Ofr;": 120082,
  Ouml: 214,
  "Pcy;": 1055,
  "Pfr;": 120083,
  "Phi;": 934,
  "Psi;": 936,
  QUOT: 34,
  "Qfr;": 120084,
  "REG;": 174,
  "Rcy;": 1056,
  "Rfr;": 8476,
  "Rho;": 929,
  "Rsh;": 8625,
  "Scy;": 1057,
  "Sfr;": 120086,
  "Sub;": 8912,
  "Sum;": 8721,
  "Sup;": 8913,
  "Tab;": 9,
  "Tau;": 932,
  "Tcy;": 1058,
  "Tfr;": 120087,
  "Ucy;": 1059,
  "Ufr;": 120088,
  Uuml: 220,
  "Vcy;": 1042,
  "Vee;": 8897,
  "Vfr;": 120089,
  "Wfr;": 120090,
  "Xfr;": 120091,
  "Ycy;": 1067,
  "Yfr;": 120092,
  "Zcy;": 1047,
  "Zfr;": 8488,
  "acE;": 8766,
  "acd;": 8767,
  "acy;": 1072,
  "afr;": 120094,
  "amp;": 38,
  "and;": 8743,
  "ang;": 8736,
  "apE;": 10864,
  "ape;": 8778,
  "ast;": 42,
  auml: 228,
  "bcy;": 1073,
  "bfr;": 120095,
  "bne;": 61,
  "bot;": 8869,
  "cap;": 8745,
  cent: 162,
  "cfr;": 120096,
  "chi;": 967,
  "cir;": 9675,
  copy: 169,
  "cup;": 8746,
  "dcy;": 1076,
  "deg;": 176,
  "dfr;": 120097,
  "die;": 168,
  "div;": 247,
  "dot;": 729,
  "ecy;": 1101,
  "efr;": 120098,
  "egs;": 10902,
  "ell;": 8467,
  "els;": 10901,
  "eng;": 331,
  "eta;": 951,
  "eth;": 240,
  euml: 235,
  "fcy;": 1092,
  "ffr;": 120099,
  "gEl;": 10892,
  "gap;": 10886,
  "gcy;": 1075,
  "gel;": 8923,
  "geq;": 8805,
  "ges;": 10878,
  "gfr;": 120100,
  "ggg;": 8921,
  "glE;": 10898,
  "gla;": 10917,
  "glj;": 10916,
  "gnE;": 8809,
  "gne;": 10888,
  "hfr;": 120101,
  "icy;": 1080,
  "iff;": 8660,
  "ifr;": 120102,
  "int;": 8747,
  iuml: 239,
  "jcy;": 1081,
  "jfr;": 120103,
  "kcy;": 1082,
  "kfr;": 120104,
  "lEg;": 10891,
  "lap;": 10885,
  "lat;": 10923,
  "lcy;": 1083,
  "leg;": 8922,
  "leq;": 8804,
  "les;": 10877,
  "lfr;": 120105,
  "lgE;": 10897,
  "lnE;": 8808,
  "lne;": 10887,
  "loz;": 9674,
  "lrm;": 8206,
  "lsh;": 8624,
  macr: 175,
  "map;": 8614,
  "mcy;": 1084,
  "mfr;": 120106,
  "mho;": 8487,
  "mid;": 8739,
  "nGg;": 8921,
  "nGt;": 8811,
  "nLl;": 8920,
  "nLt;": 8810,
  "nap;": 8777,
  nbsp: 160,
  "ncy;": 1085,
  "nfr;": 120107,
  "ngE;": 8807,
  "nge;": 8817,
  "ngt;": 8815,
  "nis;": 8956,
  "niv;": 8715,
  "nlE;": 8806,
  "nle;": 8816,
  "nlt;": 8814,
  "not;": 172,
  "npr;": 8832,
  "nsc;": 8833,
  "num;": 35,
  "ocy;": 1086,
  "ofr;": 120108,
  "ogt;": 10689,
  "ohm;": 937,
  "olt;": 10688,
  "ord;": 10845,
  ordf: 170,
  ordm: 186,
  "orv;": 10843,
  ouml: 246,
  "par;": 8741,
  para: 182,
  "pcy;": 1087,
  "pfr;": 120109,
  "phi;": 966,
  "piv;": 982,
  "prE;": 10931,
  "pre;": 10927,
  "psi;": 968,
  "qfr;": 120110,
  quot: 34,
  "rcy;": 1088,
  "reg;": 174,
  "rfr;": 120111,
  "rho;": 961,
  "rlm;": 8207,
  "rsh;": 8625,
  "scE;": 10932,
  "sce;": 10928,
  "scy;": 1089,
  sect: 167,
  "sfr;": 120112,
  "shy;": 173,
  "sim;": 8764,
  "smt;": 10922,
  "sol;": 47,
  "squ;": 9633,
  "sub;": 8834,
  "sum;": 8721,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  "sup;": 8835,
  "tau;": 964,
  "tcy;": 1090,
  "tfr;": 120113,
  "top;": 8868,
  "ucy;": 1091,
  "ufr;": 120114,
  "uml;": 168,
  uuml: 252,
  "vcy;": 1074,
  "vee;": 8744,
  "vfr;": 120115,
  "wfr;": 120116,
  "xfr;": 120117,
  "ycy;": 1099,
  "yen;": 165,
  "yfr;": 120118,
  yuml: 255,
  "zcy;": 1079,
  "zfr;": 120119,
  "zwj;": 8205,
  AMP: 38,
  "DD;": 8517,
  ETH: 208,
  "GT;": 62,
  "Gg;": 8921,
  "Gt;": 8811,
  "Im;": 8465,
  "LT;": 60,
  "Ll;": 8920,
  "Lt;": 8810,
  "Mu;": 924,
  "Nu;": 925,
  "Or;": 10836,
  "Pi;": 928,
  "Pr;": 10939,
  REG: 174,
  "Re;": 8476,
  "Sc;": 10940,
  "Xi;": 926,
  "ac;": 8766,
  "af;": 8289,
  amp: 38,
  "ap;": 8776,
  "dd;": 8518,
  deg: 176,
  "ee;": 8519,
  "eg;": 10906,
  "el;": 10905,
  eth: 240,
  "gE;": 8807,
  "ge;": 8805,
  "gg;": 8811,
  "gl;": 8823,
  "gt;": 62,
  "ic;": 8291,
  "ii;": 8520,
  "in;": 8712,
  "it;": 8290,
  "lE;": 8806,
  "le;": 8804,
  "lg;": 8822,
  "ll;": 8810,
  "lt;": 60,
  "mp;": 8723,
  "mu;": 956,
  "ne;": 8800,
  "ni;": 8715,
  not: 172,
  "nu;": 957,
  "oS;": 9416,
  "or;": 8744,
  "pi;": 960,
  "pm;": 177,
  "pr;": 8826,
  reg: 174,
  "rx;": 8478,
  "sc;": 8827,
  shy: 173,
  uml: 168,
  "wp;": 8472,
  "wr;": 8768,
  "xi;": 958,
  yen: 165,
  GT: 62,
  LT: 60,
  gt: 62,
  lt: 60
};

// node_modules/svelte/src/compiler/phases/1-parse/utils/html.js
var windows_1252 = [
  8364,
  129,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  141,
  381,
  143,
  144,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  157,
  382,
  376
];
function reg_exp_entity(entity_name, is_attribute_value) {
  if (is_attribute_value && !entity_name.endsWith(";")) {
    return `${entity_name}\\b(?!=)`;
  }
  return entity_name;
}
function get_entity_pattern(is_attribute_value) {
  const reg_exp_num = "#(?:x[a-fA-F\\d]+|\\d+)(?:;)?";
  const reg_exp_entities = Object.keys(entities_default).map(
    /** @param {any} entity_name */
    (entity_name) => reg_exp_entity(entity_name, is_attribute_value)
  );
  const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join("|")})`, "g");
  return entity_pattern;
}
var entity_pattern_content = get_entity_pattern(false);
var entity_pattern_attr_value = get_entity_pattern(true);
function decode_character_references(html, is_attribute_value) {
  const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
  return html.replace(
    entity_pattern,
    /**
     * @param {any} match
     * @param {keyof typeof entities} entity
     */
    (match, entity) => {
      let code;
      if (entity[0] !== "#") {
        code = entities_default[entity];
      } else if (entity[1] === "x") {
        code = parseInt(entity.substring(2), 16);
      } else {
        code = parseInt(entity.substring(1), 10);
      }
      if (!code) {
        return match;
      }
      return String.fromCodePoint(validate_code(code));
    }
  );
}
var NUL = 0;
function validate_code(code) {
  if (code === 10) {
    return 32;
  }
  if (code < 128) {
    return code;
  }
  if (code <= 159) {
    return windows_1252[code - 128];
  }
  if (code < 55296) {
    return code;
  }
  if (code <= 57343) {
    return NUL;
  }
  if (code <= 65535) {
    return code;
  }
  if (code >= 65536 && code <= 131071) {
    return code;
  }
  if (code >= 131072 && code <= 196607) {
    return code;
  }
  if (code >= 917504 && code <= 917631 || code >= 917760 && code <= 917999) {
    return code;
  }
  return NUL;
}

// node_modules/svelte/src/compiler/phases/1-parse/utils/create.js
function create_fragment(transparent = false) {
  return {
    type: "Fragment",
    nodes: [],
    metadata: {
      transparent,
      dynamic: false
    }
  };
}

// node_modules/svelte/src/compiler/phases/nodes.js
var element_nodes = [
  "SvelteElement",
  "RegularElement",
  "SvelteFragment",
  "Component",
  "SvelteComponent",
  "SvelteSelf",
  "SlotElement"
];
function is_element_node(node) {
  return element_nodes.includes(node.type);
}
function is_custom_element_node(node) {
  return node.type === "RegularElement" && (node.name.includes("-") || node.attributes.some((attr) => attr.type === "Attribute" && attr.name === "is"));
}
function create_attribute(name, start, end, value) {
  return {
    type: "Attribute",
    start,
    end,
    name,
    value,
    metadata: {
      delegated: null,
      needs_clsx: false
    }
  };
}
function create_expression_metadata() {
  return {
    dependencies: /* @__PURE__ */ new Set(),
    has_state: false,
    has_call: false
  };
}

// node_modules/svelte/src/html-tree-validation.js
var autoclosing_children = {
  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
  li: { direct: ["li"] },
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt#technical_summary
  dt: { descendant: ["dt", "dd"], reset_by: ["dl"] },
  dd: { descendant: ["dt", "dd"], reset_by: ["dl"] },
  p: {
    descendant: [
      "address",
      "article",
      "aside",
      "blockquote",
      "div",
      "dl",
      "fieldset",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "hr",
      "main",
      "menu",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "table",
      "ul"
    ]
  },
  rt: { descendant: ["rt", "rp"] },
  rp: { descendant: ["rt", "rp"] },
  optgroup: { descendant: ["optgroup"] },
  option: { descendant: ["option", "optgroup"] },
  thead: { direct: ["tbody", "tfoot"] },
  tbody: { direct: ["tbody", "tfoot"] },
  tfoot: { direct: ["tbody"] },
  tr: { direct: ["tr", "tbody"] },
  td: { direct: ["td", "th", "tr"] },
  th: { direct: ["td", "th", "tr"] }
};
function closing_tag_omitted(current, next2) {
  const disallowed = autoclosing_children[current];
  if (disallowed) {
    if (!next2 || ("direct" in disallowed ? disallowed.direct : disallowed.descendant).includes(next2)) {
      return true;
    }
  }
  return false;
}
var disallowed_children = {
  ...autoclosing_children,
  optgroup: { only: ["option", "#text"] },
  // Strictly speaking, seeing an <option> doesn't mean we're in a <select>, but we assume it here
  option: { only: ["#text"] },
  form: { descendant: ["form"] },
  a: { descendant: ["a"] },
  button: { descendant: ["button"] },
  h1: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h2: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h3: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h4: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h5: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  h6: { descendant: ["h1", "h2", "h3", "h4", "h5", "h6"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
  select: { only: ["option", "optgroup", "#text", "hr", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
  // No special behavior since these rules fall back to "in body" mode for
  // all except special table nodes which cause bad parsing behavior anyway.
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
  tr: { only: ["th", "td", "style", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
  tbody: { only: ["tr", "style", "script", "template"] },
  thead: { only: ["tr", "style", "script", "template"] },
  tfoot: { only: ["tr", "style", "script", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
  colgroup: { only: ["col", "template"] },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
  table: {
    only: ["caption", "colgroup", "tbody", "thead", "tfoot", "style", "script", "template"]
  },
  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
  head: {
    only: [
      "base",
      "basefont",
      "bgsound",
      "link",
      "meta",
      "title",
      "noscript",
      "noframes",
      "style",
      "script",
      "template"
    ]
  },
  // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
  html: { only: ["head", "body", "frameset"] },
  frameset: { only: ["frame"] },
  "#document": { only: ["html"] }
};
function is_tag_valid_with_ancestor(child_tag, ancestors, child_loc, ancestor_loc) {
  if (child_tag.includes("-")) return null;
  const ancestor_tag = ancestors[ancestors.length - 1];
  const disallowed = disallowed_children[ancestor_tag];
  if (!disallowed) return null;
  if ("reset_by" in disallowed && disallowed.reset_by) {
    for (let i = ancestors.length - 2; i >= 0; i--) {
      const ancestor = ancestors[i];
      if (ancestor.includes("-")) return null;
      if (disallowed.reset_by.includes(ancestors[i])) {
        return null;
      }
    }
  }
  if ("descendant" in disallowed && disallowed.descendant.includes(child_tag)) {
    const child = child_loc ? `\`<${child_tag}>\` (${child_loc})` : `\`<${child_tag}>\``;
    const ancestor = ancestor_loc ? `\`<${ancestor_tag}>\` (${ancestor_loc})` : `\`<${ancestor_tag}>\``;
    return `${child} cannot be a descendant of ${ancestor}`;
  }
  return null;
}
function is_tag_valid_with_parent(child_tag, parent_tag, child_loc, parent_loc) {
  if (child_tag.includes("-") || (parent_tag == null ? void 0 : parent_tag.includes("-"))) return null;
  if (parent_tag === "template") return null;
  const disallowed = disallowed_children[parent_tag];
  const child = child_loc ? `\`<${child_tag}>\` (${child_loc})` : `\`<${child_tag}>\``;
  const parent = parent_loc ? `\`<${parent_tag}>\` (${parent_loc})` : `\`<${parent_tag}>\``;
  if (disallowed) {
    if ("direct" in disallowed && disallowed.direct.includes(child_tag)) {
      return `${child} cannot be a direct child of ${parent}`;
    }
    if ("descendant" in disallowed && disallowed.descendant.includes(child_tag)) {
      return `${child} cannot be a child of ${parent}`;
    }
    if ("only" in disallowed && disallowed.only) {
      if (disallowed.only.includes(child_tag)) {
        return null;
      } else {
        return `${child} cannot be a child of ${parent}. \`<${parent_tag}>\` only allows these children: ${disallowed.only.map((d) => `\`<${d}>\``).join(", ")}`;
      }
    }
  }
  switch (child_tag) {
    case "body":
    case "caption":
    case "col":
    case "colgroup":
    case "frameset":
    case "frame":
    case "head":
    case "html":
      return `${child} cannot be a child of ${parent}`;
    case "thead":
    case "tbody":
    case "tfoot":
      return `${child} must be the child of a \`<table>\`, not a ${parent}`;
    case "td":
    case "th":
      return `${child} must be the child of a \`<tr>\`, not a ${parent}`;
    case "tr":
      return `\`<tr>\` must be the child of a \`<thead>\`, \`<tbody>\`, or \`<tfoot>\`, not a ${parent}`;
  }
  return null;
}

// node_modules/svelte/src/compiler/utils/string.js
function list(strings, conjunction = "or") {
  if (strings.length === 1) return strings[0];
  if (strings.length === 2) return `${strings[0]} ${conjunction} ${strings[1]}`;
  return `${strings.slice(0, -1).join(", ")} ${conjunction} ${strings[strings.length - 1]}`;
}

// node_modules/svelte/src/compiler/phases/1-parse/state/element.js
var regex_invalid_unquoted_attribute_value = /^(\/>|[\s"'=<>`])/;
var regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
var regex_closing_comment = /-->/;
var regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
var regex_token_ending_character = /[\s=/>"']/;
var regex_starts_with_quote_characters = /^["']/;
var regex_attribute_value = /^(?:"([^"]*)"|'([^'])*'|([^>\s]+))/;
var regex_valid_element_name = /^(?:![a-zA-Z]+|[a-zA-Z](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?|[a-zA-Z][a-zA-Z0-9]*:[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9])$/;
var regex_valid_component_name = (
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers adjusted for our needs
  // (must start with uppercase letter if no dots, can contain dots)
  new RegExp("^(?:\\p{Lu}[$\\u200c\\u200d\\p{ID_Continue}.]*|\\p{ID_Start}[$\\u200c\\u200d\\p{ID_Continue}]*(?:\\.[$\\u200c\\u200d\\p{ID_Continue}]+)+)$", "u")
);
var root_only_meta_tags = /* @__PURE__ */ new Map([
  ["svelte:head", "SvelteHead"],
  ["svelte:options", "SvelteOptions"],
  ["svelte:window", "SvelteWindow"],
  ["svelte:document", "SvelteDocument"],
  ["svelte:body", "SvelteBody"]
]);
var meta_tags = new Map([
  ...root_only_meta_tags,
  ["svelte:element", "SvelteElement"],
  ["svelte:component", "SvelteComponent"],
  ["svelte:self", "SvelteSelf"],
  ["svelte:fragment", "SvelteFragment"],
  ["svelte:boundary", "SvelteBoundary"]
]);
function element(parser) {
  const start = parser.index++;
  let parent = parser.current();
  if (parser.eat("!--")) {
    const data = parser.read_until(regex_closing_comment);
    parser.eat("-->", true);
    parser.append({
      type: "Comment",
      start,
      end: parser.index,
      data
    });
    return;
  }
  const is_closing_tag = parser.eat("/");
  const name = parser.read_until(regex_whitespace_or_slash_or_closing_tag);
  if (is_closing_tag) {
    parser.allow_whitespace();
    parser.eat(">", true);
    if (is_void(name)) {
      void_element_invalid_content(start);
    }
    while (
      /** @type {AST.RegularElement} */
      parent.name !== name
    ) {
      if (parser.loose) {
        if (is_element_node(parent)) {
          const last = parent.attributes.at(-1);
          if ((last == null ? void 0 : last.type) === "Attribute" && last.name === `<${name}`) {
            parser.index = last.start;
            parent.attributes.pop();
            break;
          }
        }
      }
      if (parent.type !== "RegularElement" && !parser.loose) {
        if (parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name) {
          element_invalid_closing_tag_autoclosed(start, name, parser.last_auto_closed_tag.reason);
        } else {
          element_invalid_closing_tag(start, name);
        }
      }
      parent.end = start;
      parser.pop();
      parent = parser.current();
    }
    parent.end = parser.index;
    parser.pop();
    if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) {
      parser.last_auto_closed_tag = void 0;
    }
    return;
  }
  if (name.startsWith("svelte:") && !meta_tags.has(name)) {
    const bounds = { start: start + 1, end: start + 1 + name.length };
    svelte_meta_invalid_tag(bounds, list(Array.from(meta_tags.keys())));
  }
  if (!regex_valid_element_name.test(name) && !regex_valid_component_name.test(name)) {
    if (!parser.loose || !name.endsWith(".")) {
      const bounds = { start: start + 1, end: start + 1 + name.length };
      tag_invalid_name(bounds);
    }
  }
  if (root_only_meta_tags.has(name)) {
    if (name in parser.meta_tags) {
      svelte_meta_duplicate(start, name);
    }
    if (parent.type !== "Root") {
      svelte_meta_invalid_placement(start, name);
    }
    parser.meta_tags[name] = true;
  }
  const type = meta_tags.has(name) ? meta_tags.get(name) : regex_valid_component_name.test(name) || parser.loose && name.endsWith(".") ? "Component" : name === "title" && parent_is_head(parser.stack) ? "TitleElement" : (
    // TODO Svelte 6/7: once slots are removed in favor of snippets, always keep slot as a regular element
    name === "slot" && !parent_is_shadowroot_template(parser.stack) ? "SlotElement" : "RegularElement"
  );
  const element2 = type === "RegularElement" ? {
    type,
    start,
    end: -1,
    name,
    attributes: [],
    fragment: create_fragment(true),
    metadata: {
      svg: false,
      mathml: false,
      scoped: false,
      has_spread: false,
      path: []
    }
  } : (
    /** @type {AST.ElementLike} */
    {
      type,
      start,
      end: -1,
      name,
      attributes: [],
      fragment: create_fragment(true),
      metadata: {
        // unpopulated at first, differs between types
      }
    }
  );
  parser.allow_whitespace();
  if (parent.type === "RegularElement" && closing_tag_omitted(parent.name, name)) {
    parent.end = start;
    parser.pop();
    parser.last_auto_closed_tag = {
      tag: parent.name,
      reason: name,
      depth: parser.stack.length
    };
  }
  const unique_names = [];
  const current = parser.current();
  const is_top_level_script_or_style = (name === "script" || name === "style") && current.type === "Root";
  const read = is_top_level_script_or_style ? read_static_attribute : read_attribute;
  let attribute;
  while (attribute = read(parser)) {
    if (attribute.type === "Attribute" || attribute.type === "BindDirective" || attribute.type === "StyleDirective" || attribute.type === "ClassDirective") {
      const type2 = attribute.type === "BindDirective" ? "Attribute" : attribute.type;
      if (unique_names.includes(type2 + attribute.name)) {
        attribute_duplicate(attribute);
      } else if (attribute.name !== "this") {
        unique_names.push(type2 + attribute.name);
      }
    }
    element2.attributes.push(attribute);
    parser.allow_whitespace();
  }
  if (element2.type === "SvelteComponent") {
    const index = element2.attributes.findIndex(
      /** @param {any} attr */
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      svelte_component_missing_this(start);
    }
    const definition = (
      /** @type {AST.Attribute} */
      element2.attributes.splice(index, 1)[0]
    );
    if (!is_expression_attribute(definition)) {
      svelte_component_invalid_this(definition.start);
    }
    element2.expression = get_attribute_expression(definition);
  }
  if (element2.type === "SvelteElement") {
    const index = element2.attributes.findIndex(
      /** @param {any} attr */
      (attr) => attr.type === "Attribute" && attr.name === "this"
    );
    if (index === -1) {
      svelte_element_missing_this(start);
    }
    const definition = (
      /** @type {AST.Attribute} */
      element2.attributes.splice(index, 1)[0]
    );
    if (definition.value === true) {
      svelte_element_missing_this(definition);
    }
    if (!is_expression_attribute(definition)) {
      svelte_element_invalid_this(definition);
      const chunk = (
        /** @type {Array<AST.ExpressionTag | AST.Text>} */
        definition.value[0]
      );
      element2.tag = chunk.type === "Text" ? {
        type: "Literal",
        value: chunk.data,
        raw: `'${chunk.raw}'`,
        start: chunk.start,
        end: chunk.end
      } : chunk.expression;
    } else {
      element2.tag = get_attribute_expression(definition);
    }
  }
  if (is_top_level_script_or_style) {
    parser.eat(">", true);
    let prev_comment = null;
    for (let i = current.fragment.nodes.length - 1; i >= 0; i--) {
      const node = current.fragment.nodes[i];
      if (i === current.fragment.nodes.length - 1 && node.end !== start) {
        break;
      }
      if (node.type === "Comment") {
        prev_comment = node;
        break;
      } else if (node.type !== "Text" || node.data.trim()) {
        break;
      }
    }
    if (name === "script") {
      const content = read_script(parser, start, element2.attributes);
      if (prev_comment) {
        content.content.leadingComments = [{ type: "Line", value: prev_comment.data }];
      }
      if (content.context === "module") {
        if (current.module) script_duplicate(start);
        current.module = content;
      } else {
        if (current.instance) script_duplicate(start);
        current.instance = content;
      }
    } else {
      const content = read_style(parser, start, element2.attributes);
      content.content.comment = prev_comment;
      if (current.css) style_duplicate(start);
      current.css = content;
    }
    return;
  }
  parser.append(element2);
  const self_closing = parser.eat("/") || is_void(name);
  const closed = parser.eat(">", true, false);
  if (!closed) {
    const last = element2.attributes.at(-1);
    if ((last == null ? void 0 : last.type) === "Attribute" && last.name === "<") {
      parser.index = last.start;
      element2.attributes.pop();
    } else {
      const prev_1 = parser.template[parser.index - 1];
      const prev_2 = parser.template[parser.index - 2];
      const current2 = parser.template[parser.index];
      if (prev_2 === "{" && prev_1 === "/") {
        parser.index -= 2;
      } else if (prev_1 === "{" && (current2 === "#" || current2 === "@" || current2 === ":")) {
        parser.index -= 1;
      } else {
        parser.allow_whitespace();
        if (parser.index === parser.template.length) {
          while (parser.index < parser.template_untrimmed.length && regex_whitespace.test(parser.template_untrimmed[parser.index])) {
            parser.index++;
          }
        }
      }
    }
  }
  if (self_closing || !closed) {
    element2.end = parser.index;
  } else if (name === "textarea") {
    element2.fragment.nodes = read_sequence(
      parser,
      () => regex_closing_textarea_tag.test(parser.template.slice(parser.index)),
      "inside <textarea>"
    );
    parser.read(regex_closing_textarea_tag);
    element2.end = parser.index;
  } else if (name === "script" || name === "style") {
    const start2 = parser.index;
    const data = parser.read_until(new RegExp(`</${name}>`));
    const end = parser.index;
    const node = {
      start: start2,
      end,
      type: "Text",
      data,
      raw: data
    };
    element2.fragment.nodes.push(node);
    parser.eat(`</${name}>`, true);
    element2.end = parser.index;
  } else {
    parser.stack.push(element2);
    parser.fragments.push(element2.fragment);
  }
}
function parent_is_head(stack) {
  let i = stack.length;
  while (i--) {
    const { type } = stack[i];
    if (type === "SvelteHead") return true;
    if (type === "RegularElement" || type === "Component") return false;
  }
  return false;
}
function parent_is_shadowroot_template(stack) {
  let i = stack.length;
  while (i--) {
    if (stack[i].type === "RegularElement" && /** @type {AST.RegularElement} */
    stack[i].attributes.some(
      (a) => a.type === "Attribute" && a.name === "shadowrootmode"
    )) {
      return true;
    }
  }
  return false;
}
function read_static_attribute(parser) {
  const start = parser.index;
  const name = parser.read_until(regex_token_ending_character);
  if (!name) return null;
  let value = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    let raw = parser.match_regex(regex_attribute_value);
    if (!raw) {
      expected_attribute_value(parser.index);
    }
    parser.index += raw.length;
    const quoted = raw[0] === '"' || raw[0] === "'";
    if (quoted) {
      raw = raw.slice(1, -1);
    }
    value = [
      {
        start: parser.index - raw.length - (quoted ? 1 : 0),
        end: quoted ? parser.index - 1 : parser.index,
        type: "Text",
        raw,
        data: decode_character_references(raw, true)
      }
    ];
  }
  if (parser.match_regex(regex_starts_with_quote_characters)) {
    expected_token(parser.index, "=");
  }
  return create_attribute(name, start, parser.index, value);
}
function read_attribute(parser) {
  const start = parser.index;
  if (parser.eat("{")) {
    parser.allow_whitespace();
    if (parser.eat("...")) {
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const spread2 = {
        type: "SpreadAttribute",
        start,
        end: parser.index,
        expression,
        metadata: {
          expression: create_expression_metadata()
        }
      };
      return spread2;
    } else {
      const value_start = parser.index;
      let name2 = parser.read_identifier();
      if (name2 === null) {
        if (parser.loose && (parser.match("#") || parser.match("/") || parser.match("@") || parser.match(":"))) {
          return null;
        } else if (parser.loose && parser.match("}")) {
          name2 = "";
        } else {
          attribute_empty_shorthand(start);
        }
      }
      parser.allow_whitespace();
      parser.eat("}", true);
      const expression = {
        type: "ExpressionTag",
        start: value_start,
        end: value_start + name2.length,
        expression: {
          start: value_start,
          end: value_start + name2.length,
          type: "Identifier",
          name: name2
        },
        metadata: {
          expression: create_expression_metadata()
        }
      };
      return create_attribute(name2, start, parser.index, expression);
    }
  }
  const name = parser.read_until(regex_token_ending_character);
  if (!name) return null;
  let end = parser.index;
  parser.allow_whitespace();
  const colon_index = name.indexOf(":");
  const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index));
  let value = true;
  if (parser.eat("=")) {
    parser.allow_whitespace();
    if (parser.template[parser.index] === "/" && parser.template[parser.index + 1] === ">") {
      const char_start = parser.index;
      parser.index++;
      value = [
        {
          start: char_start,
          end: char_start + 1,
          type: "Text",
          raw: "/",
          data: "/"
        }
      ];
      end = parser.index;
    } else {
      value = read_attribute_value2(parser);
      end = parser.index;
    }
  } else if (parser.match_regex(regex_starts_with_quote_characters)) {
    expected_token(parser.index, "=");
  }
  if (type) {
    const [directive_name, ...modifiers2] = name.slice(colon_index + 1).split("|");
    if (directive_name === "") {
      directive_missing_name({ start, end: start + colon_index + 1 }, name);
    }
    if (type === "StyleDirective") {
      return {
        start,
        end,
        type,
        name: directive_name,
        modifiers: (
          /** @type {Array<'important'>} */
          modifiers2
        ),
        value,
        metadata: {
          expression: create_expression_metadata()
        }
      };
    }
    const first_value = value === true ? void 0 : Array.isArray(value) ? value[0] : value;
    let expression = null;
    if (first_value) {
      const attribute_contains_text = (
        /** @type {any[]} */
        value.length > 1 || first_value.type === "Text"
      );
      if (attribute_contains_text) {
        directive_invalid_value(
          /** @type {number} */
          first_value.start
        );
      } else {
        expression = first_value.expression;
      }
    }
    const directive = {
      start,
      end,
      type,
      name: directive_name,
      expression,
      metadata: {
        expression: create_expression_metadata()
      }
    };
    directive.modifiers = modifiers2;
    if (directive.type === "TransitionDirective") {
      const direction = name.slice(0, colon_index);
      directive.intro = direction === "in" || direction === "transition";
      directive.outro = direction === "out" || direction === "transition";
    }
    if ((directive.type === "BindDirective" || directive.type === "ClassDirective") && !directive.expression) {
      directive.expression = /** @type {any} */
      {
        start: start + colon_index + 1,
        end,
        type: "Identifier",
        name: directive.name
      };
    }
    return directive;
  }
  return create_attribute(name, start, end, value);
}
function get_directive_type(name) {
  if (name === "use") return "UseDirective";
  if (name === "animate") return "AnimateDirective";
  if (name === "bind") return "BindDirective";
  if (name === "class") return "ClassDirective";
  if (name === "style") return "StyleDirective";
  if (name === "on") return "OnDirective";
  if (name === "let") return "LetDirective";
  if (name === "in" || name === "out" || name === "transition") return "TransitionDirective";
  return false;
}
function read_attribute_value2(parser) {
  var _a2;
  const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
  if (quote_mark && parser.eat(quote_mark)) {
    return [
      {
        start: parser.index - 1,
        end: parser.index - 1,
        type: "Text",
        raw: "",
        data: ""
      }
    ];
  }
  let value;
  try {
    value = read_sequence(
      parser,
      () => {
        if (quote_mark) return parser.match(quote_mark);
        return !!parser.match_regex(regex_invalid_unquoted_attribute_value);
      },
      "in attribute value"
    );
  } catch (error) {
    if (error.code === "js_parse_error") {
      const pos = (_a2 = error.position) == null ? void 0 : _a2[0];
      if (pos !== void 0 && parser.template.slice(pos - 1, pos + 1) === "/>") {
        parser.index = pos;
        expected_token(pos, quote_mark || "}");
      }
    }
    throw error;
  }
  if (value.length === 0 && !quote_mark) {
    expected_attribute_value(parser.index);
  }
  if (quote_mark) parser.index += 1;
  if (quote_mark || value.length > 1 || value[0].type === "Text") {
    return value;
  } else {
    return value[0];
  }
}
function read_sequence(parser, done, location) {
  let current_chunk = {
    start: parser.index,
    end: -1,
    type: "Text",
    raw: "",
    data: ""
  };
  const chunks = [];
  function flush(end) {
    if (current_chunk.raw) {
      current_chunk.data = decode_character_references(current_chunk.raw, true);
      current_chunk.end = end;
      chunks.push(current_chunk);
    }
  }
  while (parser.index < parser.template.length) {
    const index = parser.index;
    if (done()) {
      flush(parser.index);
      return chunks;
    } else if (parser.eat("{")) {
      if (parser.match("#")) {
        const index2 = parser.index - 1;
        parser.eat("#");
        const name = parser.read_until(/[^a-z]/);
        block_invalid_placement(index2, name, location);
      } else if (parser.match("@")) {
        const index2 = parser.index - 1;
        parser.eat("@");
        const name = parser.read_until(/[^a-z]/);
        tag_invalid_placement(index2, name, location);
      }
      flush(parser.index - 1);
      parser.allow_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      const chunk = {
        type: "ExpressionTag",
        start: index,
        end: parser.index,
        expression,
        metadata: {
          expression: create_expression_metadata()
        }
      };
      chunks.push(chunk);
      current_chunk = {
        start: parser.index,
        end: -1,
        type: "Text",
        raw: "",
        data: ""
      };
    } else {
      current_chunk.raw += parser.template[parser.index++];
    }
  }
  if (parser.loose) {
    return chunks;
  } else {
    unexpected_eof(parser.template.length);
  }
}

// node_modules/svelte/src/compiler/phases/1-parse/read/context.js
function read_pattern(parser) {
  const start = parser.index;
  let i = parser.index;
  const name = parser.read_identifier();
  if (name !== null) {
    const annotation = read_type_annotation(parser);
    return {
      type: "Identifier",
      name,
      start,
      loc: {
        start: (
          /** @type {Location} */
          locator(start)
        ),
        end: (
          /** @type {Location} */
          locator(parser.index)
        )
      },
      end: parser.index,
      typeAnnotation: annotation
    };
  }
  if (!is_bracket_open(parser.template[i])) {
    expected_pattern(i);
  }
  i = match_bracket(parser, start);
  parser.index = i;
  const pattern_string = parser.template.slice(start, i);
  try {
    let space_with_newline = parser.template.slice(0, start).replace(regex_not_newline_characters, " ");
    const first_space = space_with_newline.indexOf(" ");
    space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
    const expression = (
      /** @type {any} */
      parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, parser.ts, start - 1).left
    );
    expression.typeAnnotation = read_type_annotation(parser);
    if (expression.typeAnnotation) {
      expression.end = expression.typeAnnotation.end;
    }
    return expression;
  } catch (error) {
    parser.acorn_error(error);
  }
}
function match_bracket(parser, start) {
  const bracket_stack = [];
  let i = start;
  while (i < parser.template.length) {
    let char = parser.template[i++];
    if (char === "'" || char === '"' || char === "`") {
      i = match_quote(parser, i, char);
      continue;
    }
    if (is_bracket_open(char)) {
      bracket_stack.push(char);
    } else if (is_bracket_close(char)) {
      const popped = (
        /** @type {string} */
        bracket_stack.pop()
      );
      const expected = (
        /** @type {string} */
        get_bracket_close(popped)
      );
      if (char !== expected) {
        expected_token(i - 1, expected);
      }
      if (bracket_stack.length === 0) {
        return i;
      }
    }
  }
  unexpected_eof(parser.template.length);
}
function match_quote(parser, start, quote) {
  let is_escaped = false;
  let i = start;
  while (i < parser.template.length) {
    const char = parser.template[i++];
    if (is_escaped) {
      is_escaped = false;
      continue;
    }
    if (char === quote) {
      return i;
    }
    if (char === "\\") {
      is_escaped = true;
    }
    if (quote === "`" && char === "$" && parser.template[i] === "{") {
      i = match_bracket(parser, i);
    }
  }
  unterminated_string_constant(start);
}
function read_type_annotation(parser) {
  const start = parser.index;
  parser.allow_whitespace();
  if (!parser.eat(":")) {
    parser.index = start;
    return void 0;
  }
  const insert = "_ as ";
  let a = parser.index - insert.length;
  const template3 = parser.template.slice(0, a).replace(/[^\n]/g, " ") + insert + // If this is a type annotation for a function parameter, Acorn-TS will treat subsequent
  // parameters as part of a sequence expression instead, and will then error on optional
  // parameters (`?:`). Therefore replace that sequence with something that will not error.
  parser.template.slice(parser.index).replace(/\?\s*:/g, ":");
  let expression = parse_expression_at(template3, parser.ts, a);
  if (expression.type === "AssignmentExpression") {
    let b = expression.right.start;
    while (template3[b] !== "=") b -= 1;
    expression = parse_expression_at(template3.slice(0, b), parser.ts, a);
  }
  if (expression.type === "SequenceExpression") {
    expression = expression.expressions[0];
  }
  parser.index = /** @type {number} */
  expression.end;
  return {
    type: "TSTypeAnnotation",
    start,
    end: parser.index,
    typeAnnotation: (
      /** @type {any} */
      expression.typeAnnotation
    )
  };
}

// node_modules/svelte/src/compiler/phases/1-parse/state/tag.js
var regex_whitespace_with_closing_curly_brace = /^\s*}/;
function tag(parser) {
  const start = parser.index;
  parser.index += 1;
  parser.allow_whitespace();
  if (parser.eat("#")) return open(parser);
  if (parser.eat(":")) return next(parser);
  if (parser.eat("@")) return special(parser);
  if (parser.match("/")) {
    if (!parser.match("/*") && !parser.match("//")) {
      parser.eat("/");
      return close(parser);
    }
  }
  const expression = read_expression(parser);
  parser.allow_whitespace();
  parser.eat("}", true);
  parser.append({
    type: "ExpressionTag",
    start,
    end: parser.index,
    expression,
    metadata: {
      expression: create_expression_metadata()
    }
  });
}
function open(parser) {
  let start = parser.index - 2;
  while (parser.template[start] !== "{") start -= 1;
  if (parser.eat("if")) {
    parser.require_whitespace();
    const block2 = parser.append({
      type: "IfBlock",
      elseif: false,
      start,
      end: -1,
      test: read_expression(parser),
      consequent: create_fragment(),
      alternate: null
    });
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.stack.push(block2);
    parser.fragments.push(block2.consequent);
    return;
  }
  if (parser.eat("each")) {
    parser.require_whitespace();
    const template3 = parser.template;
    let end = parser.template.length;
    let expression;
    while (!expression) {
      try {
        expression = read_expression(parser, void 0, true);
      } catch (err) {
        end = /** @type {any} */
        err.position[0] - 2;
        while (end > start && parser.template.slice(end, end + 2) !== "as") {
          end -= 1;
        }
        if (end <= start) {
          if (parser.loose) {
            expression = get_loose_identifier(parser);
            if (expression) {
              break;
            }
          }
          throw err;
        }
        parser.template = template3.slice(0, end);
      }
    }
    parser.template = template3;
    parser.allow_whitespace();
    if (!parser.match("as")) {
      if (expression.type === "SequenceExpression") {
        expression = expression.expressions[0];
      }
      let assertion = null;
      let end2 = expression.end;
      expression = walk(expression, null, {
        // @ts-expect-error
        TSAsExpression(node, context2) {
          if (node.end === /** @type {Expression} */
          expression.end) {
            assertion = node;
            end2 = node.expression.end;
            return node.expression;
          }
          context2.next();
        }
      });
      expression.end = end2;
      if (assertion) {
        let end3 = (
          /** @type {any} */
          /** @type {any} */
          assertion.typeAnnotation.start - 2
        );
        while (parser.template.slice(end3, end3 + 2) !== "as") end3 -= 1;
        parser.index = end3;
      }
    }
    let context = null;
    let index;
    let key2;
    if (parser.eat("as")) {
      parser.require_whitespace();
      context = read_pattern(parser);
    } else {
      parser.index = /** @type {number} */
      expression.end;
    }
    parser.allow_whitespace();
    if (parser.eat(",")) {
      parser.allow_whitespace();
      index = parser.read_identifier();
      if (!index) {
        expected_identifier(parser.index);
      }
      parser.allow_whitespace();
    }
    if (parser.eat("(")) {
      parser.allow_whitespace();
      key2 = read_expression(parser, "(");
      parser.allow_whitespace();
      parser.eat(")", true);
      parser.allow_whitespace();
    }
    const matches = parser.eat("}", true, false);
    if (!matches) {
      if (parser.template.slice(parser.index - 4, parser.index) === " as ") {
        const prev_index = parser.index;
        context = read_pattern(parser);
        parser.eat("}", true);
        expression = {
          type: "Identifier",
          name: "",
          start: expression.start,
          end: prev_index - 4
        };
      } else {
        parser.eat("}", true);
      }
    }
    const block2 = parser.append({
      type: "EachBlock",
      start,
      end: -1,
      expression,
      body: create_fragment(),
      context,
      index,
      key: key2,
      metadata: (
        /** @type {any} */
        null
      )
      // filled in later
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.body);
    return;
  }
  if (parser.eat("await")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    const block2 = parser.append({
      type: "AwaitBlock",
      start,
      end: -1,
      expression,
      value: null,
      error: null,
      pending: null,
      then: null,
      catch: null
    });
    if (parser.eat("then")) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block2.value = read_pattern(parser);
        parser.allow_whitespace();
      }
      block2.then = create_fragment();
      parser.fragments.push(block2.then);
    } else if (parser.eat("catch")) {
      if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser.allow_whitespace();
      } else {
        parser.require_whitespace();
        block2.error = read_pattern(parser);
        parser.allow_whitespace();
      }
      block2.catch = create_fragment();
      parser.fragments.push(block2.catch);
    } else {
      block2.pending = create_fragment();
      parser.fragments.push(block2.pending);
    }
    const matches = parser.eat("}", true, false);
    if (!matches) {
      if (parser.template.slice(parser.index - 6, parser.index) === " then ") {
        const prev_index = parser.index;
        block2.value = read_pattern(parser);
        parser.eat("}", true);
        block2.expression = {
          type: "Identifier",
          name: "",
          start: expression.start,
          end: prev_index - 6
        };
        block2.then = block2.pending;
        block2.pending = null;
      } else if (parser.template.slice(parser.index - 7, parser.index) === " catch ") {
        const prev_index = parser.index;
        block2.error = read_pattern(parser);
        parser.eat("}", true);
        block2.expression = {
          type: "Identifier",
          name: "",
          start: expression.start,
          end: prev_index - 7
        };
        block2.catch = block2.pending;
        block2.pending = null;
      } else {
        parser.eat("}", true);
      }
    }
    parser.stack.push(block2);
    return;
  }
  if (parser.eat("key")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    const block2 = parser.append({
      type: "KeyBlock",
      start,
      end: -1,
      expression,
      fragment: create_fragment()
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.fragment);
    return;
  }
  if (parser.eat("snippet")) {
    parser.require_whitespace();
    const name_start = parser.index;
    let name = parser.read_identifier();
    const name_end = parser.index;
    if (name === null) {
      if (parser.loose) {
        name = "";
      } else {
        expected_identifier(parser.index);
      }
    }
    parser.allow_whitespace();
    const params_start = parser.index;
    const matched = parser.eat("(", true, false);
    if (matched) {
      let parentheses = 1;
      while (parser.index < parser.template.length && (!parser.match(")") || parentheses !== 1)) {
        if (parser.match("(")) parentheses++;
        if (parser.match(")")) parentheses--;
        parser.index += 1;
      }
      parser.eat(")", true);
    }
    const prelude = parser.template.slice(0, params_start).replace(/\S/g, " ");
    const params = parser.template.slice(params_start, parser.index);
    let function_expression = matched ? (
      /** @type {ArrowFunctionExpression} */
      parse_expression_at(prelude + `${params} => {}`, parser.ts, params_start)
    ) : { params: [] };
    parser.allow_whitespace();
    parser.eat("}", true);
    const block2 = parser.append({
      type: "SnippetBlock",
      start,
      end: -1,
      expression: {
        type: "Identifier",
        start: name_start,
        end: name_end,
        name
      },
      parameters: function_expression.params,
      body: create_fragment(),
      metadata: {
        can_hoist: false,
        sites: /* @__PURE__ */ new Set()
      }
    });
    parser.stack.push(block2);
    parser.fragments.push(block2.body);
    return;
  }
  expected_block_type(parser.index);
}
function next(parser) {
  const start = parser.index - 1;
  const block2 = parser.current();
  if (block2.type === "IfBlock") {
    if (!parser.eat("else")) expected_token(start, "{:else} or {:else if}");
    if (parser.eat("if")) block_invalid_elseif(start);
    parser.allow_whitespace();
    parser.fragments.pop();
    block2.alternate = create_fragment();
    parser.fragments.push(block2.alternate);
    if (parser.eat("if")) {
      parser.require_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      let elseif_start = start - 1;
      while (parser.template[elseif_start] !== "{") elseif_start -= 1;
      const child = parser.append({
        start: elseif_start,
        end: -1,
        type: "IfBlock",
        elseif: true,
        test: expression,
        consequent: create_fragment(),
        alternate: null
      });
      parser.stack.push(child);
      parser.fragments.pop();
      parser.fragments.push(child.consequent);
    } else {
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    return;
  }
  if (block2.type === "EachBlock") {
    if (!parser.eat("else")) expected_token(start, "{:else}");
    parser.allow_whitespace();
    parser.eat("}", true);
    block2.fallback = create_fragment();
    parser.fragments.pop();
    parser.fragments.push(block2.fallback);
    return;
  }
  if (block2.type === "AwaitBlock") {
    if (parser.eat("then")) {
      if (block2.then) {
        block_duplicate_clause(start, "{:then}");
      }
      if (!parser.eat("}")) {
        parser.require_whitespace();
        block2.value = read_pattern(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      block2.then = create_fragment();
      parser.fragments.pop();
      parser.fragments.push(block2.then);
      return;
    }
    if (parser.eat("catch")) {
      if (block2.catch) {
        block_duplicate_clause(start, "{:catch}");
      }
      if (!parser.eat("}")) {
        parser.require_whitespace();
        block2.error = read_pattern(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      block2.catch = create_fragment();
      parser.fragments.pop();
      parser.fragments.push(block2.catch);
      return;
    }
    expected_token(start, "{:then ...} or {:catch ...}");
  }
  block_invalid_continuation_placement(start);
}
function close(parser) {
  const start = parser.index - 1;
  let block2 = parser.current();
  let matched;
  switch (block2.type) {
    case "IfBlock":
      matched = parser.eat("if", true, false);
      if (!matched) {
        block2.end = start - 1;
        parser.pop();
        close(parser);
        return;
      }
      parser.allow_whitespace();
      parser.eat("}", true);
      while (block2.elseif) {
        block2.end = parser.index;
        parser.stack.pop();
        block2 = /** @type {AST.IfBlock} */
        parser.current();
      }
      block2.end = parser.index;
      parser.pop();
      return;
    case "EachBlock":
      matched = parser.eat("each", true, false);
      break;
    case "KeyBlock":
      matched = parser.eat("key", true, false);
      break;
    case "AwaitBlock":
      matched = parser.eat("await", true, false);
      break;
    case "SnippetBlock":
      matched = parser.eat("snippet", true, false);
      break;
    case "RegularElement":
      if (parser.loose) {
        matched = false;
      } else {
        block_unexpected_close(start);
      }
      break;
    default:
      block_unexpected_close(start);
  }
  if (!matched) {
    block2.end = start - 1;
    parser.pop();
    close(parser);
    return;
  }
  parser.allow_whitespace();
  parser.eat("}", true);
  block2.end = parser.index;
  parser.pop();
}
function special(parser) {
  let start = parser.index;
  while (parser.template[start] !== "{") start -= 1;
  if (parser.eat("html")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "HtmlTag",
      start,
      end: parser.index,
      expression
    });
    return;
  }
  if (parser.eat("debug")) {
    let identifiers;
    if (parser.read(regex_whitespace_with_closing_curly_brace)) {
      identifiers = [];
    } else {
      const expression = read_expression(parser);
      identifiers = expression.type === "SequenceExpression" ? (
        /** @type {Identifier[]} */
        expression.expressions
      ) : [
        /** @type {Identifier} */
        expression
      ];
      identifiers.forEach(
        /** @param {any} node */
        (node) => {
          if (node.type !== "Identifier") {
            debug_tag_invalid_arguments(
              /** @type {number} */
              node.start
            );
          }
        }
      );
      parser.allow_whitespace();
      parser.eat("}", true);
    }
    parser.append({
      type: "DebugTag",
      start,
      end: parser.index,
      identifiers
    });
    return;
  }
  if (parser.eat("const")) {
    parser.require_whitespace();
    const id2 = read_pattern(parser);
    parser.allow_whitespace();
    parser.eat("=", true);
    parser.allow_whitespace();
    const expression_start = parser.index;
    const init2 = read_expression(parser);
    if (init2.type === "SequenceExpression" && !parser.template.substring(expression_start, init2.start).includes("(")) {
      const_tag_invalid_expression(init2);
    }
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "ConstTag",
      start,
      end: parser.index,
      declaration: {
        type: "VariableDeclaration",
        kind: "const",
        declarations: [{ type: "VariableDeclarator", id: id2, init: init2, start: id2.start, end: init2.end }],
        start: start + 2,
        // start at const, not at @const
        end: parser.index - 1
      }
    });
  }
  if (parser.eat("render")) {
    parser.require_whitespace();
    const expression = read_expression(parser);
    if (expression.type !== "CallExpression" && (expression.type !== "ChainExpression" || expression.expression.type !== "CallExpression")) {
      render_tag_invalid_expression(expression);
    }
    parser.allow_whitespace();
    parser.eat("}", true);
    parser.append({
      type: "RenderTag",
      start,
      end: parser.index,
      expression: (
        /** @type {AST.RenderTag['expression']} */
        expression
      ),
      metadata: {
        dynamic: false,
        arguments: [],
        path: [],
        snippets: /* @__PURE__ */ new Set()
      }
    });
  }
}

// node_modules/svelte/src/compiler/phases/1-parse/state/text.js
function text(parser) {
  const start = parser.index;
  let data = "";
  while (parser.index < parser.template.length && !parser.match("<") && !parser.match("{")) {
    data += parser.template[parser.index++];
  }
  parser.append({
    type: "Text",
    start,
    end: parser.index,
    raw: data,
    data: decode_character_references(data, false)
  });
}

// node_modules/svelte/src/compiler/phases/1-parse/state/fragment.js
function fragment(parser) {
  if (parser.match("<")) {
    return element;
  }
  if (parser.match("{")) {
    return tag;
  }
  return text;
}

// node_modules/svelte/src/compiler/phases/1-parse/read/options.js
function read_options(node) {
  var _a2, _b, _c, _d;
  const component_options = {
    start: node.start,
    end: node.end,
    // @ts-ignore
    attributes: node.attributes
  };
  if (!node) {
    return component_options;
  }
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") {
      svelte_options_invalid_attribute(attribute);
    }
    const { name } = attribute;
    switch (name) {
      case "runes": {
        component_options.runes = get_boolean_value(attribute);
        break;
      }
      case "tag": {
        svelte_options_deprecated_tag(attribute);
        break;
      }
      case "customElement": {
        const ce = {};
        const { value: v } = attribute;
        const value = v === true || Array.isArray(v) ? v : [v];
        if (value === true) {
          svelte_options_invalid_customelement(attribute);
        } else if (value[0].type === "Text") {
          const tag3 = get_static_value(attribute);
          validate_tag(attribute, tag3);
          ce.tag = tag3;
          component_options.customElement = ce;
          break;
        } else if (value[0].expression.type !== "ObjectExpression") {
          if (value[0].expression.type === "Literal" && value[0].expression.value === null) {
            break;
          }
          svelte_options_invalid_customelement(attribute);
        }
        const properties = [];
        for (const property of value[0].expression.properties) {
          if (property.type !== "Property" || property.computed || property.key.type !== "Identifier") {
            svelte_options_invalid_customelement(attribute);
          }
          properties.push([property.key.name, property.value]);
        }
        const tag2 = properties.find(([name2]) => name2 === "tag");
        if (tag2) {
          const tag_value = (_a2 = tag2[1]) == null ? void 0 : _a2.value;
          validate_tag(tag2, tag_value);
          ce.tag = tag_value;
        }
        const props = (_b = properties.find(([name2]) => name2 === "props")) == null ? void 0 : _b[1];
        if (props) {
          if (props.type !== "ObjectExpression") {
            svelte_options_invalid_customelement_props(attribute);
          }
          ce.props = {};
          for (
            const property of
            /** @type {ObjectExpression} */
            props.properties
          ) {
            if (property.type !== "Property" || property.computed || property.key.type !== "Identifier" || property.value.type !== "ObjectExpression") {
              svelte_options_invalid_customelement_props(attribute);
            }
            ce.props[property.key.name] = {};
            for (const prop2 of property.value.properties) {
              if (prop2.type !== "Property" || prop2.computed || prop2.key.type !== "Identifier" || prop2.value.type !== "Literal") {
                svelte_options_invalid_customelement_props(attribute);
              }
              if (prop2.key.name === "type") {
                if (["String", "Number", "Boolean", "Array", "Object"].indexOf(
                  /** @type {string} */
                  prop2.value.value
                ) === -1) {
                  svelte_options_invalid_customelement_props(attribute);
                }
                ce.props[property.key.name].type = /** @type {any} */
                prop2.value.value;
              } else if (prop2.key.name === "reflect") {
                if (typeof prop2.value.value !== "boolean") {
                  svelte_options_invalid_customelement_props(attribute);
                }
                ce.props[property.key.name].reflect = prop2.value.value;
              } else if (prop2.key.name === "attribute") {
                if (typeof prop2.value.value !== "string") {
                  svelte_options_invalid_customelement_props(attribute);
                }
                ce.props[property.key.name].attribute = prop2.value.value;
              } else {
                svelte_options_invalid_customelement_props(attribute);
              }
            }
          }
        }
        const shadow = (_c = properties.find(([name2]) => name2 === "shadow")) == null ? void 0 : _c[1];
        if (shadow) {
          const shadowdom = shadow == null ? void 0 : shadow.value;
          if (shadowdom !== "open" && shadowdom !== "none") {
            svelte_options_invalid_customelement_shadow(shadow);
          }
          ce.shadow = shadowdom;
        }
        const extend = (_d = properties.find(([name2]) => name2 === "extend")) == null ? void 0 : _d[1];
        if (extend) {
          ce.extend = extend;
        }
        component_options.customElement = ce;
        break;
      }
      case "namespace": {
        const value = get_static_value(attribute);
        if (value === NAMESPACE_SVG) {
          component_options.namespace = "svg";
        } else if (value === NAMESPACE_MATHML) {
          component_options.namespace = "mathml";
        } else if (value === "html" || value === "mathml" || value === "svg") {
          component_options.namespace = value;
        } else {
          svelte_options_invalid_attribute_value(attribute, `"html", "mathml" or "svg"`);
        }
        break;
      }
      case "css": {
        const value = get_static_value(attribute);
        if (value === "injected") {
          component_options.css = value;
        } else {
          svelte_options_invalid_attribute_value(attribute, `"injected"`);
        }
        break;
      }
      case "immutable": {
        component_options.immutable = get_boolean_value(attribute);
        break;
      }
      case "preserveWhitespace": {
        component_options.preserveWhitespace = get_boolean_value(attribute);
        break;
      }
      case "accessors": {
        component_options.accessors = get_boolean_value(attribute);
        break;
      }
      default:
        svelte_options_unknown_attribute(attribute, name);
    }
  }
  return component_options;
}
function get_static_value(attribute) {
  const { value } = attribute;
  if (value === true) return true;
  const chunk = Array.isArray(value) ? value[0] : value;
  if (!chunk) return true;
  if (value.length > 1) {
    return null;
  }
  if (chunk.type === "Text") return chunk.data;
  if (chunk.expression.type !== "Literal") {
    return null;
  }
  return chunk.expression.value;
}
function get_boolean_value(attribute) {
  const value = get_static_value(attribute);
  if (typeof value !== "boolean") {
    svelte_options_invalid_attribute_value(attribute, "true or false");
  }
  return value;
}
var tag_name_char = "[a-z0-9_.·À-ÖØ-öø-ͽͿ-῿‌-‍‿-⁀⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿-]";
var regex_valid_tag_name = new RegExp(`^[a-z]${tag_name_char}*-${tag_name_char}*$`, "u");
var reserved_tag_names = [
  "annotation-xml",
  "color-profile",
  "font-face",
  "font-face-src",
  "font-face-uri",
  "font-face-format",
  "font-face-name",
  "missing-glyph"
];
function validate_tag(attribute, tag2) {
  if (typeof tag2 !== "string") {
    svelte_options_invalid_tagname(attribute);
  }
  if (tag2) {
    if (!regex_valid_tag_name.test(tag2)) {
      svelte_options_invalid_tagname(attribute);
    } else if (reserved_tag_names.includes(tag2)) {
      svelte_options_reserved_tagname(attribute);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/special-element.js
function disallow_children(node) {
  const { nodes } = node.fragment;
  if (nodes.length > 0) {
    const first = nodes[0];
    const last = nodes[nodes.length - 1];
    svelte_meta_invalid_content({ start: first.start, end: last.end }, node.name);
  }
}

// node_modules/svelte/src/compiler/phases/1-parse/index.js
var regex_position_indicator = / \(\d+:\d+\)$/;
var regex_lang_attribute = /<!--[^]*?-->|<script\s+(?:[^>]*|(?:[^=>'"/]+=(?:"[^"]*"|'[^']*'|[^>\s]+)\s+)*)lang=(["'])?([^"' >]+)\1[^>]*>/g;
var Parser2 = class {
  /**
   * @param {string} template
   * @param {boolean} loose
   */
  constructor(template3, loose) {
    /**
     * @readonly
     * @type {string}
     */
    __publicField(this, "template");
    /**
     * @readonly
     * @type {string}
     */
    __publicField(this, "template_untrimmed");
    /**
     * Whether or not we're in loose parsing mode, in which
     * case we try to continue parsing as much as possible
     * @type {boolean}
     */
    __publicField(this, "loose");
    /** */
    __publicField(this, "index", 0);
    /** Whether we're parsing in TypeScript mode */
    __publicField(this, "ts", false);
    /** @type {AST.TemplateNode[]} */
    __publicField(this, "stack", []);
    /** @type {AST.Fragment[]} */
    __publicField(this, "fragments", []);
    /** @type {AST.Root} */
    __publicField(this, "root");
    /** @type {Record<string, boolean>} */
    __publicField(this, "meta_tags", {});
    /** @type {LastAutoClosedTag | undefined} */
    __publicField(this, "last_auto_closed_tag");
    if (typeof template3 !== "string") {
      throw new TypeError("Template must be a string");
    }
    this.loose = loose;
    this.template_untrimmed = template3;
    this.template = template3.trimEnd();
    let match_lang;
    do
      match_lang = regex_lang_attribute.exec(template3);
    while (match_lang && match_lang[0][1] !== "s");
    regex_lang_attribute.lastIndex = 0;
    this.ts = (match_lang == null ? void 0 : match_lang[2]) === "ts";
    this.root = {
      css: null,
      js: [],
      // @ts-ignore
      start: null,
      // @ts-ignore
      end: null,
      type: "Root",
      fragment: create_fragment(),
      options: null,
      metadata: {
        ts: this.ts
      }
    };
    this.stack.push(this.root);
    this.fragments.push(this.root.fragment);
    let state = fragment;
    while (this.index < this.template.length) {
      state = state(this) || fragment;
    }
    if (this.stack.length > 1) {
      const current = this.current();
      if (this.loose) {
        current.end = this.template.length;
      } else if (current.type === "RegularElement") {
        current.end = current.start + 1;
        element_unclosed(current, current.name);
      } else {
        current.end = current.start + 1;
        block_unclosed(current);
      }
    }
    if (state !== fragment) {
      unexpected_eof(this.index);
    }
    if (this.root.fragment.nodes.length) {
      let start = (
        /** @type {number} */
        this.root.fragment.nodes[0].start
      );
      while (regex_whitespace.test(template3[start])) start += 1;
      let end = (
        /** @type {number} */
        this.root.fragment.nodes[this.root.fragment.nodes.length - 1].end
      );
      while (regex_whitespace.test(template3[end - 1])) end -= 1;
      this.root.start = start;
      this.root.end = end;
    } else {
      this.root.start = this.root.end = null;
    }
    const options_index = this.root.fragment.nodes.findIndex(
      /** @param {any} thing */
      (thing) => thing.type === "SvelteOptions"
    );
    if (options_index !== -1) {
      const options = (
        /** @type {AST.SvelteOptionsRaw} */
        this.root.fragment.nodes[options_index]
      );
      this.root.fragment.nodes.splice(options_index, 1);
      this.root.options = read_options(options);
      disallow_children(options);
      Object.defineProperty(this.root.options, "__raw__", {
        value: options,
        enumerable: false
      });
    }
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  /**
   * @param {any} err
   * @returns {never}
   */
  acorn_error(err) {
    js_parse_error(err.pos, err.message.replace(regex_position_indicator, ""));
  }
  /**
   * @param {string} str
   * @param {boolean} required
   * @param {boolean} required_in_loose
   */
  eat(str, required = false, required_in_loose = true) {
    if (this.match(str)) {
      this.index += str.length;
      return true;
    }
    if (required && (!this.loose || required_in_loose)) {
      expected_token(this.index, str);
    }
    return false;
  }
  /** @param {string} str */
  match(str) {
    const length = str.length;
    if (length === 1) {
      return this.template[this.index] === str;
    }
    return this.template.slice(this.index, this.index + length) === str;
  }
  /**
   * Match a regex at the current index
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  match_regex(pattern) {
    const match = pattern.exec(this.template.slice(this.index));
    if (!match || match.index !== 0) return null;
    return match[0];
  }
  allow_whitespace() {
    while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
      this.index++;
    }
  }
  /**
   * Search for a regex starting at the current index and return the result if it matches
   * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
   */
  read(pattern) {
    const result = this.match_regex(pattern);
    if (result) this.index += result.length;
    return result;
  }
  /** @param {any} allow_reserved */
  read_identifier(allow_reserved = false) {
    const start = this.index;
    let i = this.index;
    const code = (
      /** @type {number} */
      this.template.codePointAt(i)
    );
    if (!isIdentifierStart(code, true)) return null;
    i += code <= 65535 ? 1 : 2;
    while (i < this.template.length) {
      const code2 = (
        /** @type {number} */
        this.template.codePointAt(i)
      );
      if (!isIdentifierChar(code2, true)) break;
      i += code2 <= 65535 ? 1 : 2;
    }
    const identifier = this.template.slice(this.index, this.index = i);
    if (!allow_reserved && is_reserved(identifier)) {
      unexpected_reserved_word(start, identifier);
    }
    return identifier;
  }
  /** @param {RegExp} pattern */
  read_until(pattern) {
    if (this.index >= this.template.length) {
      if (this.loose) return "";
      unexpected_eof(this.template.length);
    }
    const start = this.index;
    const match = pattern.exec(this.template.slice(start));
    if (match) {
      this.index = start + match.index;
      return this.template.slice(start, this.index);
    }
    this.index = this.template.length;
    return this.template.slice(start);
  }
  require_whitespace() {
    if (!regex_whitespace.test(this.template[this.index])) {
      expected_whitespace(this.index);
    }
    this.allow_whitespace();
  }
  pop() {
    this.fragments.pop();
    return this.stack.pop();
  }
  /**
   * @template {AST.Fragment['nodes'][number]} T
   * @param {T} node
   * @returns {T}
   */
  append(node) {
    var _a2;
    (_a2 = this.fragments.at(-1)) == null ? void 0 : _a2.nodes.push(node);
    return node;
  }
};
function parse2(template3, loose = false) {
  const parser = new Parser2(template3, loose);
  return parser.root;
}

// node_modules/svelte/src/compiler/phases/1-parse/remove_typescript_nodes.js
function remove_this_param(node, context) {
  var _a2;
  if (((_a2 = node.params[0]) == null ? void 0 : _a2.type) === "Identifier" && node.params[0].name === "this") {
    node.params.shift();
  }
  return context.next();
}
var visitors = {
  _(node, context) {
    const n = context.next() ?? node;
    delete n.typeAnnotation;
    delete n.typeParameters;
    delete n.typeArguments;
    delete n.returnType;
    delete n.accessibility;
  },
  Decorator(node) {
    typescript_invalid_feature(node, "decorators (related TSC proposal is not stage 4 yet)");
  },
  ImportDeclaration(node) {
    var _a2;
    if (node.importKind === "type") return empty;
    if (((_a2 = node.specifiers) == null ? void 0 : _a2.length) > 0) {
      const specifiers = node.specifiers.filter((s) => s.importKind !== "type");
      if (specifiers.length === 0) return empty;
      return { ...node, specifiers };
    }
    return node;
  },
  ExportNamedDeclaration(node, context) {
    var _a2;
    if (node.exportKind === "type") return empty;
    if (node.declaration) {
      const result = context.next();
      if (((_a2 = result == null ? void 0 : result.declaration) == null ? void 0 : _a2.type) === "EmptyStatement") {
        return empty;
      }
      return result;
    }
    if (node.specifiers) {
      const specifiers = node.specifiers.filter((s) => s.exportKind !== "type");
      if (specifiers.length === 0) return empty;
      return { ...node, specifiers };
    }
    return node;
  },
  ExportDefaultDeclaration(node) {
    if (node.exportKind === "type") return empty;
    return node;
  },
  ExportAllDeclaration(node) {
    if (node.exportKind === "type") return empty;
    return node;
  },
  PropertyDefinition(node, { next: next2 }) {
    if (node.accessor) {
      typescript_invalid_feature(
        node,
        "accessor fields (related TSC proposal is not stage 4 yet)"
      );
    }
    return next2();
  },
  TSAsExpression(node, context) {
    return context.visit(node.expression);
  },
  TSSatisfiesExpression(node, context) {
    return context.visit(node.expression);
  },
  TSNonNullExpression(node, context) {
    return context.visit(node.expression);
  },
  TSInterfaceDeclaration() {
    return empty;
  },
  TSTypeAliasDeclaration() {
    return empty;
  },
  TSTypeAssertion(node, context) {
    return context.visit(node.expression);
  },
  TSEnumDeclaration(node) {
    typescript_invalid_feature(node, "enums");
  },
  TSParameterProperty(node, context) {
    var _a2;
    if ((node.readonly || node.accessibility) && ((_a2 = context.path.at(-2)) == null ? void 0 : _a2.kind) === "constructor") {
      typescript_invalid_feature(node, "accessibility modifiers on constructor parameters");
    }
    return context.visit(node.parameter);
  },
  TSInstantiationExpression(node, context) {
    return context.visit(node.expression);
  },
  FunctionExpression: remove_this_param,
  FunctionDeclaration: remove_this_param,
  TSDeclareFunction() {
    return empty;
  },
  ClassDeclaration(node, context) {
    if (node.declare) {
      return empty;
    }
    delete node.implements;
    return context.next();
  },
  MethodDefinition(node, context) {
    if (node.abstract) {
      return empty;
    }
    return context.next();
  },
  VariableDeclaration(node, context) {
    if (node.declare) {
      return empty;
    }
    return context.next();
  },
  TSModuleDeclaration(node, context) {
    if (!node.body) return empty;
    const cleaned = (
      /** @type {any[]} */
      node.body.body.map((entry) => context.visit(entry))
    );
    if (cleaned.some((entry) => entry !== empty)) {
      typescript_invalid_feature(node, "namespaces with non-type nodes");
    }
    return empty;
  }
};
function remove_typescript_nodes(ast) {
  return walk(ast, null, visitors);
}

// node_modules/svelte/src/compiler/utils/slot.js
function determine_slot(node) {
  if (!is_element_node(node)) return null;
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") continue;
    if (attribute.name !== "slot") continue;
    if (!is_text_attribute(attribute)) continue;
    return (
      /** @type {string} */
      attribute.value[0].data
    );
  }
  return null;
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/utils.js
function validate_assignment(node, argument, state) {
  validate_no_const_assignment(node, argument, state.scope, node.type === "BindDirective");
  if (argument.type === "Identifier") {
    const binding = state.scope.get(argument.name);
    if (state.analysis.runes) {
      if ((binding == null ? void 0 : binding.node) === state.analysis.props_id) {
        constant_assignment(node, "$props.id()");
      }
      if ((binding == null ? void 0 : binding.kind) === "each") {
        each_item_invalid_assignment(node);
      }
    }
    if ((binding == null ? void 0 : binding.kind) === "snippet") {
      snippet_parameter_assignment(node);
    }
  }
}
function validate_no_const_assignment(node, argument, scope, is_binding) {
  if (argument.type === "ArrayPattern") {
    for (const element2 of argument.elements) {
      if (element2) {
        validate_no_const_assignment(node, element2, scope, is_binding);
      }
    }
  } else if (argument.type === "ObjectPattern") {
    for (const element2 of argument.properties) {
      if (element2.type === "Property") {
        validate_no_const_assignment(node, element2.value, scope, is_binding);
      }
    }
  } else if (argument.type === "Identifier") {
    const binding = scope.get(argument.name);
    if ((binding == null ? void 0 : binding.declaration_kind) === "import" || (binding == null ? void 0 : binding.declaration_kind) === "const" && binding.kind !== "each") {
      const thing = binding.declaration_kind === "import" ? "import" : "constant";
      if (is_binding) {
        constant_binding(node, thing);
      } else {
        constant_assignment(node, thing);
      }
    }
  }
}
function validate_opening_tag(node, state, expected) {
  if (state.analysis.source[node.start + 1] !== expected) {
    block_unexpected_character({ start: node.start, end: node.start + 5 }, expected);
  }
}
function validate_block_not_empty(node, context) {
  if (!node) return;
  if (node.nodes.length === 1 && node.nodes[0].type === "Text" && !node.nodes[0].raw.trim()) {
    block_empty(node.nodes[0]);
  }
}
function ensure_no_module_import_conflict(node, state) {
  var _a2;
  const ids = extract_identifiers(node.id);
  for (const id2 of ids) {
    if (state.ast_type === "instance" && state.scope === state.analysis.instance.scope && ((_a2 = state.analysis.module.scope.get(id2.name)) == null ? void 0 : _a2.declaration_kind) === "import") {
      declaration_duplicate_module_import(node.id);
    }
  }
}
function is_safe_identifier(expression, scope) {
  let node = expression;
  while (node.type === "MemberExpression") node = node.object;
  if (node.type !== "Identifier") return false;
  const binding = scope.get(node.name);
  if (!binding) return true;
  if (binding.kind === "store_sub") {
    return is_safe_identifier({ name: node.name.slice(1), type: "Identifier" }, scope);
  }
  return binding.declaration_kind !== "import" && binding.kind !== "prop" && binding.kind !== "bindable_prop" && binding.kind !== "rest_prop";
}
function is_pure(node, context) {
  if (node.type === "Literal") {
    return true;
  }
  if (node.type === "CallExpression") {
    if (!is_pure(node.callee, context)) {
      return false;
    }
    for (let arg of node.arguments) {
      if (!is_pure(arg.type === "SpreadElement" ? arg.argument : arg, context)) {
        return false;
      }
    }
    return true;
  }
  if (node.type !== "Identifier" && node.type !== "MemberExpression") {
    return false;
  }
  if (get_rune(call(node), context.state.scope) === "$effect.tracking") {
    return false;
  }
  let left = node;
  while (left.type === "MemberExpression") {
    left = left.object;
  }
  if (!left) return false;
  if (left.type === "Identifier") {
    const binding = context.state.scope.get(left.name);
    if (binding === null) return true;
  } else if (is_pure(left, context)) {
    return true;
  }
  return false;
}
function validate_identifier_name(binding, function_depth) {
  var _a2;
  if (!binding) return;
  const declaration_kind = binding.declaration_kind;
  if (declaration_kind !== "synthetic" && declaration_kind !== "param" && declaration_kind !== "rest_param" && (!function_depth || function_depth <= 1)) {
    const node = binding.node;
    if (node.name === "$") {
      dollar_binding_invalid(node);
    } else if (node.name.startsWith("$") && // import type { $Type } from "" - these are normally already filtered out,
    // but for the migration they aren't, and throwing here is preventing the migration to complete
    // TODO -> once migration script is gone we can remove this check
    !(((_a2 = binding.initial) == null ? void 0 : _a2.type) === "ImportDeclaration" && /** @type {any} */
    binding.initial.importKind === "type")) {
      dollar_prefix_invalid(node);
    }
  }
}
function validate_export(node, scope, name) {
  const binding = scope.get(name);
  if (!binding) return;
  if (binding.kind === "derived") {
    derived_invalid_export(node);
  }
  if ((binding.kind === "state" || binding.kind === "raw_state") && binding.reassigned) {
    state_invalid_export(node);
  }
}

// node_modules/svelte/src/compiler/phases/scope.js
var UNKNOWN = Symbol("unknown");
var NUMBER = Symbol("number");
var STRING = Symbol("string");
var globals = {
  BigInt: [NUMBER],
  "Math.min": [NUMBER, Math.min],
  "Math.max": [NUMBER, Math.max],
  "Math.random": [NUMBER],
  "Math.floor": [NUMBER, Math.floor],
  // @ts-ignore
  "Math.f16round": [NUMBER, Math.f16round],
  "Math.round": [NUMBER, Math.round],
  "Math.abs": [NUMBER, Math.abs],
  "Math.acos": [NUMBER, Math.acos],
  "Math.asin": [NUMBER, Math.asin],
  "Math.atan": [NUMBER, Math.atan],
  "Math.atan2": [NUMBER, Math.atan2],
  "Math.ceil": [NUMBER, Math.ceil],
  "Math.cos": [NUMBER, Math.cos],
  "Math.sin": [NUMBER, Math.sin],
  "Math.tan": [NUMBER, Math.tan],
  "Math.exp": [NUMBER, Math.exp],
  "Math.log": [NUMBER, Math.log],
  "Math.pow": [NUMBER, Math.pow],
  "Math.sqrt": [NUMBER, Math.sqrt],
  "Math.clz32": [NUMBER, Math.clz32],
  "Math.imul": [NUMBER, Math.imul],
  "Math.sign": [NUMBER, Math.sign],
  "Math.log10": [NUMBER, Math.log10],
  "Math.log2": [NUMBER, Math.log2],
  "Math.log1p": [NUMBER, Math.log1p],
  "Math.expm1": [NUMBER, Math.expm1],
  "Math.cosh": [NUMBER, Math.cosh],
  "Math.sinh": [NUMBER, Math.sinh],
  "Math.tanh": [NUMBER, Math.tanh],
  "Math.acosh": [NUMBER, Math.acosh],
  "Math.asinh": [NUMBER, Math.asinh],
  "Math.atanh": [NUMBER, Math.atanh],
  "Math.trunc": [NUMBER, Math.trunc],
  "Math.fround": [NUMBER, Math.fround],
  "Math.cbrt": [NUMBER, Math.cbrt],
  Number: [NUMBER, Number],
  "Number.isInteger": [NUMBER, Number.isInteger],
  "Number.isFinite": [NUMBER, Number.isFinite],
  "Number.isNaN": [NUMBER, Number.isNaN],
  "Number.isSafeInteger": [NUMBER, Number.isSafeInteger],
  "Number.parseFloat": [NUMBER, Number.parseFloat],
  "Number.parseInt": [NUMBER, Number.parseInt],
  String: [STRING, String],
  "String.fromCharCode": [STRING, String.fromCharCode],
  "String.fromCodePoint": [STRING, String.fromCodePoint]
};
var global_constants = {
  "Math.PI": Math.PI,
  "Math.E": Math.E,
  "Math.LN10": Math.LN10,
  "Math.LN2": Math.LN2,
  "Math.LOG10E": Math.LOG10E,
  "Math.LOG2E": Math.LOG2E,
  "Math.SQRT2": Math.SQRT2,
  "Math.SQRT1_2": Math.SQRT1_2
};
var Binding = class {
  /**
   *
   * @param {Scope} scope
   * @param {Identifier} node
   * @param {BindingKind} kind
   * @param {DeclarationKind} declaration_kind
   * @param {Binding['initial']} initial
   */
  constructor(scope, node, kind, declaration_kind, initial) {
    /** @type {Scope} */
    __publicField(this, "scope");
    /** @type {Identifier} */
    __publicField(this, "node");
    /** @type {BindingKind} */
    __publicField(this, "kind");
    /** @type {DeclarationKind} */
    __publicField(this, "declaration_kind");
    /**
     * What the value was initialized with.
     * For destructured props such as `let { foo = 'bar' } = $props()` this is `'bar'` and not `$props()`
     * @type {null | Expression | FunctionDeclaration | ClassDeclaration | ImportDeclaration | AST.EachBlock | AST.SnippetBlock}
     */
    __publicField(this, "initial", null);
    /** @type {Array<{ node: Identifier; path: AST.SvelteNode[] }>} */
    __publicField(this, "references", []);
    /**
     * For `legacy_reactive`: its reactive dependencies
     * @type {Binding[]}
     */
    __publicField(this, "legacy_dependencies", []);
    /**
     * Legacy props: the `class` in `{ export klass as class}`. $props(): The `class` in { class: klass } = $props()
     * @type {string | null}
     */
    __publicField(this, "prop_alias", null);
    /**
     * Additional metadata, varies per binding type
     * @type {null | { inside_rest?: boolean }}
     */
    __publicField(this, "metadata", null);
    __publicField(this, "mutated", false);
    __publicField(this, "reassigned", false);
    this.scope = scope;
    this.node = node;
    this.initial = initial;
    this.kind = kind;
    this.declaration_kind = declaration_kind;
  }
  get updated() {
    return this.mutated || this.reassigned;
  }
  /**
   * @returns {this is Binding & { initial: ArrowFunctionExpression | FunctionDeclaration | FunctionExpression }}
   */
  is_function() {
    var _a2;
    if (this.updated) {
      return false;
    }
    const type = (_a2 = this.initial) == null ? void 0 : _a2.type;
    return type === "ArrowFunctionExpression" || type === "FunctionExpression" || type === "FunctionDeclaration";
  }
};
var Evaluation = class {
  /**
   *
   * @param {Scope} scope
   * @param {Expression} expression
   * @param {Set<any>} values
   */
  constructor(scope, expression, values) {
    /** @type {Set<any>} */
    __publicField(this, "values");
    /**
     * True if there is exactly one possible value
     * @readonly
     * @type {boolean}
     */
    __publicField(this, "is_known", true);
    /**
     * True if the value is known to not be null/undefined
     * @readonly
     * @type {boolean}
     */
    __publicField(this, "is_defined", true);
    /**
     * True if the value is known to be a string
     * @readonly
     * @type {boolean}
     */
    __publicField(this, "is_string", true);
    /**
     * True if the value is known to be a number
     * @readonly
     * @type {boolean}
     */
    __publicField(this, "is_number", true);
    /**
     * @readonly
     * @type {any}
     */
    __publicField(this, "value");
    var _a2, _b;
    this.values = values;
    switch (expression.type) {
      case "Literal": {
        this.values.add(expression.value);
        break;
      }
      case "Identifier": {
        const binding = scope.get(expression.name);
        if (binding) {
          if (((_a2 = binding.initial) == null ? void 0 : _a2.type) === "CallExpression" && get_rune(binding.initial, scope) === "$props.id") {
            this.values.add(STRING);
            break;
          }
          const is_prop = binding.kind === "prop" || binding.kind === "rest_prop" || binding.kind === "bindable_prop";
          if (((_b = binding.initial) == null ? void 0 : _b.type) === "EachBlock" && binding.initial.index === expression.name) {
            this.values.add(NUMBER);
            break;
          }
          if (!binding.updated && binding.initial !== null && !is_prop) {
            binding.scope.evaluate(
              /** @type {Expression} */
              binding.initial,
              this.values
            );
            break;
          }
        } else if (expression.name === "undefined") {
          this.values.add(void 0);
          break;
        }
        this.values.add(UNKNOWN);
        break;
      }
      case "BinaryExpression": {
        const a = scope.evaluate(
          /** @type {Expression} */
          expression.left
        );
        const b = scope.evaluate(expression.right);
        if (a.is_known && b.is_known) {
          this.values.add(binary2[expression.operator](a.value, b.value));
          break;
        }
        switch (expression.operator) {
          case "!=":
          case "!==":
          case "<":
          case "<=":
          case ">":
          case ">=":
          case "==":
          case "===":
          case "in":
          case "instanceof":
            this.values.add(true);
            this.values.add(false);
            break;
          case "%":
          case "&":
          case "*":
          case "**":
          case "-":
          case "/":
          case "<<":
          case ">>":
          case ">>>":
          case "^":
          case "|":
            this.values.add(NUMBER);
            break;
          case "+":
            if (a.is_string || b.is_string) {
              this.values.add(STRING);
            } else if (a.is_number && b.is_number) {
              this.values.add(NUMBER);
            } else {
              this.values.add(STRING);
              this.values.add(NUMBER);
            }
            break;
          default:
            this.values.add(UNKNOWN);
        }
        break;
      }
      case "ConditionalExpression": {
        const test = scope.evaluate(expression.test);
        const consequent = scope.evaluate(expression.consequent);
        const alternate = scope.evaluate(expression.alternate);
        if (test.is_known) {
          for (const value of (test.value ? consequent : alternate).values) {
            this.values.add(value);
          }
        } else {
          for (const value of consequent.values) {
            this.values.add(value);
          }
          for (const value of alternate.values) {
            this.values.add(value);
          }
        }
        break;
      }
      case "LogicalExpression": {
        const a = scope.evaluate(expression.left);
        const b = scope.evaluate(expression.right);
        if (a.is_known) {
          if (b.is_known) {
            this.values.add(logical2[expression.operator](a.value, b.value));
            break;
          }
          if (expression.operator === "&&" && !a.value || expression.operator === "||" && a.value || expression.operator === "??" && a.value != null) {
            this.values.add(a.value);
          } else {
            for (const value of b.values) {
              this.values.add(value);
            }
          }
          break;
        }
        for (const value of a.values) {
          this.values.add(value);
        }
        for (const value of b.values) {
          this.values.add(value);
        }
        break;
      }
      case "UnaryExpression": {
        const argument = scope.evaluate(expression.argument);
        if (argument.is_known) {
          this.values.add(unary2[expression.operator](argument.value));
          break;
        }
        switch (expression.operator) {
          case "!":
          case "delete":
            this.values.add(false);
            this.values.add(true);
            break;
          case "+":
          case "-":
          case "~":
            this.values.add(NUMBER);
            break;
          case "typeof":
            this.values.add(STRING);
            break;
          case "void":
            this.values.add(void 0);
            break;
          default:
            this.values.add(UNKNOWN);
        }
        break;
      }
      case "CallExpression": {
        const keypath = get_global_keypath(expression.callee, scope);
        if (keypath) {
          if (is_rune(keypath)) {
            const arg = (
              /** @type {Expression | undefined} */
              expression.arguments[0]
            );
            switch (keypath) {
              case "$state":
              case "$state.raw":
              case "$derived":
                if (arg) {
                  scope.evaluate(arg, this.values);
                } else {
                  this.values.add(void 0);
                }
                break;
              case "$props.id":
                this.values.add(STRING);
                break;
              case "$effect.tracking":
                this.values.add(false);
                this.values.add(true);
                break;
              case "$derived.by":
                if ((arg == null ? void 0 : arg.type) === "ArrowFunctionExpression" && arg.body.type !== "BlockStatement") {
                  scope.evaluate(arg.body, this.values);
                  break;
                }
                this.values.add(UNKNOWN);
                break;
              default: {
                this.values.add(UNKNOWN);
              }
            }
            break;
          }
          if (Object.hasOwn(globals, keypath) && expression.arguments.every((arg) => arg.type !== "SpreadElement")) {
            const [type, fn] = globals[keypath];
            const values2 = expression.arguments.map((arg) => scope.evaluate(arg));
            if (fn && values2.every((e2) => e2.is_known)) {
              this.values.add(fn(...values2.map((e2) => e2.value)));
            } else {
              this.values.add(type);
            }
            break;
          }
        }
        this.values.add(UNKNOWN);
        break;
      }
      case "TemplateLiteral": {
        let result = expression.quasis[0].value.cooked;
        for (let i = 0; i < expression.expressions.length; i += 1) {
          const e2 = scope.evaluate(expression.expressions[i]);
          if (e2.is_known) {
            result += e2.value + expression.quasis[i + 1].value.cooked;
          } else {
            this.values.add(STRING);
            break;
          }
        }
        this.values.add(result);
        break;
      }
      case "MemberExpression": {
        const keypath = get_global_keypath(expression, scope);
        if (keypath && Object.hasOwn(global_constants, keypath)) {
          this.values.add(global_constants[keypath]);
          break;
        }
        this.values.add(UNKNOWN);
        break;
      }
      default: {
        this.values.add(UNKNOWN);
      }
    }
    for (const value of this.values) {
      this.value = value;
      if (value !== STRING && typeof value !== "string") {
        this.is_string = false;
      }
      if (value !== NUMBER && typeof value !== "number") {
        this.is_number = false;
      }
      if (value == null || value === UNKNOWN) {
        this.is_defined = false;
      }
    }
    if (this.values.size > 1 || typeof this.value === "symbol") {
      this.is_known = false;
    }
  }
};
var _porous;
var _Scope = class _Scope {
  /**
   *
   * @param {ScopeRoot} root
   * @param {Scope | null} parent
   * @param {boolean} porous
   */
  constructor(root, parent, porous) {
    /** @type {ScopeRoot} */
    __publicField(this, "root");
    /**
     * The immediate parent scope
     * @type {Scope | null}
     */
    __publicField(this, "parent");
    /**
     * Whether or not `var` declarations are contained by this scope
     * @type {boolean}
     */
    __privateAdd(this, _porous);
    /**
     * A map of every identifier declared by this scope, and all the
     * identifiers that reference it
     * @type {Map<string, Binding>}
     */
    __publicField(this, "declarations", /* @__PURE__ */ new Map());
    /**
     * A map of declarators to the bindings they declare
     * @type {Map<VariableDeclarator | AST.LetDirective, Binding[]>}
     */
    __publicField(this, "declarators", /* @__PURE__ */ new Map());
    /**
     * A set of all the names referenced with this scope
     * — useful for generating unique names
     * @type {Map<string, { node: Identifier; path: AST.SvelteNode[] }[]>}
     */
    __publicField(this, "references", /* @__PURE__ */ new Map());
    /**
     * The scope depth allows us to determine if a state variable is referenced in its own scope,
     * which is usually an error. Block statements do not increase this value
     */
    __publicField(this, "function_depth", 0);
    /**
     * If tracing of reactive dependencies is enabled for this scope
     * @type {null | Expression}
     */
    __publicField(this, "tracing", null);
    this.root = root;
    this.parent = parent;
    __privateSet(this, _porous, porous);
    this.function_depth = parent ? parent.function_depth + (porous ? 0 : 1) : 0;
  }
  /**
   * @param {Identifier} node
   * @param {Binding['kind']} kind
   * @param {DeclarationKind} declaration_kind
   * @param {null | Expression | FunctionDeclaration | ClassDeclaration | ImportDeclaration | AST.EachBlock | AST.SnippetBlock} initial
   * @returns {Binding}
   */
  declare(node, kind, declaration_kind, initial = null) {
    if (this.parent) {
      if (declaration_kind === "var" && __privateGet(this, _porous)) {
        return this.parent.declare(node, kind, declaration_kind);
      }
      if (declaration_kind === "import") {
        return this.parent.declare(node, kind, declaration_kind, initial);
      }
    }
    if (this.declarations.has(node.name)) {
      const binding2 = this.declarations.get(node.name);
      if (binding2 && binding2.declaration_kind !== "var" && declaration_kind !== "var") {
        declaration_duplicate(node, node.name);
      }
    }
    const binding = new Binding(this, node, kind, declaration_kind, initial);
    validate_identifier_name(binding, this.function_depth);
    this.declarations.set(node.name, binding);
    this.root.conflicts.add(node.name);
    return binding;
  }
  child(porous = false) {
    return new _Scope(this.root, this, porous);
  }
  /**
   * @param {string} preferred_name
   * @returns {string}
   */
  generate(preferred_name) {
    if (__privateGet(this, _porous)) {
      return (
        /** @type {Scope} */
        this.parent.generate(preferred_name)
      );
    }
    preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, "_").replace(/^[0-9]/, "_");
    let name = preferred_name;
    let n = 1;
    while (this.references.has(name) || this.declarations.has(name) || this.root.conflicts.has(name) || is_reserved(name)) {
      name = `${preferred_name}_${n++}`;
    }
    this.references.set(name, []);
    this.root.conflicts.add(name);
    return name;
  }
  /**
   * @param {string} name
   * @returns {Binding | null}
   */
  get(name) {
    var _a2;
    return this.declarations.get(name) ?? ((_a2 = this.parent) == null ? void 0 : _a2.get(name)) ?? null;
  }
  /**
   * @param {VariableDeclarator | AST.LetDirective} node
   * @returns {Binding[]}
   */
  get_bindings(node) {
    const bindings = this.declarators.get(node);
    if (!bindings) {
      throw new Error("No binding found for declarator");
    }
    return bindings;
  }
  /**
   * @param {string} name
   * @returns {Scope | null}
   */
  owner(name) {
    return this.declarations.has(name) ? this : this.parent && this.parent.owner(name);
  }
  /**
   * @param {Identifier} node
   * @param {AST.SvelteNode[]} path
   */
  reference(node, path) {
    path = [...path];
    let references = this.references.get(node.name);
    if (!references) this.references.set(node.name, references = []);
    references.push({ node, path });
    const binding = this.declarations.get(node.name);
    if (binding) {
      binding.references.push({ node, path });
    } else if (this.parent) {
      this.parent.reference(node, path);
    } else {
      this.root.conflicts.add(node.name);
    }
  }
  /**
   * Does partial evaluation to find an exact value or at least the rough type of the expression.
   * Only call this once scope has been fully generated in a first pass,
   * else this evaluates on incomplete data and may yield wrong results.
   * @param {Expression} expression
   * @param {Set<any>} [values]
   */
  evaluate(expression, values = /* @__PURE__ */ new Set()) {
    return new Evaluation(this, expression, values);
  }
};
_porous = new WeakMap();
var Scope = _Scope;
var binary2 = {
  "!=": (left, right) => left != right,
  "!==": (left, right) => left !== right,
  "<": (left, right) => left < right,
  "<=": (left, right) => left <= right,
  ">": (left, right) => left > right,
  ">=": (left, right) => left >= right,
  "==": (left, right) => left == right,
  "===": (left, right) => left === right,
  in: (left, right) => left in right,
  instanceof: (left, right) => left instanceof right,
  "%": (left, right) => left % right,
  "&": (left, right) => left & right,
  "*": (left, right) => left * right,
  "**": (left, right) => left ** right,
  "+": (left, right) => left + right,
  "-": (left, right) => left - right,
  "/": (left, right) => left / right,
  "<<": (left, right) => left << right,
  ">>": (left, right) => left >> right,
  ">>>": (left, right) => left >>> right,
  "^": (left, right) => left ^ right,
  "|": (left, right) => left | right
};
var unary2 = {
  "-": (argument) => -argument,
  "+": (argument) => +argument,
  "!": (argument) => !argument,
  "~": (argument) => ~argument,
  typeof: (argument) => typeof argument,
  void: () => void 0,
  delete: () => true
};
var logical2 = {
  "||": (left, right) => left || right,
  "&&": (left, right) => left && right,
  "??": (left, right) => left ?? right
};
var ScopeRoot = class {
  constructor() {
    /** @type {Set<string>} */
    __publicField(this, "conflicts", /* @__PURE__ */ new Set());
  }
  /**
   * @param {string} preferred_name
   */
  unique(preferred_name) {
    preferred_name = preferred_name.replace(/[^a-zA-Z0-9_$]/g, "_");
    let final_name = preferred_name;
    let n = 1;
    while (this.conflicts.has(final_name)) {
      final_name = `${preferred_name}_${n++}`;
    }
    this.conflicts.add(final_name);
    const id2 = id(final_name);
    return id2;
  }
};
function create_scopes(ast, root, allow_reactive_declarations, parent) {
  const scopes = /* @__PURE__ */ new Map();
  const scope = new Scope(root, parent, false);
  scopes.set(ast, scope);
  const state = { scope };
  const references = [];
  const updates = [];
  const possible_implicit_declarations = [];
  function add_params(scope2, params) {
    for (const param of params) {
      for (const node of extract_identifiers(param)) {
        scope2.declare(node, "normal", param.type === "RestElement" ? "rest_param" : "param");
      }
    }
  }
  const create_block_scope = (node, { state: state2, next: next2 }) => {
    const scope2 = state2.scope.child(true);
    scopes.set(node, scope2);
    next2({ scope: scope2 });
  };
  const SvelteFragment4 = (node, { state: state2, next: next2 }) => {
    const scope2 = state2.scope.child();
    scopes.set(node, scope2);
    next2({ scope: scope2 });
  };
  const Component4 = (node, context) => {
    node.metadata.scopes = {
      default: context.state.scope.child()
    };
    if (node.type === "SvelteComponent") {
      context.visit(node.expression);
    }
    const default_state = determine_slot(node) ? context.state : { scope: node.metadata.scopes.default };
    for (const attribute of node.attributes) {
      if (attribute.type === "LetDirective") {
        context.visit(attribute, default_state);
      } else {
        context.visit(attribute);
      }
    }
    for (const child of node.fragment.nodes) {
      let state2 = default_state;
      const slot_name = determine_slot(child);
      if (slot_name !== null) {
        node.metadata.scopes[slot_name] = context.state.scope.child();
        state2 = {
          scope: node.metadata.scopes[slot_name]
        };
      }
      context.visit(child, state2);
    }
  };
  const SvelteDirective = (node, { state: state2, path, visit }) => {
    state2.scope.reference(id(node.name.split(".")[0]), path);
    if (node.expression) {
      visit(node.expression);
    }
  };
  walk(ast, state, {
    // references
    Identifier(node, { path, state: state2 }) {
      const parent2 = path.at(-1);
      if (parent2 && is_reference(
        node,
        /** @type {Node} */
        parent2
      ) && // TSTypeAnnotation, TSInterfaceDeclaration etc - these are normally already filtered out,
      // but for the migration they aren't, so we need to filter them out here
      // TODO -> once migration script is gone we can remove this check
      !parent2.type.startsWith("TS")) {
        references.push([state2.scope, { node, path: path.slice() }]);
      }
    },
    LabeledStatement(node, { path, next: next2 }) {
      if (path.length > 1 || !allow_reactive_declarations) return next2();
      if (node.label.name !== "$") return next2();
      const scope2 = state.scope.child();
      scopes.set(node, scope2);
      if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
        for (const id2 of extract_identifiers(node.body.expression.left)) {
          if (!id2.name.startsWith("$")) {
            possible_implicit_declarations.push(id2);
          }
        }
      }
      next2({ scope: scope2 });
    },
    SvelteFragment: SvelteFragment4,
    SlotElement: SvelteFragment4,
    SvelteElement: SvelteFragment4,
    RegularElement: SvelteFragment4,
    LetDirective(node, context) {
      const scope2 = context.state.scope;
      const bindings = [];
      scope2.declarators.set(node, bindings);
      if (node.expression) {
        for (const id2 of extract_identifiers_from_destructuring(node.expression)) {
          const binding = scope2.declare(id2, "template", "const");
          scope2.reference(id2, [context.path[context.path.length - 1], node]);
          bindings.push(binding);
        }
      } else {
        const id2 = {
          name: node.name,
          type: "Identifier",
          start: node.start,
          end: node.end
        };
        const binding = scope2.declare(id2, "template", "const");
        scope2.reference(id2, [context.path[context.path.length - 1], node]);
        bindings.push(binding);
      }
    },
    Component: (node, context) => {
      context.state.scope.reference(id(node.name), context.path);
      Component4(node, context);
    },
    SvelteSelf: Component4,
    SvelteComponent: Component4,
    // updates
    AssignmentExpression(node, { state: state2, next: next2 }) {
      updates.push([state2.scope, node.left]);
      next2();
    },
    UpdateExpression(node, { state: state2, next: next2 }) {
      updates.push([
        state2.scope,
        /** @type {Identifier | MemberExpression} */
        node.argument
      ]);
      next2();
    },
    ImportDeclaration(node, { state: state2 }) {
      for (const specifier of node.specifiers) {
        state2.scope.declare(specifier.local, "normal", "import", node);
      }
    },
    FunctionExpression(node, { state: state2, next: next2 }) {
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      if (node.id) scope2.declare(node.id, "normal", "function");
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    FunctionDeclaration(node, { state: state2, next: next2 }) {
      if (node.id) state2.scope.declare(node.id, "normal", "function", node);
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    ArrowFunctionExpression(node, { state: state2, next: next2 }) {
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      add_params(scope2, node.params);
      next2({ scope: scope2 });
    },
    ForStatement: create_block_scope,
    ForInStatement: create_block_scope,
    ForOfStatement: create_block_scope,
    SwitchStatement: create_block_scope,
    BlockStatement(node, context) {
      const parent2 = context.path.at(-1);
      if ((parent2 == null ? void 0 : parent2.type) === "FunctionDeclaration" || (parent2 == null ? void 0 : parent2.type) === "FunctionExpression" || (parent2 == null ? void 0 : parent2.type) === "ArrowFunctionExpression") {
        context.next();
      } else {
        create_block_scope(node, context);
      }
    },
    ClassDeclaration(node, { state: state2, next: next2 }) {
      if (node.id) state2.scope.declare(node.id, "normal", "let", node);
      next2();
    },
    VariableDeclaration(node, { state: state2, path, next: next2 }) {
      var _a2;
      const is_parent_const_tag = ((_a2 = path.at(-1)) == null ? void 0 : _a2.type) === "ConstTag";
      for (const declarator2 of node.declarations) {
        const bindings = [];
        state2.scope.declarators.set(declarator2, bindings);
        for (const id2 of extract_identifiers(declarator2.id)) {
          const binding = state2.scope.declare(
            id2,
            is_parent_const_tag ? "template" : "normal",
            node.kind,
            declarator2.init
          );
          bindings.push(binding);
        }
      }
      next2();
    },
    CatchClause(node, { state: state2, next: next2 }) {
      if (node.param) {
        const scope2 = state2.scope.child(true);
        scopes.set(node, scope2);
        for (const id2 of extract_identifiers(node.param)) {
          scope2.declare(id2, "normal", "let");
        }
        next2({ scope: scope2 });
      } else {
        next2();
      }
    },
    EachBlock(node, { state: state2, visit }) {
      visit(node.expression);
      const scope2 = state2.scope.child();
      scopes.set(node, scope2);
      if (node.context) {
        for (const id2 of extract_identifiers(node.context)) {
          const binding = scope2.declare(id2, "each", "const");
          let inside_rest = false;
          let is_rest_id = false;
          walk(node.context, null, {
            Identifier(node2) {
              if (inside_rest && node2 === id2) {
                is_rest_id = true;
              }
            },
            RestElement(_, { next: next2 }) {
              const prev = inside_rest;
              inside_rest = true;
              next2();
              inside_rest = prev;
            }
          });
          binding.metadata = { inside_rest: is_rest_id };
        }
        visit(node.context, { scope: scope2 });
      }
      if (node.index) {
        const is_keyed = node.key && (node.key.type !== "Identifier" || !node.index || node.key.name !== node.index);
        scope2.declare(id(node.index), is_keyed ? "template" : "normal", "const", node);
      }
      if (node.key) visit(node.key, { scope: scope2 });
      for (const child of node.body.nodes) {
        visit(child, { scope: scope2 });
      }
      if (node.fallback) visit(node.fallback, { scope: scope2 });
      node.metadata = {
        expression: create_expression_metadata(),
        keyed: false,
        contains_group_binding: false,
        index: scope2.root.unique("$$index"),
        declarations: scope2.declarations,
        is_controlled: false
      };
    },
    AwaitBlock(node, context) {
      context.visit(node.expression);
      if (node.pending) {
        context.visit(node.pending);
      }
      if (node.then) {
        context.visit(node.then);
        if (node.value) {
          const then_scope = (
            /** @type {Scope} */
            scopes.get(node.then)
          );
          const value_scope = context.state.scope.child();
          scopes.set(node.value, value_scope);
          context.visit(node.value, { scope: value_scope });
          for (const id2 of extract_identifiers(node.value)) {
            then_scope.declare(id2, "template", "const");
            value_scope.declare(id2, "normal", "const");
          }
        }
      }
      if (node.catch) {
        context.visit(node.catch);
        if (node.error) {
          const catch_scope = (
            /** @type {Scope} */
            scopes.get(node.catch)
          );
          const error_scope = context.state.scope.child();
          scopes.set(node.error, error_scope);
          context.visit(node.error, { scope: error_scope });
          for (const id2 of extract_identifiers(node.error)) {
            catch_scope.declare(id2, "template", "const");
            error_scope.declare(id2, "normal", "const");
          }
        }
      }
    },
    SnippetBlock(node, context) {
      const state2 = context.state;
      let scope2 = state2.scope;
      scope2.declare(node.expression, "normal", "function", node);
      const child_scope = state2.scope.child();
      scopes.set(node, child_scope);
      for (const param of node.parameters) {
        for (const id2 of extract_identifiers(param)) {
          child_scope.declare(id2, "snippet", "let");
        }
      }
      context.next({ scope: child_scope });
    },
    Fragment: (node, context) => {
      const scope2 = context.state.scope.child(node.metadata.transparent);
      scopes.set(node, scope2);
      context.next({ scope: scope2 });
    },
    BindDirective(node, context) {
      updates.push([
        context.state.scope,
        /** @type {Identifier | MemberExpression} */
        node.expression
      ]);
      context.next();
    },
    TransitionDirective: SvelteDirective,
    AnimateDirective: SvelteDirective,
    UseDirective: SvelteDirective,
    // using it's own function instead of `SvelteDirective` because
    // StyleDirective doesn't have expressions and are generally already
    // handled by `Identifier`. This is the special case for the shorthand
    // eg <button style:height /> where the variable has the same name of
    // the css property
    StyleDirective(node, { path, state: state2, next: next2 }) {
      if (node.value === true) {
        state2.scope.reference(id(node.name), path.concat(node));
      }
      next2();
    }
    // TODO others
  });
  for (const id2 of possible_implicit_declarations) {
    const binding = scope.get(id2.name);
    if (binding) continue;
    scope.declare(id2, "legacy_reactive", "let");
  }
  for (const [scope2, { node, path }] of references) {
    scope2.reference(node, path);
  }
  for (const [scope2, node] of updates) {
    for (const expression of unwrap_pattern(node)) {
      const left = object2(expression);
      const binding = left && scope2.get(left.name);
      if (binding !== null && left !== binding.node) {
        if (left === expression) {
          binding.reassigned = true;
        } else {
          binding.mutated = true;
        }
      }
    }
  }
  return {
    scope,
    scopes
  };
}
function set_scope(node, { next: next2, state }) {
  const scope = state.scopes.get(node);
  next2(scope !== void 0 && scope !== state.scope ? { ...state, scope } : state);
}
function get_rune(node, scope) {
  if (!node) return null;
  if (node.type !== "CallExpression") return null;
  const keypath = get_global_keypath(node.callee, scope);
  if (!keypath || !is_rune(keypath)) return null;
  return keypath;
}
function get_global_keypath(node, scope) {
  let n = node;
  let joined = "";
  while (n.type === "MemberExpression") {
    if (n.computed) return null;
    if (n.property.type !== "Identifier") return null;
    joined = "." + n.property.name + joined;
    n = n.object;
  }
  if (n.type === "CallExpression" && n.callee.type === "Identifier") {
    joined = "()" + joined;
    n = n.callee;
  }
  if (n.type !== "Identifier") return null;
  const binding = scope.get(n.name);
  if (binding !== null) return null;
  return n.name + joined;
}

// node_modules/svelte/src/compiler/phases/2-analyze/utils/check_graph_for_cycles.js
function check_graph_for_cycles(edges) {
  const graph = edges.reduce((g, edge) => {
    const [u, v] = edge;
    if (!g.has(u)) g.set(u, []);
    if (!g.has(v)) g.set(v, []);
    g.get(u).push(v);
    return g;
  }, /* @__PURE__ */ new Map());
  const visited = /* @__PURE__ */ new Set();
  const on_stack = /* @__PURE__ */ new Set();
  const cycles = [];
  function visit(v) {
    var _a2;
    visited.add(v);
    on_stack.add(v);
    (_a2 = graph.get(v)) == null ? void 0 : _a2.forEach((w2) => {
      if (!visited.has(w2)) {
        visit(w2);
      } else if (on_stack.has(w2)) {
        cycles.push([...on_stack, w2]);
      }
    });
    on_stack.delete(v);
  }
  graph.forEach((_, v) => {
    if (!visited.has(v)) {
      visit(v);
    }
  });
  return cycles[0];
}

// node_modules/svelte/src/compiler/phases/css.js
var regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/;
var regex_css_name_boundary = /^[\s,;}]$/;
function remove_css_prefix(name) {
  return name.replace(regex_css_browser_prefix, "");
}
var is_keyframes_node = (node) => remove_css_prefix(node.name) === "keyframes";

// node_modules/svelte/src/compiler/phases/2-analyze/css/utils.js
var UNKNOWN2 = {};
function gather_possible_values(node, is_class, set2, is_nested = false) {
  if (set2.has(UNKNOWN2)) {
    return;
  }
  if (node.type === "Literal") {
    set2.add(String(node.value));
  } else if (node.type === "ConditionalExpression") {
    gather_possible_values(node.consequent, is_class, set2, is_nested);
    gather_possible_values(node.alternate, is_class, set2, is_nested);
  } else if (node.type === "LogicalExpression") {
    if (node.operator === "&&") {
      const left = /* @__PURE__ */ new Set();
      gather_possible_values(node.left, is_class, left, is_nested);
      if (left.has(UNKNOWN2)) {
        if (!is_class || !is_nested) {
          set2.add("");
          set2.add(false);
          set2.add(NaN);
          set2.add(0);
        }
      } else {
        for (const value of left) {
          if (!value && value != void 0 && (!is_class || !is_nested)) {
            set2.add(value);
          }
        }
      }
      gather_possible_values(node.right, is_class, set2, is_nested);
    } else {
      gather_possible_values(node.left, is_class, set2, is_nested);
      gather_possible_values(node.right, is_class, set2, is_nested);
    }
  } else if (is_class && node.type === "ArrayExpression") {
    for (const entry of node.elements) {
      if (entry) {
        gather_possible_values(entry, is_class, set2, true);
      }
    }
  } else if (is_class && node.type === "ObjectExpression") {
    for (const property of node.properties) {
      if (property.type === "Property" && !property.computed && (property.key.type === "Identifier" || property.key.type === "Literal")) {
        set2.add(
          property.key.type === "Identifier" ? property.key.name : String(property.key.value)
        );
      } else {
        set2.add(UNKNOWN2);
      }
    }
  } else {
    set2.add(UNKNOWN2);
  }
}
function get_possible_values(chunk, is_class) {
  const values = /* @__PURE__ */ new Set();
  if (chunk.type === "Text") {
    values.add(chunk.data);
  } else {
    gather_possible_values(chunk.expression, is_class, values);
  }
  if (values.has(UNKNOWN2)) return null;
  return [...values].map((value) => String(value));
}
function get_parent_rules(rule) {
  const rules = [];
  while (rule) {
    rules.push(rule);
    rule = rule.metadata.parent_rule;
  }
  return rules;
}
function is_global(relative_selector) {
  const first = relative_selector.selectors[0];
  return first.type === "PseudoClassSelector" && first.name === "global" && (first.args === null || // Only these two selector types keep the whole selector global, because e.g.
  // :global(button).x means that the selector is still scoped because of the .x
  relative_selector.selectors.every(
    (selector) => is_unscoped_pseudo_class(selector) || selector.type === "PseudoElementSelector"
  ));
}
function is_unscoped_pseudo_class(selector) {
  return selector.type === "PseudoClassSelector" && // These make the selector scoped
  (selector.name !== "has" && selector.name !== "is" && selector.name !== "where" && // Not is special because we want to scope as specific as possible, but because :not
  // inverses the result, we want to leave the unscoped, too. The exception is more than
  // one selector in the :not (.e.g :not(.x .y)), then .x and .y should be scoped
  (selector.name !== "not" || selector.args === null || selector.args.children.every((c) => c.children.length === 1)) || // selectors with has/is/where/not can also be global if all their children are global
  selector.args === null || selector.args.children.every((c) => c.children.every((r) => is_global(r))));
}
function is_outer_global(relative_selector) {
  const first = relative_selector.selectors[0];
  return first.type === "PseudoClassSelector" && first.name === "global" && (first.args === null || // Only these two selector types can keep the whole selector global, because e.g.
  // :global(button).x means that the selector is still scoped because of the .x
  relative_selector.selectors.every(
    (selector) => selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector"
  ));
}

// node_modules/svelte/src/compiler/phases/2-analyze/css/css-analyze.js
function is_global_block_selector(simple_selector) {
  return simple_selector.type === "PseudoClassSelector" && simple_selector.name === "global" && simple_selector.args === null;
}
function is_unscoped(path) {
  return path.filter((node) => node.type === "Rule").every((node) => node.metadata.has_global_selectors);
}
function is_in_global_block(path) {
  return path.some((node) => node.type === "Rule" && node.metadata.is_global_block);
}
var css_visitors = {
  Atrule(node, context) {
    var _a2;
    if (is_keyframes_node(node)) {
      if (!node.prelude.startsWith("-global-") && !is_in_global_block(context.path)) {
        context.state.keyframes.push(node.prelude);
      } else if (node.prelude.startsWith("-global-")) {
        (_a2 = context.state.analysis.css).has_global || (_a2.has_global = is_unscoped(context.path));
      }
    }
    context.next();
  },
  ComplexSelector(node, context) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    context.next();
    {
      const global = node.children.find(is_global);
      if (global) {
        const is_nested = ((_a2 = context.path.at(-2)) == null ? void 0 : _a2.type) === "PseudoClassSelector";
        if (is_nested && !global.selectors[0].args) {
          css_global_block_invalid_placement(global.selectors[0]);
        }
        const idx = node.children.indexOf(global);
        if (global.selectors[0].args !== null && idx !== 0 && idx !== node.children.length - 1) {
          for (let i = idx + 1; i < node.children.length; i++) {
            if (!is_global(node.children[i])) {
              css_global_invalid_placement(global.selectors[0]);
            }
          }
        }
      }
    }
    for (const relative_selector of node.children) {
      for (let i = 0; i < relative_selector.selectors.length; i++) {
        const selector = relative_selector.selectors[i];
        if (selector.type === "PseudoClassSelector" && selector.name === "global") {
          const child = (_b = selector.args) == null ? void 0 : _b.children[0].children[0];
          if ((child == null ? void 0 : child.selectors[0].type) === "TypeSelector" && i !== 0) {
            css_global_invalid_selector_list(selector);
          }
          if (((_c = relative_selector.selectors[i + 1]) == null ? void 0 : _c.type) === "TypeSelector") {
            css_type_selector_invalid_placement(relative_selector.selectors[i + 1]);
          }
          if (selector.args !== null && selector.args.children.length > 1 && (node.children.length > 1 || relative_selector.selectors.length > 1)) {
            css_global_invalid_selector(selector);
          }
        }
      }
    }
    node.metadata.rule = context.state.rule;
    node.metadata.is_global = node.children.every(
      ({ metadata }) => metadata.is_global || metadata.is_global_like
    );
    (_d = node.metadata).used || (_d.used = node.metadata.is_global);
    if (((_e = node.metadata.rule) == null ? void 0 : _e.metadata.parent_rule) && ((_g = (_f = node.children[0]) == null ? void 0 : _f.selectors[0]) == null ? void 0 : _g.type) === "NestingSelector") {
      const first = (_h = node.children[0]) == null ? void 0 : _h.selectors[1];
      const no_nesting_scope = (first == null ? void 0 : first.type) !== "PseudoClassSelector" || is_unscoped_pseudo_class(first);
      const parent_is_global = node.metadata.rule.metadata.parent_rule.prelude.children.some(
        (child) => child.children.length === 1 && child.children[0].metadata.is_global
      );
      if (no_nesting_scope && parent_is_global) {
        node.metadata.used = true;
      }
    }
  },
  RelativeSelector(node, context) {
    var _a2, _b, _c, _d;
    const parent = (
      /** @type {AST.CSS.ComplexSelector} */
      context.path.at(-1)
    );
    if (node.combinator != null && !((_a2 = context.state.rule) == null ? void 0 : _a2.metadata.parent_rule) && parent.children[0] === node && ((_b = context.path.at(-3)) == null ? void 0 : _b.type) !== "PseudoClassSelector") {
      css_selector_invalid(node.combinator);
    }
    node.metadata.is_global = node.selectors.length >= 1 && is_global(node);
    if (node.selectors.length >= 1 && node.selectors.every(
      (selector) => selector.type === "PseudoClassSelector" || selector.type === "PseudoElementSelector"
    )) {
      const first = node.selectors[0];
      (_c = node.metadata).is_global_like || (_c.is_global_like = first.type === "PseudoClassSelector" && first.name === "host" || first.type === "PseudoElementSelector" && [
        "view-transition",
        "view-transition-group",
        "view-transition-old",
        "view-transition-new",
        "view-transition-image-pair"
      ].includes(first.name));
    }
    (_d = node.metadata).is_global_like || (_d.is_global_like = node.selectors.some(
      (child) => child.type === "PseudoClassSelector" && child.name === "root"
    ) && // :root.y:has(.x) is not a global selector because while .y is unscoped, .x inside `:has(...)` should be scoped
    !node.selectors.some((child) => child.type === "PseudoClassSelector" && child.name === "has"));
    if (node.metadata.is_global_like || node.metadata.is_global) {
      for (const child of node.selectors) {
        walk(
          /** @type {AST.CSS.Node} */
          child,
          null,
          {
            ComplexSelector(node2, context2) {
              node2.metadata.used = true;
              context2.next();
            }
          }
        );
      }
    }
    context.next();
  },
  Rule(node, context) {
    var _a2, _b, _c;
    node.metadata.parent_rule = context.state.rule;
    for (const complex_selector of node.prelude.children) {
      let is_global_block = false;
      for (let selector_idx = 0; selector_idx < complex_selector.children.length; selector_idx++) {
        const child = complex_selector.children[selector_idx];
        const idx = child.selectors.findIndex(is_global_block_selector);
        if (is_global_block) {
          child.metadata.is_global_like = true;
        }
        if (idx === 0) {
          if (child.selectors.length > 1 && selector_idx === 0 && node.metadata.parent_rule === null) {
            css_global_block_invalid_modifier_start(child.selectors[1]);
          } else {
            node.metadata.is_global_block = is_global_block = true;
            for (let i = 1; i < child.selectors.length; i++) {
              walk(
                /** @type {AST.CSS.Node} */
                child.selectors[i],
                null,
                {
                  ComplexSelector(node2) {
                    node2.metadata.used = true;
                  }
                }
              );
            }
            if (child.combinator && child.combinator.name !== " ") {
              css_global_block_invalid_combinator(child, child.combinator.name);
            }
            const declaration2 = node.block.children.find((child2) => child2.type === "Declaration");
            const is_lone_global = complex_selector.children.length === 1 && complex_selector.children[0].selectors.length === 1;
            if (is_lone_global && node.prelude.children.length > 1) {
              css_global_block_invalid_list(node.prelude);
            }
            if (declaration2 && // :global { color: red; } is invalid, but foo :global { color: red; } is valid
            node.prelude.children.length === 1 && is_lone_global) {
              css_global_block_invalid_declaration(declaration2);
            }
          }
        } else if (idx !== -1) {
          css_global_block_invalid_modifier(child.selectors[idx]);
        }
      }
      if (node.metadata.is_global_block && !is_global_block) {
        css_global_block_invalid_list(node.prelude);
      }
    }
    const state = { ...context.state, rule: node };
    context.visit(node.prelude, state);
    for (const selector of node.prelude.children) {
      (_a2 = node.metadata).has_global_selectors || (_a2.has_global_selectors = selector.metadata.is_global);
      (_b = node.metadata).has_local_selectors || (_b.has_local_selectors = !selector.metadata.is_global);
    }
    (_c = context.state.analysis.css).has_global || (_c.has_global = node.metadata.has_global_selectors && node.block.children.filter((child) => child.type === "Declaration").length > 0 && is_unscoped(context.path));
    context.visit(node.block, state);
  },
  NestingSelector(node, context) {
    var _a2, _b;
    const rule = (
      /** @type {AST.CSS.Rule} */
      context.state.rule
    );
    const parent_rule = rule.metadata.parent_rule;
    if (!parent_rule) {
      const children = rule.prelude.children;
      const selectors = children[0].children[0].selectors;
      if (children.length > 1 || selectors.length > 1 || selectors[0].type !== "PseudoClassSelector" || selectors[0].name !== "global" || ((_b = (_a2 = selectors[0].args) == null ? void 0 : _a2.children[0]) == null ? void 0 : _b.children[0].selectors[0]) !== node) {
        css_nesting_selector_invalid_placement(node);
      }
    } else if (
      // :global { &.foo { ... } } is invalid
      parent_rule.metadata.is_global_block && !parent_rule.metadata.parent_rule && parent_rule.prelude.children[0].children.length === 1 && parent_rule.prelude.children[0].children[0].selectors.length === 1
    ) {
      css_global_block_invalid_modifier_start(node);
    }
    context.next();
  }
};
function analyze_css(stylesheet, analysis) {
  const css_state = {
    keyframes: analysis.css.keyframes,
    rule: null,
    analysis
  };
  walk(stylesheet, css_state, css_visitors);
}

// node_modules/svelte/src/compiler/phases/2-analyze/css/css-prune.js
var NODE_PROBABLY_EXISTS = 0;
var NODE_DEFINITELY_EXISTS = 1;
var FORWARD = 0;
var BACKWARD = 1;
var whitelist_attribute_selector = /* @__PURE__ */ new Map([
  ["details", ["open"]],
  ["dialog", ["open"]]
]);
var descendant_combinator = {
  type: "Combinator",
  name: " ",
  start: -1,
  end: -1
};
var nesting_selector = {
  type: "RelativeSelector",
  start: -1,
  end: -1,
  combinator: null,
  selectors: [
    {
      type: "NestingSelector",
      name: "&",
      start: -1,
      end: -1
    }
  ],
  metadata: {
    is_global: false,
    is_global_like: false,
    scoped: false
  }
};
var any_selector = {
  type: "RelativeSelector",
  start: -1,
  end: -1,
  combinator: null,
  selectors: [
    {
      type: "TypeSelector",
      name: "*",
      start: -1,
      end: -1
    }
  ],
  metadata: {
    is_global: false,
    is_global_like: false,
    scoped: false
  }
};
var seen = /* @__PURE__ */ new Set();
function prune(stylesheet, element2) {
  walk(
    /** @type {Compiler.AST.CSS.Node} */
    stylesheet,
    null,
    {
      Rule(node, context) {
        if (node.metadata.is_global_block) {
          context.visit(node.prelude);
        } else {
          context.next();
        }
      },
      ComplexSelector(node) {
        const selectors = get_relative_selectors(node);
        seen.clear();
        if (apply_selector(
          selectors,
          /** @type {Compiler.AST.CSS.Rule} */
          node.metadata.rule,
          element2,
          BACKWARD
        )) {
          node.metadata.used = true;
        }
      }
    }
  );
}
function get_relative_selectors(node) {
  var _a2;
  const selectors = truncate(node);
  if (((_a2 = node.metadata.rule) == null ? void 0 : _a2.metadata.parent_rule) && selectors.length > 0) {
    let has_explicit_nesting_selector = false;
    for (let selector of selectors) {
      walk(selector, null, {
        // @ts-ignore
        NestingSelector() {
          has_explicit_nesting_selector = true;
        }
      });
      if (has_explicit_nesting_selector) break;
    }
    if (!has_explicit_nesting_selector) {
      if (selectors[0].combinator === null) {
        selectors[0] = {
          ...selectors[0],
          combinator: descendant_combinator
        };
      }
      selectors.unshift(nesting_selector);
    }
  }
  return selectors;
}
function truncate(node) {
  const i = node.children.findLastIndex(({ metadata, selectors }) => {
    const first = selectors[0];
    return (
      // not after a :global selector
      !metadata.is_global_like && !(first.type === "PseudoClassSelector" && first.name === "global" && first.args === null) && // not a :global(...) without a :has/is/where(...) modifier that is scoped
      !metadata.is_global
    );
  });
  return node.children.slice(0, i + 1).map((child) => {
    const root = child.selectors.find((s) => s.type === "PseudoClassSelector" && s.name === "root");
    if (!root || child.metadata.is_global_like) return child;
    return {
      ...child,
      selectors: child.selectors.filter((s) => s.type === "PseudoClassSelector" && s.name === "has")
    };
  });
}
function apply_selector(relative_selectors, rule, element2, direction) {
  const rest_selectors = relative_selectors.slice();
  const relative_selector = direction === FORWARD ? rest_selectors.shift() : rest_selectors.pop();
  const matched = !!relative_selector && relative_selector_might_apply_to_node(relative_selector, rule, element2, direction) && apply_combinator(relative_selector, rest_selectors, rule, element2, direction);
  if (matched) {
    if (!is_outer_global(relative_selector)) {
      relative_selector.metadata.scoped = true;
    }
    element2.metadata.scoped = true;
  }
  return matched;
}
function apply_combinator(relative_selector, rest_selectors, rule, node, direction) {
  var _a2;
  const combinator = direction == FORWARD ? (_a2 = rest_selectors[0]) == null ? void 0 : _a2.combinator : relative_selector.combinator;
  if (!combinator) return true;
  switch (combinator.name) {
    case " ":
    case ">": {
      const is_adjacent = combinator.name === ">";
      const parents = direction === FORWARD ? get_descendant_elements(node, is_adjacent) : get_ancestor_elements(node, is_adjacent);
      let parent_matched = false;
      for (const parent of parents) {
        if (apply_selector(rest_selectors, rule, parent, direction)) {
          parent_matched = true;
        }
      }
      return parent_matched || direction === BACKWARD && (!is_adjacent || parents.length === 0) && rest_selectors.every((selector) => is_global2(selector, rule));
    }
    case "+":
    case "~": {
      const siblings = get_possible_element_siblings(node, direction, combinator.name === "+");
      let sibling_matched = false;
      for (const possible_sibling of siblings.keys()) {
        if (possible_sibling.type === "RenderTag" || possible_sibling.type === "SlotElement" || possible_sibling.type === "Component") {
          if (rest_selectors.length === 1 && rest_selectors[0].metadata.is_global) {
            sibling_matched = true;
          }
        } else if (apply_selector(rest_selectors, rule, possible_sibling, direction)) {
          sibling_matched = true;
        }
      }
      return sibling_matched || direction === BACKWARD && get_element_parent(node) === null && rest_selectors.every((selector) => is_global2(selector, rule));
    }
    default:
      return true;
  }
}
function is_global2(selector, rule) {
  if (selector.metadata.is_global || selector.metadata.is_global_like) {
    return true;
  }
  let explicitly_global = false;
  for (const s of selector.selectors) {
    let selector_list = null;
    let can_be_global = false;
    let owner = rule;
    if (s.type === "PseudoClassSelector") {
      if ((s.name === "is" || s.name === "where") && s.args) {
        selector_list = s.args;
      } else {
        can_be_global = is_unscoped_pseudo_class(s);
      }
    }
    if (s.type === "NestingSelector") {
      owner = /** @type {Compiler.AST.CSS.Rule} */
      rule.metadata.parent_rule;
      selector_list = owner.prelude;
    }
    const has_global_selectors = !!(selector_list == null ? void 0 : selector_list.children.some((complex_selector) => {
      return complex_selector.children.every(
        (relative_selector) => is_global2(relative_selector, owner)
      );
    }));
    explicitly_global || (explicitly_global = has_global_selectors);
    if (!has_global_selectors && !can_be_global) {
      return false;
    }
  }
  return explicitly_global || selector.selectors.length === 0;
}
var regex_backslash_and_following_character = /\\(.)/g;
function relative_selector_might_apply_to_node(relative_selector, rule, element2, direction) {
  var _a2;
  const has_selectors = [];
  const other_selectors = [];
  for (const selector of relative_selector.selectors) {
    if (selector.type === "PseudoClassSelector" && selector.name === "has" && selector.args) {
      has_selectors.push(selector);
    } else {
      other_selectors.push(selector);
    }
  }
  if (has_selectors.length > 0) {
    const rules = get_parent_rules(rule);
    const include_self = rules.some((r) => r.prelude.children.some((c) => c.children.some((s) => is_global2(s, r)))) || rules[rules.length - 1].prelude.children.some(
      (c) => c.children.some(
        (r) => r.selectors.some(
          (s) => s.type === "PseudoClassSelector" && (s.name === "root" || s.name === "global" && s.args)
        )
      )
    );
    for (const has_selector of has_selectors) {
      const complex_selectors = (
        /** @type {Compiler.AST.CSS.SelectorList} */
        has_selector.args.children
      );
      let matched = false;
      for (const complex_selector of complex_selectors) {
        const [first, ...rest2] = truncate(complex_selector);
        if (!first) {
          complex_selector.metadata.used = true;
          matched = true;
          continue;
        }
        if (include_self) {
          const selector_including_self = [
            first.combinator ? { ...first, combinator: null } : first,
            ...rest2
          ];
          if (apply_selector(selector_including_self, rule, element2, FORWARD)) {
            complex_selector.metadata.used = true;
            matched = true;
          }
        }
        const selector_excluding_self = [
          any_selector,
          first.combinator ? first : { ...first, combinator: descendant_combinator },
          ...rest2
        ];
        if (apply_selector(selector_excluding_self, rule, element2, FORWARD)) {
          complex_selector.metadata.used = true;
          matched = true;
        }
      }
      if (!matched) {
        return false;
      }
    }
  }
  for (const selector of other_selectors) {
    if (selector.type === "Percentage" || selector.type === "Nth") continue;
    const name = selector.name.replace(regex_backslash_and_following_character, "$1");
    switch (selector.type) {
      case "PseudoClassSelector": {
        if (name === "host" || name === "root") return false;
        if (name === "global" && selector.args !== null && relative_selector.selectors.length === 1) {
          const args = selector.args;
          const complex_selector = args.children[0];
          return apply_selector(complex_selector.children, rule, element2, BACKWARD);
        }
        if (name === "global" && selector.args === null) return true;
        if (name === "not" && selector.args) {
          for (const complex_selector of selector.args.children) {
            walk(complex_selector, null, {
              ComplexSelector(node, context) {
                node.metadata.used = true;
                context.next();
              }
            });
            const relative = truncate(complex_selector);
            if (complex_selector.children.length > 1) {
              for (const selector2 of relative) {
                selector2.metadata.scoped = true;
              }
              let el = element2;
              while (el) {
                el.metadata.scoped = true;
                el = get_element_parent(el);
              }
            }
          }
          break;
        }
        if ((name === "is" || name === "where") && selector.args) {
          let matched = false;
          for (const complex_selector of selector.args.children) {
            const relative = truncate(complex_selector);
            const is_global3 = relative.length === 0;
            if (is_global3) {
              complex_selector.metadata.used = true;
              matched = true;
            } else if (apply_selector(relative, rule, element2, BACKWARD)) {
              complex_selector.metadata.used = true;
              matched = true;
            } else if (complex_selector.children.length > 1 && (name == "is" || name == "where")) {
              complex_selector.metadata.used = true;
              matched = true;
              for (const selector2 of relative) {
                selector2.metadata.scoped = true;
              }
            }
          }
          if (!matched) {
            return false;
          }
        }
        break;
      }
      case "PseudoElementSelector": {
        break;
      }
      case "AttributeSelector": {
        const whitelisted = whitelist_attribute_selector.get(element2.name.toLowerCase());
        if (!(whitelisted == null ? void 0 : whitelisted.includes(selector.name.toLowerCase())) && !attribute_matches(
          element2,
          selector.name,
          selector.value && unquote(selector.value),
          selector.matcher,
          ((_a2 = selector.flags) == null ? void 0 : _a2.includes("i")) ?? false
        )) {
          return false;
        }
        break;
      }
      case "ClassSelector": {
        if (!attribute_matches(element2, "class", name, "~=", false) && !element2.attributes.some(
          (attribute) => attribute.type === "ClassDirective" && attribute.name === name
        )) {
          return false;
        }
        break;
      }
      case "IdSelector": {
        if (!attribute_matches(element2, "id", name, "=", false)) {
          return false;
        }
        break;
      }
      case "TypeSelector": {
        if (element2.name.toLowerCase() !== name.toLowerCase() && name !== "*" && element2.type !== "SvelteElement") {
          return false;
        }
        break;
      }
      case "NestingSelector": {
        let matched = false;
        const parent = (
          /** @type {Compiler.AST.CSS.Rule} */
          rule.metadata.parent_rule
        );
        for (const complex_selector of parent.prelude.children) {
          if (apply_selector(get_relative_selectors(complex_selector), parent, element2, direction) || complex_selector.children.every((s) => is_global2(s, parent))) {
            complex_selector.metadata.used = true;
            matched = true;
          }
        }
        if (!matched) {
          return false;
        }
        break;
      }
    }
  }
  return true;
}
function test_attribute(operator, expected_value, case_insensitive, value) {
  if (case_insensitive) {
    expected_value = expected_value.toLowerCase();
    value = value.toLowerCase();
  }
  switch (operator) {
    case "=":
      return value === expected_value;
    case "~=":
      return value.split(/\s/).includes(expected_value);
    case "|=":
      return `${value}-`.startsWith(`${expected_value}-`);
    case "^=":
      return value.startsWith(expected_value);
    case "$=":
      return value.endsWith(expected_value);
    case "*=":
      return value.includes(expected_value);
    default:
      throw new Error("this shouldn't happen");
  }
}
function attribute_matches(node, name, expected_value, operator, case_insensitive) {
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") return true;
    if (attribute.type === "BindDirective" && attribute.name === name) return true;
    if (attribute.type !== "Attribute") continue;
    if (attribute.name.toLowerCase() !== name.toLowerCase()) continue;
    if (attribute.value === true) return operator === null;
    if (expected_value === null) return true;
    if (is_text_attribute(attribute)) {
      return test_attribute(operator, expected_value, case_insensitive, attribute.value[0].data);
    }
    const chunks = get_attribute_chunks(attribute.value);
    const possible_values = /* @__PURE__ */ new Set();
    let prev_values = [];
    for (const chunk of chunks) {
      const current_possible_values = get_possible_values(chunk, name === "class");
      if (!current_possible_values) return true;
      if (prev_values.length > 0) {
        const start_with_space = [];
        const remaining = [];
        current_possible_values.forEach((current_possible_value) => {
          if (regex_starts_with_whitespace.test(current_possible_value)) {
            start_with_space.push(current_possible_value);
          } else {
            remaining.push(current_possible_value);
          }
        });
        if (remaining.length > 0) {
          if (start_with_space.length > 0) {
            prev_values.forEach((prev_value) => possible_values.add(prev_value));
          }
          const combined = [];
          prev_values.forEach((prev_value) => {
            remaining.forEach((value) => {
              combined.push(prev_value + value);
            });
          });
          prev_values = combined;
          start_with_space.forEach((value) => {
            if (regex_ends_with_whitespace.test(value)) {
              possible_values.add(value);
            } else {
              prev_values.push(value);
            }
          });
          continue;
        } else {
          prev_values.forEach((prev_value) => possible_values.add(prev_value));
          prev_values = [];
        }
      }
      current_possible_values.forEach((current_possible_value) => {
        if (regex_ends_with_whitespace.test(current_possible_value)) {
          possible_values.add(current_possible_value);
        } else {
          prev_values.push(current_possible_value);
        }
      });
      if (prev_values.length < current_possible_values.length) {
        prev_values.push(" ");
      }
      if (prev_values.length > 20) {
        return true;
      }
    }
    prev_values.forEach((prev_value) => possible_values.add(prev_value));
    for (const value of possible_values) {
      if (test_attribute(operator, expected_value, case_insensitive, value)) return true;
    }
  }
  return false;
}
function unquote(str) {
  if (str[0] === str[str.length - 1] && str[0] === "'" || str[0] === '"') {
    return str.slice(1, str.length - 1);
  }
  return str;
}
function get_ancestor_elements(node, adjacent_only, seen2 = /* @__PURE__ */ new Set()) {
  const ancestors = [];
  const path = node.metadata.path;
  let i = path.length;
  while (i--) {
    const parent = path[i];
    if (parent.type === "SnippetBlock") {
      if (!seen2.has(parent)) {
        seen2.add(parent);
        for (const site of parent.metadata.sites) {
          ancestors.push(...get_ancestor_elements(site, adjacent_only, seen2));
        }
      }
      break;
    }
    if (parent.type === "RegularElement" || parent.type === "SvelteElement") {
      ancestors.push(parent);
      if (adjacent_only) {
        break;
      }
    }
  }
  return ancestors;
}
function get_descendant_elements(node, adjacent_only, seen2 = /* @__PURE__ */ new Set()) {
  const descendants = [];
  function walk_children(node2) {
    walk(node2, null, {
      _(node3, context) {
        if (node3.type === "RegularElement" || node3.type === "SvelteElement") {
          descendants.push(node3);
          if (!adjacent_only) {
            context.next();
          }
        } else if (node3.type === "RenderTag") {
          for (const snippet of node3.metadata.snippets) {
            if (seen2.has(snippet)) continue;
            seen2.add(snippet);
            walk_children(snippet.body);
          }
        } else {
          context.next();
        }
      }
    });
  }
  walk_children(node.type === "RenderTag" ? node : node.fragment);
  return descendants;
}
function get_element_parent(node) {
  let path = node.metadata.path;
  let i = path.length;
  while (i--) {
    const parent = path[i];
    if (parent.type === "RegularElement" || parent.type === "SvelteElement") {
      return parent;
    }
  }
  return null;
}
function get_possible_element_siblings(node, direction, adjacent_only, seen2 = /* @__PURE__ */ new Set()) {
  const result = /* @__PURE__ */ new Map();
  const path = node.metadata.path;
  let current = node;
  let i = path.length;
  while (i--) {
    const fragment2 = (
      /** @type {Compiler.AST.Fragment} */
      path[i--]
    );
    let j = fragment2.nodes.indexOf(current) + (direction === FORWARD ? 1 : -1);
    while (j >= 0 && j < fragment2.nodes.length) {
      const node2 = fragment2.nodes[j];
      if (node2.type === "RegularElement") {
        const has_slot_attribute = node2.attributes.some(
          (attr) => attr.type === "Attribute" && attr.name.toLowerCase() === "slot"
        );
        if (!has_slot_attribute) {
          result.set(node2, NODE_DEFINITELY_EXISTS);
          if (adjacent_only) {
            return result;
          }
        }
      } else if (is_block(node2) || node2.type === "Component") {
        if (node2.type === "SlotElement" || node2.type === "Component") {
          result.set(node2, NODE_PROBABLY_EXISTS);
        }
        const possible_last_child = get_possible_nested_siblings(node2, direction, adjacent_only);
        add_to_map(possible_last_child, result);
        if (adjacent_only && node2.type !== "Component" && has_definite_elements(possible_last_child)) {
          return result;
        }
      } else if (node2.type === "SvelteElement") {
        result.set(node2, NODE_PROBABLY_EXISTS);
      } else if (node2.type === "RenderTag") {
        result.set(node2, NODE_PROBABLY_EXISTS);
        for (const snippet of node2.metadata.snippets) {
          add_to_map(get_possible_nested_siblings(snippet, direction, adjacent_only), result);
        }
      }
      j = direction === FORWARD ? j + 1 : j - 1;
    }
    current = path[i];
    if (!current) break;
    if (current.type === "Component" || current.type === "SvelteComponent" || current.type === "SvelteSelf") {
      continue;
    }
    if (current.type === "SnippetBlock") {
      if (seen2.has(current)) break;
      seen2.add(current);
      for (const site of current.metadata.sites) {
        const siblings = get_possible_element_siblings(site, direction, adjacent_only, seen2);
        add_to_map(siblings, result);
        if (adjacent_only && current.metadata.sites.size === 1 && has_definite_elements(siblings)) {
          return result;
        }
      }
    }
    if (!is_block(current)) break;
    if (current.type === "EachBlock" && fragment2 === current.body) {
      add_to_map(get_possible_nested_siblings(current, direction, adjacent_only), result);
    }
  }
  return result;
}
function get_possible_nested_siblings(node, direction, adjacent_only, seen2 = /* @__PURE__ */ new Set()) {
  let fragments = [];
  switch (node.type) {
    case "EachBlock":
      fragments.push(node.body, node.fallback);
      break;
    case "IfBlock":
      fragments.push(node.consequent, node.alternate);
      break;
    case "AwaitBlock":
      fragments.push(node.pending, node.then, node.catch);
      break;
    case "KeyBlock":
    case "SlotElement":
      fragments.push(node.fragment);
      break;
    case "SnippetBlock":
      if (seen2.has(node)) {
        return /* @__PURE__ */ new Map();
      }
      seen2.add(node);
      fragments.push(node.body);
      break;
    case "Component":
      fragments.push(node.fragment, ...[...node.metadata.snippets].map((s) => s.body));
      break;
  }
  const result = /* @__PURE__ */ new Map();
  let exhaustive = node.type !== "SlotElement" && node.type !== "SnippetBlock";
  for (const fragment2 of fragments) {
    if (fragment2 == null) {
      exhaustive = false;
      continue;
    }
    const map = loop_child(fragment2.nodes, direction, adjacent_only, seen2);
    exhaustive && (exhaustive = has_definite_elements(map));
    add_to_map(map, result);
  }
  if (!exhaustive) {
    for (const key2 of result.keys()) {
      result.set(key2, NODE_PROBABLY_EXISTS);
    }
  }
  return result;
}
function has_definite_elements(result) {
  if (result.size === 0) return false;
  for (const exist of result.values()) {
    if (exist === NODE_DEFINITELY_EXISTS) {
      return true;
    }
  }
  return false;
}
function add_to_map(from, to) {
  from.forEach((exist, element2) => {
    to.set(element2, higher_existence(exist, to.get(element2)));
  });
}
function higher_existence(exist1, exist2) {
  if (exist2 === void 0) return exist1;
  return exist1 > exist2 ? exist1 : exist2;
}
function loop_child(children, direction, adjacent_only, seen2) {
  const result = /* @__PURE__ */ new Map();
  let i = direction === FORWARD ? 0 : children.length - 1;
  while (i >= 0 && i < children.length) {
    const child = children[i];
    if (child.type === "RegularElement") {
      result.set(child, NODE_DEFINITELY_EXISTS);
      if (adjacent_only) {
        break;
      }
    } else if (child.type === "SvelteElement") {
      result.set(child, NODE_PROBABLY_EXISTS);
    } else if (child.type === "RenderTag") {
      for (const snippet of child.metadata.snippets) {
        add_to_map(get_possible_nested_siblings(snippet, direction, adjacent_only, seen2), result);
      }
    } else if (is_block(child)) {
      const child_result = get_possible_nested_siblings(child, direction, adjacent_only, seen2);
      add_to_map(child_result, result);
      if (adjacent_only && has_definite_elements(child_result)) {
        break;
      }
    }
    i = direction === FORWARD ? i + 1 : i - 1;
  }
  return result;
}
function is_block(node) {
  return node.type === "IfBlock" || node.type === "EachBlock" || node.type === "AwaitBlock" || node.type === "KeyBlock" || node.type === "SlotElement";
}

// node_modules/svelte/src/compiler/phases/2-analyze/css/css-warn.js
function warn_unused(stylesheet) {
  walk(stylesheet, { stylesheet }, visitors2);
}
var visitors2 = {
  Atrule(node, context) {
    if (!is_keyframes_node(node)) {
      context.next();
    }
  },
  PseudoClassSelector(node, context) {
    if (node.name === "is" || node.name === "where") {
      context.next();
    }
  },
  ComplexSelector(node, context) {
    var _a2, _b;
    if (!node.metadata.used && // prevent double-marking of `.unused:is(.unused)`
    (((_a2 = context.path.at(-2)) == null ? void 0 : _a2.type) !== "PseudoClassSelector" || /** @type {AST.CSS.ComplexSelector} */
    ((_b = context.path.at(-4)) == null ? void 0 : _b.metadata.used))) {
      const content = context.state.stylesheet.content;
      const text2 = content.styles.substring(node.start - content.start, node.end - content.start);
      css_unused_selector(node, text2);
    }
    context.next();
  },
  Rule(node, context) {
    if (node.metadata.is_global_block) {
      context.visit(node.prelude);
    } else {
      context.next();
    }
  }
};

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/function.js
function visit_function(node, context) {
  node.metadata = {
    hoisted: false,
    hoisted_params: [],
    scope: context.state.scope
  };
  context.next({
    ...context.state,
    function_depth: context.state.function_depth + 1,
    expression: null
  });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ArrowFunctionExpression.js
function ArrowFunctionExpression(node, context) {
  visit_function(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/AssignmentExpression.js
function AssignmentExpression(node, context) {
  validate_assignment(node, node.left, context.state);
  if (context.state.reactive_statement) {
    const id2 = node.left.type === "MemberExpression" ? object2(node.left) : node.left;
    if (id2 !== null) {
      for (const id3 of extract_identifiers(node.left)) {
        const binding = context.state.scope.get(id3.name);
        if (binding) {
          context.state.reactive_statement.assignments.add(binding);
        }
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/fragment.js
function mark_subtree_dynamic(path) {
  let i = path.length;
  while (i--) {
    const node = path[i];
    if (node.type === "Fragment") {
      if (node.metadata.dynamic) return;
      node.metadata.dynamic = true;
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Attribute.js
function Attribute(node, context) {
  context.next();
  const parent = (
    /** @type {AST.SvelteNode} */
    context.path.at(-1)
  );
  if (parent.type === "RegularElement") {
    if (node.name === "value" && parent.name === "option") {
      mark_subtree_dynamic(context.path);
    }
  }
  if (is_event_attribute(node)) {
    mark_subtree_dynamic(context.path);
  }
  if (cannot_be_set_statically(node.name)) {
    mark_subtree_dynamic(context.path);
  }
  if (node.name === "class" && !Array.isArray(node.value) && node.value !== true && node.value.expression.type !== "Literal" && node.value.expression.type !== "TemplateLiteral" && node.value.expression.type !== "BinaryExpression") {
    mark_subtree_dynamic(context.path);
    node.metadata.needs_clsx = true;
  }
  if (node.value !== true) {
    for (const chunk of get_attribute_chunks(node.value)) {
      if (chunk.type !== "ExpressionTag") continue;
      if (chunk.expression.type === "FunctionExpression" || chunk.expression.type === "ArrowFunctionExpression") {
        continue;
      }
    }
    if (is_event_attribute(node)) {
      const parent2 = context.path.at(-1);
      if ((parent2 == null ? void 0 : parent2.type) === "RegularElement" || (parent2 == null ? void 0 : parent2.type) === "SvelteElement") {
        context.state.analysis.uses_event_attributes = true;
      }
      const expression = get_attribute_expression(node);
      const delegated_event = get_delegated_event(node.name.slice(2), expression, context);
      if (delegated_event !== null) {
        if (delegated_event.hoisted) {
          delegated_event.function.metadata.hoisted = true;
        }
        node.metadata.delegated = delegated_event;
      }
    }
  }
}
var unhoisted = { hoisted: false };
function get_delegated_event(event_name, handler, context) {
  var _a2, _b, _c;
  if (!handler || !is_delegated(event_name)) {
    return null;
  }
  const element2 = context.path.at(-1);
  if ((element2 == null ? void 0 : element2.type) !== "RegularElement") {
    return null;
  }
  let target_function = null;
  let binding = null;
  if (element2.metadata.has_spread) {
    return unhoisted;
  }
  if (handler.type === "ArrowFunctionExpression" || handler.type === "FunctionExpression") {
    target_function = handler;
  } else if (handler.type === "Identifier") {
    binding = context.state.scope.get(handler.name);
    if (context.state.analysis.module.scope.references.has(handler.name)) {
      return unhoisted;
    }
    if (binding != null) {
      for (const { path } of binding.references) {
        const parent = path.at(-1);
        if (parent === void 0) return unhoisted;
        const grandparent = path.at(-2);
        let element3 = null;
        let event_name2 = null;
        if (parent.type === "OnDirective") {
          element3 = /** @type {AST.RegularElement} */
          grandparent;
          event_name2 = parent.name;
        } else if (parent.type === "ExpressionTag" && (grandparent == null ? void 0 : grandparent.type) === "Attribute" && is_event_attribute(grandparent)) {
          element3 = /** @type {AST.RegularElement} */
          path.at(-3);
          const attribute = (
            /** @type {AST.Attribute} */
            grandparent
          );
          event_name2 = get_attribute_event_name(attribute.name);
        }
        if (element3 && event_name2) {
          if (element3.type !== "RegularElement" || element3.metadata.has_spread || !is_delegated(event_name2)) {
            return unhoisted;
          }
        } else if (parent.type !== "FunctionDeclaration" && parent.type !== "VariableDeclarator") {
          return unhoisted;
        }
      }
    }
    if (context.state.analysis.exports.find((node) => node.name === handler.name)) {
      return unhoisted;
    }
    if (binding == null ? void 0 : binding.is_function()) {
      target_function = binding.initial;
    }
  }
  if (target_function == null || target_function.params.length > 1) {
    return unhoisted;
  }
  const visited_references = /* @__PURE__ */ new Set();
  const scope = target_function.metadata.scope;
  for (const [reference] of scope.references) {
    if (reference === "arguments" || reference === "$host") return unhoisted;
    if (((_a2 = scope.get(`$${reference}`)) == null ? void 0 : _a2.kind) === "store_sub") return unhoisted;
    const binding2 = scope.get(reference);
    const local_binding = context.state.scope.get(reference);
    if (local_binding !== null && ((_b = local_binding.initial) == null ? void 0 : _b.type) === "SnippetBlock" && !local_binding.initial.metadata.can_hoist) {
      return unhoisted;
    }
    if (local_binding !== null && binding2 !== null && local_binding.node !== binding2.node) {
      return unhoisted;
    }
    if (binding2 !== null && binding2.kind === "store_sub" && visited_references.has(reference.slice(1))) {
      return unhoisted;
    }
    if (binding2 !== null && ((_c = binding2.initial) == null ? void 0 : _c.type) === "EachBlock") return unhoisted;
    if (binding2 !== null && // Bail out if the the binding is a rest param
    (binding2.declaration_kind === "rest_param" || // Bail out if we reference anything from the EachBlock (for now) that mutates in non-runes mode,
    (!context.state.analysis.runes && binding2.kind === "each" || // or any normal not reactive bindings that are mutated.
    binding2.kind === "normal") && binding2.updated)) {
      return unhoisted;
    }
    visited_references.add(reference);
  }
  return { hoisted: true, function: target_function };
}
function get_attribute_event_name(event_name) {
  event_name = event_name.slice(2);
  if (is_capture_event(event_name)) {
    event_name = event_name.slice(0, -7);
  }
  return event_name;
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/AwaitBlock.js
function AwaitBlock(node, context) {
  validate_block_not_empty(node.pending, context);
  validate_block_not_empty(node.then, context);
  validate_block_not_empty(node.catch, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "#");
    if (node.value) {
      const start = (
        /** @type {number} */
        node.value.start
      );
      const match = context.state.analysis.source.substring(start - 10, start).match(/{(\s*):then\s+$/);
      if (match && match[1] !== "") {
        block_unexpected_character({ start: start - 10, end: start }, ":");
      }
    }
    if (node.error) {
      const start = (
        /** @type {number} */
        node.error.start
      );
      const match = context.state.analysis.source.substring(start - 10, start).match(/{(\s*):catch\s+$/);
      if (match && match[1] !== "") {
        block_unexpected_character({ start: start - 10, end: start }, ":");
      }
    }
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/bindings.js
var binding_properties = {
  // media
  currentTime: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  duration: {
    valid_elements: ["audio", "video"],
    event: "durationchange",
    omit_in_ssr: true
  },
  focused: {},
  paused: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  buffered: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  seekable: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  played: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  volume: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  muted: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  playbackRate: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true,
    bidirectional: true
  },
  seeking: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  ended: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  readyState: {
    valid_elements: ["audio", "video"],
    omit_in_ssr: true
  },
  // video
  videoHeight: {
    valid_elements: ["video"],
    event: "resize",
    omit_in_ssr: true
  },
  videoWidth: {
    valid_elements: ["video"],
    event: "resize",
    omit_in_ssr: true
  },
  // img
  naturalWidth: {
    valid_elements: ["img"],
    event: "load",
    omit_in_ssr: true
  },
  naturalHeight: {
    valid_elements: ["img"],
    event: "load",
    omit_in_ssr: true
  },
  // document
  activeElement: {
    valid_elements: ["svelte:document"],
    omit_in_ssr: true
  },
  fullscreenElement: {
    valid_elements: ["svelte:document"],
    event: "fullscreenchange",
    omit_in_ssr: true
  },
  pointerLockElement: {
    valid_elements: ["svelte:document"],
    event: "pointerlockchange",
    omit_in_ssr: true
  },
  visibilityState: {
    valid_elements: ["svelte:document"],
    event: "visibilitychange",
    omit_in_ssr: true
  },
  // window
  innerWidth: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  innerHeight: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  outerWidth: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  outerHeight: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  scrollX: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true,
    bidirectional: true
  },
  scrollY: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true,
    bidirectional: true
  },
  online: {
    valid_elements: ["svelte:window"],
    omit_in_ssr: true
  },
  devicePixelRatio: {
    valid_elements: ["svelte:window"],
    event: "resize",
    omit_in_ssr: true
  },
  // dimensions
  clientWidth: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  clientHeight: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  offsetWidth: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  offsetHeight: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  contentRect: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  contentBoxSize: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  borderBoxSize: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  devicePixelContentBoxSize: {
    omit_in_ssr: true,
    invalid_elements: ["svelte:window", "svelte:document"]
  },
  // checkbox/radio
  indeterminate: {
    event: "change",
    bidirectional: true,
    valid_elements: ["input"],
    omit_in_ssr: true
    // no corresponding attribute
  },
  checked: {
    valid_elements: ["input"],
    bidirectional: true
  },
  group: {
    valid_elements: ["input"],
    bidirectional: true
  },
  // various
  this: {
    omit_in_ssr: true
  },
  innerText: {
    invalid_elements: ["svelte:window", "svelte:document"],
    bidirectional: true
  },
  innerHTML: {
    invalid_elements: ["svelte:window", "svelte:document"],
    bidirectional: true
  },
  textContent: {
    invalid_elements: ["svelte:window", "svelte:document"],
    bidirectional: true
  },
  open: {
    event: "toggle",
    bidirectional: true,
    valid_elements: ["details"]
  },
  value: {
    valid_elements: ["input", "textarea", "select"],
    bidirectional: true
  },
  files: {
    valid_elements: ["input"],
    omit_in_ssr: true,
    bidirectional: true
  }
};

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/BindDirective.js
function BindDirective(node, context) {
  var _a2, _b, _c, _d, _e;
  const parent = context.path.at(-1);
  if ((parent == null ? void 0 : parent.type) === "RegularElement" || (parent == null ? void 0 : parent.type) === "SvelteElement" || (parent == null ? void 0 : parent.type) === "SvelteWindow" || (parent == null ? void 0 : parent.type) === "SvelteDocument" || (parent == null ? void 0 : parent.type) === "SvelteBody") {
    if (node.name in binding_properties) {
      const property = binding_properties[node.name];
      if (property.valid_elements && !property.valid_elements.includes(parent.name)) {
        bind_invalid_target(
          node,
          node.name,
          property.valid_elements.map((valid_element) => `<${valid_element}>`).join(", ")
        );
      }
      if (property.invalid_elements && property.invalid_elements.includes(parent.name)) {
        const valid_bindings = Object.entries(binding_properties).filter(([_, binding_property]) => {
          var _a3, _b2;
          return ((_a3 = binding_property.valid_elements) == null ? void 0 : _a3.includes(parent.name)) || !binding_property.valid_elements && !((_b2 = binding_property.invalid_elements) == null ? void 0 : _b2.includes(parent.name));
        }).map(([property_name]) => property_name).sort();
        bind_invalid_name(
          node,
          node.name,
          `Possible bindings for <${parent.name}> are ${valid_bindings.join(", ")}`
        );
      }
      if (parent.name === "input" && node.name !== "this") {
        const type = (
          /** @type {AST.Attribute | undefined} */
          parent.attributes.find((a) => a.type === "Attribute" && a.name === "type")
        );
        if (type && !is_text_attribute(type)) {
          if (node.name !== "value" || type.value === true) {
            attribute_invalid_type(type);
          }
        } else {
          if (node.name === "checked" && (type == null ? void 0 : type.value[0].data) !== "checkbox") {
            bind_invalid_target(node, node.name, '<input type="checkbox">');
          }
          if (node.name === "files" && (type == null ? void 0 : type.value[0].data) !== "file") {
            bind_invalid_target(node, node.name, '<input type="file">');
          }
        }
      }
      if (parent.name === "select" && node.name !== "this") {
        const multiple = parent.attributes.find(
          (a) => a.type === "Attribute" && a.name === "multiple" && !is_text_attribute(a) && a.value !== true
        );
        if (multiple) {
          attribute_invalid_multiple(multiple);
        }
      }
      if (node.name === "offsetWidth" && is_svg(parent.name)) {
        bind_invalid_target(
          node,
          node.name,
          `non-<svg> elements. Use 'clientWidth' for <svg> instead`
        );
      }
      if (is_content_editable_binding(node.name)) {
        const contenteditable = (
          /** @type {AST.Attribute} */
          parent.attributes.find((a) => a.type === "Attribute" && a.name === "contenteditable")
        );
        if (!contenteditable) {
          attribute_contenteditable_missing(node);
        } else if (!is_text_attribute(contenteditable) && contenteditable.value !== true) {
          attribute_contenteditable_dynamic(contenteditable);
        }
      }
    } else {
      const match = fuzzymatch(node.name, Object.keys(binding_properties));
      if (match) {
        const property = binding_properties[match];
        if (!property.valid_elements || property.valid_elements.includes(parent.name)) {
          bind_invalid_name(node, node.name, `Did you mean '${match}'?`);
        }
      }
      bind_invalid_name(node, node.name);
    }
  }
  if (node.expression.type === "SequenceExpression") {
    if (node.name === "group") {
      bind_group_invalid_expression(node);
    }
    let i = (
      /** @type {number} */
      node.expression.start
    );
    let leading_comments_start = (
      /**@type {any}*/
      (_b = (_a2 = node.expression.leadingComments) == null ? void 0 : _a2.at(0)) == null ? void 0 : _b.start
    );
    let leading_comments_end = (
      /**@type {any}*/
      (_d = (_c = node.expression.leadingComments) == null ? void 0 : _c.at(-1)) == null ? void 0 : _d.end
    );
    while (context.state.analysis.source[--i] !== "{") {
      if (context.state.analysis.source[i] === "(" && // if the parenthesis is in a leading comment we don't need to throw the error
      !(leading_comments_start && leading_comments_end && i <= leading_comments_end && i >= leading_comments_start)) {
        bind_invalid_parens(node, node.name);
      }
    }
    if (node.expression.expressions.length !== 2) {
      bind_invalid_expression(node);
    }
    mark_subtree_dynamic(context.path);
    return;
  }
  validate_assignment(node, node.expression, context.state);
  const assignee = node.expression;
  const left = object2(assignee);
  if (left === null) {
    bind_invalid_expression(node);
  }
  const binding = context.state.scope.get(left.name);
  if (assignee.type === "Identifier") {
    if (node.name !== "this" && // bind:this also works for regular variables
    (!binding || binding.kind !== "state" && binding.kind !== "raw_state" && binding.kind !== "prop" && binding.kind !== "bindable_prop" && binding.kind !== "each" && binding.kind !== "store_sub" && !binding.updated)) {
      bind_invalid_value(node.expression);
    }
  }
  if (node.name === "group") {
    if (!binding) {
      throw new Error("Cannot find declaration for bind:group");
    }
    if (binding.kind === "snippet") {
      bind_group_invalid_snippet_parameter(node);
    }
    const each_blocks = [];
    const [keypath, expression_ids] = extract_all_identifiers_from_expression(node.expression);
    let ids = expression_ids;
    let i = context.path.length;
    while (i--) {
      const parent2 = context.path[i];
      if (parent2.type === "EachBlock") {
        const references = ids.filter((id2) => parent2.metadata.declarations.has(id2.name));
        if (references.length > 0) {
          parent2.metadata.contains_group_binding = true;
          each_blocks.push(parent2);
          ids = ids.filter((id2) => !references.includes(id2));
          ids.push(...extract_all_identifiers_from_expression(parent2.expression)[1]);
        }
      }
    }
    const bindings = expression_ids.map((id2) => context.state.scope.get(id2.name));
    let group_name;
    outer: for (const [[key2, b], group] of context.state.analysis.binding_groups) {
      if (b.length !== bindings.length || key2 !== keypath) continue;
      for (let i2 = 0; i2 < bindings.length; i2++) {
        if (bindings[i2] !== b[i2]) continue outer;
      }
      group_name = group;
    }
    if (!group_name) {
      group_name = context.state.scope.root.unique("binding_group");
      context.state.analysis.binding_groups.set([keypath, bindings], group_name);
    }
    node.metadata = {
      binding_group_name: group_name,
      parent_each_blocks: each_blocks
    };
  }
  if ((binding == null ? void 0 : binding.kind) === "each" && ((_e = binding.metadata) == null ? void 0 : _e.inside_rest)) {
    bind_invalid_each_rest(binding.node, binding.node.name);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/CallExpression.js
function CallExpression(node, context) {
  var _a2, _b;
  const parent = (
    /** @type {AST.SvelteNode} */
    get_parent(context.path, -1)
  );
  const rune = get_rune(node, context.state.scope);
  if (rune && rune !== "$inspect") {
    for (const arg of node.arguments) {
      if (arg.type === "SpreadElement") {
        rune_invalid_spread(node, rune);
      }
    }
  }
  switch (rune) {
    case null:
      if (!is_safe_identifier(node.callee, context.state.scope)) {
        context.state.analysis.needs_context = true;
      }
      break;
    case "$bindable":
      if (node.arguments.length > 1) {
        rune_invalid_arguments_length(node, "$bindable", "zero or one arguments");
      }
      if (parent.type !== "AssignmentPattern" || ((_a2 = context.path.at(-3)) == null ? void 0 : _a2.type) !== "ObjectPattern" || ((_b = context.path.at(-4)) == null ? void 0 : _b.type) !== "VariableDeclarator" || get_rune(
        /** @type {VariableDeclarator} */
        context.path.at(-4).init,
        context.state.scope
      ) !== "$props") {
        bindable_invalid_location(node);
      }
      context.state.analysis.needs_context = true;
      break;
    case "$host":
      if (node.arguments.length > 0) {
        rune_invalid_arguments(node, "$host");
      } else if (context.state.ast_type === "module" || !context.state.analysis.custom_element) {
        host_invalid_placement(node);
      }
      break;
    case "$props":
      if (context.state.has_props_rune) {
        props_duplicate(node, rune);
      }
      context.state.has_props_rune = true;
      if (parent.type !== "VariableDeclarator" || context.state.ast_type !== "instance" || context.state.scope !== context.state.analysis.instance.scope) {
        props_invalid_placement(node);
      }
      if (node.arguments.length > 0) {
        rune_invalid_arguments(node, rune);
      }
      break;
    case "$props.id": {
      const grand_parent = get_parent(context.path, -2);
      if (context.state.analysis.props_id) {
        props_duplicate(node, rune);
      }
      if (parent.type !== "VariableDeclarator" || parent.id.type !== "Identifier" || context.state.ast_type !== "instance" || context.state.scope !== context.state.analysis.instance.scope || grand_parent.type !== "VariableDeclaration") {
        props_id_invalid_placement(node);
      }
      if (node.arguments.length > 0) {
        rune_invalid_arguments(node, rune);
      }
      context.state.analysis.props_id = parent.id;
      break;
    }
    case "$state":
    case "$state.raw":
    case "$derived":
    case "$derived.by":
      if ((parent.type !== "VariableDeclarator" || get_parent(context.path, -3).type === "ConstTag") && !(parent.type === "PropertyDefinition" && !parent.static && !parent.computed)) {
        state_invalid_placement(node, rune);
      }
      if ((rune === "$derived" || rune === "$derived.by") && node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      } else if (node.arguments.length > 1) {
        rune_invalid_arguments_length(node, rune, "zero or one arguments");
      }
      break;
    case "$effect":
    case "$effect.pre":
      if (parent.type !== "ExpressionStatement") {
        effect_invalid_placement(node);
      }
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      context.state.analysis.needs_context = true;
      break;
    case "$effect.tracking":
      if (node.arguments.length !== 0) {
        rune_invalid_arguments(node, rune);
      }
      break;
    case "$effect.root":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
    case "$inspect":
      if (node.arguments.length < 1) {
        rune_invalid_arguments_length(node, rune, "one or more arguments");
      }
      break;
    case "$inspect().with":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
    case "$inspect.trace": {
      if (node.arguments.length > 1) {
        rune_invalid_arguments_length(node, rune, "zero or one arguments");
      }
      const grand_parent = context.path.at(-2);
      const fn = context.path.at(-3);
      if (parent.type !== "ExpressionStatement" || (grand_parent == null ? void 0 : grand_parent.type) !== "BlockStatement" || !((fn == null ? void 0 : fn.type) === "FunctionDeclaration" || (fn == null ? void 0 : fn.type) === "FunctionExpression" || (fn == null ? void 0 : fn.type) === "ArrowFunctionExpression") || grand_parent.body[0] !== parent) {
        inspect_trace_invalid_placement(node);
      }
      if (fn.generator) {
        inspect_trace_generator(node);
      }
      if (dev) {
        if (node.arguments[0]) {
          context.state.scope.tracing = thunk(
            /** @type {Expression} */
            node.arguments[0]
          );
        } else {
          const label = get_function_label(context.path.slice(0, -2)) ?? "trace";
          const loc = `(${locate_node(fn)})`;
          context.state.scope.tracing = thunk(literal(label + " " + loc));
        }
        context.state.analysis.tracing = true;
      }
      break;
    }
    case "$state.snapshot":
      if (node.arguments.length !== 1) {
        rune_invalid_arguments_length(node, rune, "exactly one argument");
      }
      break;
  }
  if (rune === "$inspect" || rune === "$derived") {
    context.next({ ...context.state, function_depth: context.state.function_depth + 1 });
  } else {
    context.next();
  }
  if (context.state.expression) {
    if (!is_pure(node.callee, context) || context.state.expression.dependencies.size > 0) {
      context.state.expression.has_call = true;
      context.state.expression.has_state = true;
    }
  }
}
function get_function_label(nodes) {
  const fn = (
    /** @type {FunctionExpression | FunctionDeclaration | ArrowFunctionExpression} */
    nodes.at(-1)
  );
  if ((fn.type === "FunctionDeclaration" || fn.type === "FunctionExpression") && fn.id != null) {
    return fn.id.name;
  }
  const parent = nodes.at(-2);
  if (!parent) return;
  if (parent.type === "CallExpression") {
    return source.slice(parent.callee.start, parent.callee.end) + "(...)";
  }
  if (parent.type === "Property" && !parent.computed) {
    return (
      /** @type {Identifier} */
      parent.key.name
    );
  }
  if (parent.type === "VariableDeclarator" && parent.id.type === "Identifier") {
    return parent.id.name;
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ClassBody.js
function ClassBody(node, context) {
  var _a2;
  const derived_state = [];
  for (const definition of node.body) {
    if (definition.type === "PropertyDefinition" && (definition.key.type === "PrivateIdentifier" || definition.key.type === "Identifier") && ((_a2 = definition.value) == null ? void 0 : _a2.type) === "CallExpression") {
      const rune = get_rune(definition.value, context.state.scope);
      if (rune === "$derived" || rune === "$derived.by") {
        derived_state.push({
          name: definition.key.name,
          private: definition.key.type === "PrivateIdentifier"
        });
      }
    }
  }
  context.next({ ...context.state, derived_state });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ClassDeclaration.js
function ClassDeclaration(node, context) {
  if (context.state.analysis.runes && node.id !== null) {
    validate_identifier_name(context.state.scope.get(node.id.name));
  }
  const allowed_depth = context.state.ast_type === "module" ? 0 : 1;
  if (context.state.scope.function_depth > allowed_depth) {
    perf_avoid_nested_class(node);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ClassDirective.js
function ClassDirective(node, context) {
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/attribute.js
function validate_attribute_name(attribute) {
  if (attribute.name.includes(":") && !attribute.name.startsWith("xmlns:") && !attribute.name.startsWith("xlink:") && !attribute.name.startsWith("xml:")) {
    attribute_illegal_colon(attribute);
  }
}
function validate_attribute(attribute, parent) {
  var _a2;
  if (Array.isArray(attribute.value) && attribute.value.length === 1 && attribute.value[0].type === "ExpressionTag" && (parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteSelf" || parent.type === "RegularElement" && is_custom_element_node(parent))) {
    attribute_quoted(attribute);
  }
  if (attribute.value === true || !Array.isArray(attribute.value) || attribute.value.length === 1) {
    return;
  }
  const is_quoted = ((_a2 = attribute.value.at(-1)) == null ? void 0 : _a2.end) !== attribute.end;
  if (!is_quoted) {
    attribute_unquoted_sequence(attribute);
  }
}
function validate_slot_attribute(context, attribute, is_component = false) {
  const parent = context.path.at(-2);
  let owner = void 0;
  if ((parent == null ? void 0 : parent.type) === "SnippetBlock") {
    if (!is_text_attribute(attribute)) {
      slot_attribute_invalid(attribute);
    }
    return;
  }
  let i = context.path.length;
  while (i--) {
    const ancestor = context.path[i];
    if (!owner && (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteSelf" || ancestor.type === "SvelteElement" || ancestor.type === "RegularElement" && is_custom_element_node(ancestor))) {
      owner = ancestor;
    }
  }
  if (owner) {
    if (owner.type === "Component" || owner.type === "SvelteComponent" || owner.type === "SvelteSelf") {
      if (owner !== parent) {
        if (!is_component) {
          slot_attribute_invalid_placement(attribute);
        }
      } else {
        if (!is_text_attribute(attribute)) {
          slot_attribute_invalid(attribute);
        }
        const name = attribute.value[0].data;
        if (context.state.component_slots.has(name)) {
          slot_attribute_duplicate(attribute, name, owner.name);
        }
        context.state.component_slots.add(name);
        if (name === "default") {
          for (const node of owner.fragment.nodes) {
            if (node.type === "Text" && regex_only_whitespaces.test(node.data)) {
              continue;
            }
            if (node.type === "RegularElement" || node.type === "SvelteFragment") {
              if (node.attributes.some((a) => a.type === "Attribute" && a.name === "slot")) {
                continue;
              }
            }
            slot_default_duplicate(node);
          }
        }
      }
    }
  } else if (!is_component) {
    slot_attribute_invalid_placement(attribute);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/snippets.js
function is_resolved_snippet(binding) {
  var _a2;
  return !binding || binding.declaration_kind === "import" || binding.kind === "prop" || binding.kind === "rest_prop" || binding.kind === "bindable_prop" || ((_a2 = binding == null ? void 0 : binding.initial) == null ? void 0 : _a2.type) === "SnippetBlock";
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/component.js
function visit_component(node, context) {
  var _a2;
  node.metadata.path = [...context.path];
  node.metadata.snippets = /* @__PURE__ */ new Set();
  let resolved = true;
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "BindDirective") {
      resolved = false;
      continue;
    }
    if (attribute.type !== "Attribute" || !is_expression_attribute(attribute)) {
      continue;
    }
    const expression = get_attribute_expression(attribute);
    if (expression.type === "Identifier") {
      const binding = context.state.scope.get(expression.name);
      resolved && (resolved = is_resolved_snippet(binding));
      if (((_a2 = binding == null ? void 0 : binding.initial) == null ? void 0 : _a2.type) === "SnippetBlock") {
        node.metadata.snippets.add(binding.initial);
      }
    } else if (expression.type !== "Literal") {
      resolved = false;
    }
  }
  if (resolved) {
    for (const child of node.fragment.nodes) {
      if (child.type === "SnippetBlock") {
        node.metadata.snippets.add(child);
      }
    }
  }
  context.state.analysis.snippet_renderers.set(node, resolved);
  mark_subtree_dynamic(context.path);
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute" && attribute.type !== "SpreadAttribute" && attribute.type !== "LetDirective" && attribute.type !== "OnDirective" && attribute.type !== "BindDirective") {
      component_invalid_directive(attribute);
    }
    if (attribute.type === "OnDirective" && (attribute.modifiers.length > 1 || attribute.modifiers.some((m) => m !== "once"))) {
      event_handler_invalid_component_modifier(attribute);
    }
    if (attribute.type === "Attribute") {
      if (context.state.analysis.runes) {
        validate_attribute(attribute, node);
        if (is_expression_attribute(attribute)) {
          const expression = get_attribute_expression(attribute);
          if (expression.type === "SequenceExpression") {
            let i = (
              /** @type {number} */
              expression.start
            );
            while (--i > 0) {
              const char = context.state.analysis.source[i];
              if (char === "(") break;
              if (char === "{") attribute_invalid_sequence_expression(expression);
            }
          }
        }
      }
      validate_attribute_name(attribute);
      if (attribute.name === "slot") {
        validate_slot_attribute(context, attribute, true);
      }
    }
    if (attribute.type === "BindDirective" && attribute.name !== "this") {
      context.state.analysis.uses_component_bindings = true;
    }
  }
  const default_state = determine_slot(node) ? context.state : { ...context.state, scope: node.metadata.scopes.default };
  for (const attribute of node.attributes) {
    context.visit(attribute, attribute.type === "LetDirective" ? default_state : context.state);
  }
  let comments = [];
  const nodes = { default: [] };
  for (const child of node.fragment.nodes) {
    if (child.type === "Comment") {
      comments.push(child);
      continue;
    }
    const slot_name = determine_slot(child) ?? "default";
    (nodes[slot_name] ?? (nodes[slot_name] = [])).push(...comments, child);
    if (slot_name !== "default") comments = [];
  }
  const component_slots = /* @__PURE__ */ new Set();
  for (const slot_name in nodes) {
    const state = {
      ...context.state,
      scope: node.metadata.scopes[slot_name],
      parent_element: null,
      component_slots
    };
    context.visit({ ...node.fragment, nodes: nodes[slot_name] }, state);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Component.js
function Component(node, context) {
  const binding = context.state.scope.get(
    node.name.includes(".") ? node.name.slice(0, node.name.indexOf(".")) : node.name
  );
  node.metadata.dynamic = context.state.analysis.runes && // Svelte 4 required you to use svelte:component to switch components
  binding !== null && (binding.kind !== "normal" || node.name.includes("."));
  visit_component(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ConstTag.js
function ConstTag(node, context) {
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "@");
  }
  const parent = context.path.at(-1);
  const grand_parent = context.path.at(-2);
  if ((parent == null ? void 0 : parent.type) !== "Fragment" || (grand_parent == null ? void 0 : grand_parent.type) !== "IfBlock" && (grand_parent == null ? void 0 : grand_parent.type) !== "SvelteFragment" && (grand_parent == null ? void 0 : grand_parent.type) !== "Component" && (grand_parent == null ? void 0 : grand_parent.type) !== "SvelteComponent" && (grand_parent == null ? void 0 : grand_parent.type) !== "EachBlock" && (grand_parent == null ? void 0 : grand_parent.type) !== "AwaitBlock" && (grand_parent == null ? void 0 : grand_parent.type) !== "SnippetBlock" && (grand_parent == null ? void 0 : grand_parent.type) !== "SvelteBoundary" && (grand_parent == null ? void 0 : grand_parent.type) !== "KeyBlock" && ((grand_parent == null ? void 0 : grand_parent.type) !== "RegularElement" && (grand_parent == null ? void 0 : grand_parent.type) !== "SvelteElement" || !grand_parent.attributes.some((a) => a.type === "Attribute" && a.name === "slot"))) {
    const_tag_invalid_placement(node);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/DebugTag.js
function DebugTag(node, context) {
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "@");
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/EachBlock.js
function EachBlock(node, context) {
  validate_opening_tag(node, context.state, "#");
  validate_block_not_empty(node.body, context);
  validate_block_not_empty(node.fallback, context);
  const id2 = node.context;
  if ((id2 == null ? void 0 : id2.type) === "Identifier" && (id2.name === "$state" || id2.name === "$derived")) {
    state_invalid_placement(node, id2.name);
  }
  if (node.key) {
    node.metadata.keyed = node.key.type !== "Identifier" || !node.index || node.key.name !== node.index;
  }
  context.visit(node.expression, {
    ...context.state,
    expression: node.metadata.expression,
    scope: (
      /** @type {Scope} */
      context.state.scope.parent
    )
  });
  context.visit(node.body);
  if (node.key) context.visit(node.key);
  if (node.fallback) context.visit(node.fallback);
  mark_subtree_dynamic(context.path);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExportDefaultDeclaration.js
function ExportDefaultDeclaration(node, context) {
  if (!context.state.ast_type) {
    if (node.declaration.type === "Identifier") {
      validate_export(node, context.state.scope, node.declaration.name);
    }
  } else {
    module_illegal_default_export(node);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExportNamedDeclaration.js
function ExportNamedDeclaration(node, context) {
  var _a2;
  context.next();
  if (((_a2 = node.declaration) == null ? void 0 : _a2.type) === "VariableDeclaration") {
    if (context.state.analysis.runes && context.state.ast_type === "instance" && node.declaration.kind === "let") {
      legacy_export_invalid(node);
    }
    for (const declarator2 of node.declaration.declarations) {
      for (const id2 of extract_identifiers(declarator2.id)) {
        const binding = context.state.scope.get(id2.name);
        if (!binding) continue;
        if (binding.kind === "derived") {
          derived_invalid_export(node);
        }
        if ((binding.kind === "state" || binding.kind === "raw_state") && binding.reassigned) {
          state_invalid_export(node);
        }
      }
    }
  }
  if (context.state.analysis.runes) {
    if (node.declaration && context.state.ast_type === "instance") {
      if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
        context.state.analysis.exports.push({
          name: (
            /** @type {Identifier} */
            node.declaration.id.name
          ),
          alias: null
        });
      } else if (node.declaration.kind === "const") {
        for (const declarator2 of node.declaration.declarations) {
          for (const node2 of extract_identifiers(declarator2.id)) {
            context.state.analysis.exports.push({ name: node2.name, alias: null });
          }
        }
      }
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExportSpecifier.js
function ExportSpecifier(node, context) {
  const local_name = node.local.type === "Identifier" ? node.local.name : (
    /** @type {string} */
    node.local.value
  );
  const exported_name = node.exported.type === "Identifier" ? node.exported.name : (
    /** @type {string} */
    node.exported.value
  );
  if (context.state.ast_type === "instance") {
    if (context.state.analysis.runes) {
      context.state.analysis.exports.push({
        name: local_name,
        alias: exported_name
      });
      const binding = context.state.scope.get(local_name);
      if (binding) binding.reassigned = true;
    }
  } else {
    validate_export(node, context.state.scope, local_name);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExpressionStatement.js
function ExpressionStatement(node, context) {
  if (node.expression.type === "NewExpression" && node.expression.callee.type === "Identifier" && node.expression.arguments.length === 1 && node.expression.arguments[0].type === "ObjectExpression" && node.expression.arguments[0].properties.some(
    (p) => p.type === "Property" && p.key.type === "Identifier" && p.key.name === "target"
  )) {
    const binding = context.state.scope.get(node.expression.callee.name);
    if ((binding == null ? void 0 : binding.kind) === "normal" && binding.declaration_kind === "import") {
      const declaration2 = (
        /** @type {ImportDeclaration} */
        binding.initial
      );
      if (
        /** @type {string} */
        declaration2.source.value.endsWith(".svelte") && declaration2.specifiers.find(
          (s) => s.local.name === binding.node.name && s.type === "ImportDefaultSpecifier"
        )
      ) {
        legacy_component_creation(node.expression);
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ExpressionTag.js
function ExpressionTag(node, context) {
  var _a2;
  const in_template = ((_a2 = context.path.at(-1)) == null ? void 0 : _a2.type) === "Fragment";
  if (in_template && context.state.parent_element) {
    const message = is_tag_valid_with_parent("#text", context.state.parent_element);
    if (message) {
      node_invalid_placement(node, message);
    }
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/FunctionDeclaration.js
function FunctionDeclaration(node, context) {
  if (context.state.analysis.runes && node.id !== null) {
    validate_identifier_name(context.state.scope.get(node.id.name));
  }
  visit_function(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/FunctionExpression.js
function FunctionExpression(node, context) {
  visit_function(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/HtmlTag.js
function HtmlTag(node, context) {
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "@");
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/utils.js
function memoize_expression(state, value) {
  const id2 = id(state.scope.generate("expression"));
  state.init.push(const_builder(id2, create_derived(state, thunk(value))));
  return call("$.get", id2);
}
function get_expression_id(state, value) {
  return id(`$${state.expressions.push(value) - 1}`);
}
function build_template_chunk(values, visit, state, memoize = (value, metadata) => metadata.has_call ? get_expression_id(state, value) : value) {
  const expressions = [];
  let quasi2 = quasi("");
  const quasis = [quasi2];
  let has_state = false;
  for (let i = 0; i < values.length; i++) {
    const node = values[i];
    if (node.type === "Text") {
      quasi2.value.cooked += node.data;
    } else if (node.expression.type === "Literal") {
      if (node.expression.value != null) {
        quasi2.value.cooked += node.expression.value + "";
      }
    } else if (node.expression.type !== "Identifier" || node.expression.name !== "undefined" || state.scope.get("undefined")) {
      let value2 = memoize(
        /** @type {Expression} */
        visit(node.expression, state),
        node.metadata.expression
      );
      const evaluated = state.scope.evaluate(value2);
      has_state || (has_state = node.metadata.expression.has_state && !evaluated.is_known);
      if (values.length === 1) {
        if (evaluated.is_known) {
          value2 = literal((evaluated.value ?? "") + "");
        }
        return { value: value2, has_state };
      }
      if (value2.type === "LogicalExpression" && value2.right.type === "Literal" && (value2.operator === "??" || value2.operator === "||")) {
        if (value2.right.value === null) {
          value2 = { ...value2, right: literal("") };
        }
      }
      if (evaluated.is_known) {
        quasi2.value.cooked += (evaluated.value ?? "") + "";
      } else {
        if (!evaluated.is_defined) {
          value2 = logical("??", value2, literal(""));
        }
        expressions.push(value2);
        quasi2 = quasi("", i + 1 === values.length);
        quasis.push(quasi2);
      }
    }
  }
  for (const quasi3 of quasis) {
    quasi3.value.raw = sanitize_template_string(
      /** @type {string} */
      quasi3.value.cooked
    );
  }
  const value = expressions.length > 0 ? template(quasis, expressions) : literal(
    /** @type {string} */
    quasi2.value.cooked
  );
  return { value, has_state };
}
function build_render_statement(state) {
  return stmt(
    call(
      "$.template_effect",
      arrow(
        state.expressions.map((_, i) => id(`$${i}`)),
        state.update.length === 1 && state.update[0].type === "ExpressionStatement" ? state.update[0].expression : block(state.update)
      ),
      state.expressions.length > 0 && array(state.expressions.map((expression) => thunk(expression))),
      state.expressions.length > 0 && !state.analysis.runes && id("$.derived_safe_equal")
    )
  );
}
function parse_directive_name(name) {
  const parts = name.split(".");
  let part = (
    /** @type {string} */
    parts.shift()
  );
  let expression = id(part);
  while (part = /** @type {string} */
  parts.shift()) {
    const computed = !regex_is_valid_identifier.test(part);
    expression = member(expression, computed ? literal(part) : id(part), computed);
  }
  return expression;
}
function build_update_assignment(state, id2, init2, value, update2) {
  state.init.push(var_builder(id2, init2));
  state.update.push(
    if_builder(binary("!==", id(id2), assignment("=", id(id2), value)), block([update2]))
  );
}
function build_bind_this(expression, value, { state, visit }) {
  if (expression.type === "SequenceExpression") {
    const [get3, set3] = (
      /** @type {SequenceExpression} */
      visit(expression).expressions
    );
    return call("$.bind_this", value, set3, get3);
  }
  const ids = [];
  const values = [];
  const seen2 = [];
  const transform = { ...state.transform };
  walk(expression, null, {
    Identifier(node2, { path }) {
      if (seen2.includes(node2.name)) return;
      seen2.push(node2.name);
      const parent = (
        /** @type {Expression} */
        path.at(-1)
      );
      if (!is_reference(node2, parent)) return;
      const binding = state.scope.get(node2.name);
      if (!binding) return;
      for (const [owner, scope] of state.scopes) {
        if (owner.type === "EachBlock" && scope === binding.scope) {
          ids.push(node2);
          values.push(
            /** @type {Expression} */
            visit(node2)
          );
          if (transform[node2.name]) {
            transform[node2.name] = {
              ...transform[node2.name],
              read: (node3) => node3
            };
          }
          break;
        }
      }
    }
  });
  const child_state = { ...state, transform };
  const get2 = (
    /** @type {Expression} */
    visit(expression, child_state)
  );
  const set2 = (
    /** @type {Expression} */
    visit(assignment("=", expression, id("$$value")), child_state)
  );
  let node = get2;
  while (node.type === "MemberExpression") {
    node.optional = true;
    node = node.object;
  }
  return call(
    "$.bind_this",
    value,
    arrow([id("$$value"), ...ids], set2),
    arrow([...ids], get2),
    values.length > 0 && thunk(array(values))
  );
}
function validate_binding(state, binding, expression) {
  if (binding.expression.type === "SequenceExpression") {
    return;
  }
  const left = object2(binding.expression);
  const left_binding = left && state.scope.get(left.name);
  if ((left_binding == null ? void 0 : left_binding.kind) === "store_sub") return;
  const loc = locator(binding.start);
  const obj = (
    /** @type {Expression} */
    expression.object
  );
  state.init.push(
    stmt(
      call(
        "$.validate_binding",
        literal(state.analysis.source.slice(binding.start, binding.end)),
        thunk(
          state.store_to_invalidate ? sequence([call("$.mark_store_binding"), obj]) : obj
        ),
        thunk(
          /** @type {Expression} */
          expression.computed ? expression.property : literal(
            /** @type {Identifier} */
            expression.property.name
          )
        ),
        loc && literal(loc.line),
        loc && literal(loc.column)
      )
    )
  );
}
function validate_mutation(node, context, expression) {
  let left = (
    /** @type {Expression | Super} */
    node.type === "AssignmentExpression" ? node.left : node.argument
  );
  if (!dev || left.type !== "MemberExpression" || is_ignored(node, "ownership_invalid_mutation")) {
    return expression;
  }
  const name = object2(left);
  if (!name) return expression;
  const binding = context.state.scope.get(name.name);
  if ((binding == null ? void 0 : binding.kind) !== "prop" && (binding == null ? void 0 : binding.kind) !== "bindable_prop") return expression;
  const state = (
    /** @type {ComponentClientTransformState} */
    context.state
  );
  state.analysis.needs_mutation_validation = true;
  const path = [];
  while (left.type === "MemberExpression") {
    if (left.property.type === "Literal") {
      path.unshift(left.property);
    } else if (left.property.type === "Identifier") {
      const transform = Object.hasOwn(context.state.transform, left.property.name) ? context.state.transform[left.property.name] : null;
      if (left.computed) {
        path.unshift((transform == null ? void 0 : transform.read) ? transform.read(left.property) : left.property);
      } else {
        path.unshift(literal(left.property.name));
      }
    } else {
      return expression;
    }
    left = left.object;
  }
  path.unshift(literal(name.name));
  const loc = locator(
    /** @type {number} */
    left.start
  );
  return call(
    "$$ownership_validator.mutation",
    literal(binding.prop_alias),
    array(path),
    expression,
    loc && literal(loc.line),
    loc && literal(loc.column)
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/utils.js
function is_state_source(binding, analysis) {
  return (binding.kind === "state" || binding.kind === "raw_state") && (!analysis.immutable || binding.reassigned || analysis.accessors);
}
function build_getter(node, state) {
  if (Object.hasOwn(state.transform, node.name)) {
    const binding = state.scope.get(node.name);
    if (node !== (binding == null ? void 0 : binding.node)) {
      return state.transform[node.name].read(node);
    }
  }
  return node;
}
function get_hoisted_params(node, context) {
  var _a2;
  const scope = context.state.scope;
  const params = [];
  function push_unique(id2) {
    if (!params.find((param) => param.name === id2.name)) {
      params.push(id2);
    }
  }
  for (const [reference] of scope.references) {
    let binding = scope.get(reference);
    if (binding !== null && !scope.declarations.has(reference) && binding.initial !== node) {
      if (binding.kind === "store_sub") {
        push_unique(id(binding.node.name));
        binding = /** @type {Binding} */
        scope.get(binding.node.name.slice(1));
      }
      let expression = (_a2 = context.state.transform[reference]) == null ? void 0 : _a2.read(id(binding.node.name));
      if (
        // If it's a destructured derived binding, then we can extract the derived signal reference and use that.
        // TODO this code is bad, we need to kill it
        expression != null && typeof expression !== "function" && expression.type === "MemberExpression" && expression.object.type === "CallExpression" && expression.object.callee.type === "Identifier" && expression.object.callee.name === "$.get" && expression.object.arguments[0].type === "Identifier"
      ) {
        push_unique(id(expression.object.arguments[0].name));
      } else if (
        // If we are referencing a simple $$props value, then we need to reference the object property instead
        (binding.kind === "prop" || binding.kind === "bindable_prop") && !is_prop_source(binding, context.state)
      ) {
        push_unique(id("$$props"));
      } else if (
        // imports don't need to be hoisted
        binding.declaration_kind !== "import"
      ) {
        push_unique(id(binding.node.name));
        if (binding.kind === "rest_prop" && context.state.analysis.runes) {
          push_unique(id("$$props"));
        }
      }
    }
  }
  if (dev) {
    let visit = function(node2, { next: next2, stop }) {
      if (validate_mutation(
        node2,
        /** @type {any} */
        context,
        node2
      ) !== node2) {
        params.push(id("$$ownership_validator"));
        stop();
      } else {
        next2();
      }
    };
    walk(
      /** @type {Node} */
      node,
      null,
      {
        AssignmentExpression: visit,
        UpdateExpression: visit
      }
    );
  }
  return params;
}
function build_hoisted_params(node, context) {
  const hoisted_params = get_hoisted_params(node, context);
  node.metadata.hoisted_params = hoisted_params;
  const params = [];
  if (node.params.length === 0) {
    if (hoisted_params.length > 0) {
      params.push(id(context.state.scope.generate("_")));
    }
  } else {
    for (const param of node.params) {
      params.push(
        /** @type {Pattern} */
        context.visit(param)
      );
    }
  }
  params.push(...hoisted_params);
  return params;
}
function get_prop_source(binding, state, name, initial) {
  const args = [id("$$props"), literal(name)];
  let flags = 0;
  if (binding.kind === "bindable_prop") {
    flags |= PROPS_IS_BINDABLE;
  }
  if (state.analysis.immutable) {
    flags |= PROPS_IS_IMMUTABLE;
  }
  if (state.analysis.runes) {
    flags |= PROPS_IS_RUNES;
  }
  if (state.analysis.accessors || (state.analysis.immutable ? binding.reassigned || state.analysis.runes && binding.mutated : binding.updated)) {
    flags |= PROPS_IS_UPDATED;
  }
  let arg;
  if (initial) {
    if (is_simple_expression(initial)) {
      arg = initial;
    } else {
      if (initial.type === "CallExpression" && initial.callee.type === "Identifier" && initial.arguments.length === 0) {
        arg = initial.callee;
      } else {
        arg = thunk(initial);
      }
      flags |= PROPS_IS_LAZY_INITIAL;
    }
  }
  if (flags || arg) {
    args.push(literal(flags));
    if (arg) args.push(arg);
  }
  return call("$.prop", ...args);
}
function is_prop_source(binding, state) {
  return (binding.kind === "prop" || binding.kind === "bindable_prop") && (!state.analysis.runes || state.analysis.accessors || binding.reassigned || binding.initial || // Until legacy mode is gone, we also need to use the prop source when only mutated is true,
  // because the parent could be a legacy component which needs coarse-grained reactivity
  binding.updated);
}
function should_proxy(node, scope) {
  if (!node || node.type === "Literal" || node.type === "TemplateLiteral" || node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression" || node.type === "UnaryExpression" || node.type === "BinaryExpression" || node.type === "Identifier" && node.name === "undefined") {
    return false;
  }
  if (node.type === "Identifier" && scope !== null) {
    const binding = scope.get(node.name);
    if (binding !== null && !binding.reassigned && binding.initial !== null && binding.initial.type !== "FunctionDeclaration" && binding.initial.type !== "ClassDeclaration" && binding.initial.type !== "ImportDeclaration" && binding.initial.type !== "EachBlock" && binding.initial.type !== "SnippetBlock") {
      return should_proxy(binding.initial, null);
    }
  }
  return true;
}
function create_derived(state, arg) {
  return call(state.analysis.runes ? "$.derived" : "$.derived_safe_equal", arg);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Identifier.js
function Identifier(node, context) {
  var _a2, _b, _c;
  let i = context.path.length;
  let parent = (
    /** @type {Expression} */
    context.path[--i]
  );
  if (!is_reference(node, parent)) {
    return;
  }
  mark_subtree_dynamic(context.path);
  if (node.name === "arguments" && !context.path.some((n) => n.type === "FunctionDeclaration" || n.type === "FunctionExpression")) {
    invalid_arguments_usage(node);
  }
  if (node.name === "$$slots") {
    context.state.analysis.uses_slots = true;
  }
  if (context.state.analysis.runes) {
    if (is_rune(node.name) && context.state.scope.get(node.name) === null && ((_a2 = context.state.scope.get(node.name.slice(1))) == null ? void 0 : _a2.kind) !== "store_sub") {
      let current = node;
      let name = node.name;
      while (parent.type === "MemberExpression") {
        if (parent.computed) rune_invalid_computed_property(parent);
        name += `.${/** @type {Identifier} */
        parent.property.name}`;
        current = parent;
        parent = /** @type {Expression} */
        context.path[--i];
        if (!is_rune(name)) {
          if (name === "$effect.active") {
            rune_renamed(parent, "$effect.active", "$effect.tracking");
          }
          if (name === "$state.frozen") {
            rune_renamed(parent, "$state.frozen", "$state.raw");
          }
          if (name === "$state.is") {
            rune_removed(parent, "$state.is");
          }
          rune_invalid_name(parent, name);
        }
      }
      if (parent.type !== "CallExpression") {
        rune_missing_parentheses(current);
      }
    }
  }
  let binding = context.state.scope.get(node.name);
  if (!context.state.analysis.runes) {
    if (node.name === "$$props") {
      context.state.analysis.uses_props = true;
    }
    if (node.name === "$$restProps") {
      context.state.analysis.uses_rest_props = true;
    }
  }
  if (binding) {
    if (context.state.expression) {
      context.state.expression.dependencies.add(binding);
      (_b = context.state.expression).has_state || (_b.has_state = binding.kind !== "normal");
    }
    if (context.state.analysis.runes && node !== binding.node && context.state.function_depth === binding.scope.function_depth && // If we have $state that can be proxied or frozen and isn't re-assigned, then that means
    // it's likely not using a primitive value and thus this warning isn't that helpful.
    (binding.kind === "state" && (binding.reassigned || ((_c = binding.initial) == null ? void 0 : _c.type) === "CallExpression" && binding.initial.arguments.length === 1 && binding.initial.arguments[0].type !== "SpreadElement" && !should_proxy(binding.initial.arguments[0], context.state.scope)) || binding.kind === "raw_state" || binding.kind === "derived") && // We're only concerned with reads here
    (parent.type !== "AssignmentExpression" || parent.left !== node) && parent.type !== "UpdateExpression") {
      let type = "closure";
      let i2 = context.path.length;
      while (i2--) {
        const parent2 = context.path[i2];
        if (parent2.type === "ArrowFunctionExpression" || parent2.type === "FunctionDeclaration" || parent2.type === "FunctionExpression") {
          break;
        }
        if (parent2.type === "CallExpression" && parent2.arguments.includes(
          /** @type {any} */
          context.path[i2 + 1]
        )) {
          const rune = get_rune(parent2, context.state.scope);
          if (rune === "$state" || rune === "$state.raw") {
            type = "derived";
            break;
          }
        }
      }
      state_referenced_locally(node, node.name, type);
    }
    if (context.state.reactive_statement && binding.scope === context.state.analysis.module.scope && binding.reassigned) {
      reactive_declaration_module_script_dependency(node);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/IfBlock.js
function IfBlock(node, context) {
  validate_block_not_empty(node.consequent, context);
  validate_block_not_empty(node.alternate, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, node.elseif ? ":" : "#");
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/ImportDeclaration.js
function ImportDeclaration(node, context) {
  if (context.state.analysis.runes) {
    const source2 = (
      /** @type {string} */
      node.source.value
    );
    if (source2.startsWith("svelte/internal")) {
      import_svelte_internal_forbidden(node);
    }
    if (source2 === "svelte") {
      for (const specifier of node.specifiers) {
        if (specifier.type === "ImportSpecifier") {
          if (specifier.imported.type === "Identifier" && (specifier.imported.name === "beforeUpdate" || specifier.imported.name === "afterUpdate")) {
            runes_mode_invalid_import(specifier, specifier.imported.name);
          }
        }
      }
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/KeyBlock.js
function KeyBlock(node, context) {
  validate_block_not_empty(node.fragment, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "#");
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/LabeledStatement.js
function LabeledStatement(node, context) {
  if (node.label.name === "$") {
    const parent = (
      /** @type {AST.SvelteNode} */
      context.path.at(-1)
    );
    const is_reactive_statement = context.state.ast_type === "instance" && parent.type === "Program";
    if (is_reactive_statement) {
      if (context.state.analysis.runes) {
        legacy_reactive_statement_invalid(node);
      }
      const reactive_statement = {
        assignments: /* @__PURE__ */ new Set(),
        dependencies: []
      };
      context.next({
        ...context.state,
        reactive_statement,
        function_depth: context.state.scope.function_depth + 1
      });
      for (const [name, nodes] of context.state.scope.references) {
        const binding = context.state.scope.get(name);
        if (binding === null) continue;
        for (const { node: node2, path } of nodes) {
          let left = node2;
          let i = path.length - 1;
          let parent2 = (
            /** @type {Expression} */
            path.at(i)
          );
          while (parent2.type === "MemberExpression") {
            left = parent2;
            parent2 = /** @type {Expression} */
            path.at(--i);
          }
          if (parent2.type === "AssignmentExpression" && parent2.operator === "=" && parent2.left === left) {
            continue;
          }
          reactive_statement.dependencies.push(binding);
          break;
        }
      }
      context.state.analysis.reactive_statements.set(node, reactive_statement);
      if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
        let ids = extract_identifiers(node.body.expression.left);
        if (node.body.expression.left.type === "MemberExpression") {
          const id2 = object2(node.body.expression.left);
          if (id2 !== null) {
            ids = [id2];
          }
        }
        for (const id2 of ids) {
          const binding = context.state.scope.get(id2.name);
          if ((binding == null ? void 0 : binding.kind) === "legacy_reactive") {
            binding.legacy_dependencies = Array.from(reactive_statement.dependencies);
          }
        }
      }
    } else if (!context.state.analysis.runes) {
      reactive_declaration_invalid_placement(node);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/LetDirective.js
function LetDirective(node, context) {
  const parent = context.path.at(-1);
  if (parent === void 0 || parent.type !== "Component" && parent.type !== "RegularElement" && parent.type !== "SlotElement" && parent.type !== "SvelteElement" && parent.type !== "SvelteComponent" && parent.type !== "SvelteSelf" && parent.type !== "SvelteFragment") {
    let_directive_invalid_placement(node);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Literal.js
function Literal(node) {
  if (typeof node.value === "string") {
    if (regex_bidirectional_control_characters.test(node.value)) {
      bidirectional_control_characters(node);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/MemberExpression.js
function MemberExpression(node, context) {
  if (node.object.type === "Identifier" && node.property.type === "Identifier") {
    const binding = context.state.scope.get(node.object.name);
    if ((binding == null ? void 0 : binding.kind) === "rest_prop" && node.property.name.startsWith("$$")) {
      props_illegal_name(node.property);
    }
  }
  if (context.state.expression && !is_pure(node, context)) {
    context.state.expression.has_state = true;
  }
  if (!is_safe_identifier(node, context.state.scope)) {
    context.state.analysis.needs_context = true;
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/NewExpression.js
function NewExpression(node, context) {
  if (node.callee.type === "ClassExpression" && context.state.scope.function_depth > 0) {
    perf_avoid_inline_class(node);
  }
  context.state.analysis.needs_context = true;
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/OnDirective.js
function OnDirective(node, context) {
  var _a2, _b;
  if (context.state.analysis.runes) {
    const parent_type = (_a2 = context.path.at(-1)) == null ? void 0 : _a2.type;
    if (parent_type === "RegularElement" || parent_type === "SvelteElement") {
      event_directive_deprecated(node, node.name);
    }
  }
  const parent = context.path.at(-1);
  if ((parent == null ? void 0 : parent.type) === "SvelteElement" || (parent == null ? void 0 : parent.type) === "RegularElement") {
    (_b = context.state.analysis).event_directive_node ?? (_b.event_directive_node = node);
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/a11y.js
var import_aria_query = __toESM(require_lib(), 1);
var import_axobject_query = __toESM(require_lib2(), 1);
var aria_roles = import_aria_query.roles.keys();
var abstract_roles = aria_roles.filter((role) => {
  var _a2;
  return (_a2 = import_aria_query.roles.get(role)) == null ? void 0 : _a2.abstract;
});
var non_abstract_roles = aria_roles.filter((name) => !abstract_roles.includes(name));
var non_interactive_roles = non_abstract_roles.filter((name) => {
  const role = import_aria_query.roles.get(name);
  return (
    // 'toolbar' does not descend from widget, but it does support
    // aria-activedescendant, thus in practice we treat it as a widget.
    // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
    // 'generic' is meant to have no semantic meaning.
    // 'cell' is treated as CellRole by the AXObject which is interactive, so we treat 'cell' it as interactive as well.
    !["toolbar", "tabpanel", "generic", "cell"].includes(name) && !(role == null ? void 0 : role.superClass.some((classes) => classes.includes("widget") || classes.includes("window")))
  );
}).concat(
  // The `progressbar` is descended from `widget`, but in practice, its
  // value is always `readonly`, so we treat it as a non-interactive role.
  "progressbar"
);
var interactive_roles = non_abstract_roles.filter(
  (name) => !non_interactive_roles.includes(name) && // 'generic' is meant to have no semantic meaning.
  name !== "generic"
);
function is_non_interactive_roles(role) {
  return non_interactive_roles.includes(role);
}
function is_interactive_roles(role) {
  return interactive_roles.includes(role);
}
function is_abstract_role(role) {
  return abstract_roles.includes(role);
}
var presentation_roles = ["presentation", "none"];
function is_presentation_role(role) {
  return presentation_roles.includes(role);
}
function is_hidden_from_screen_reader(tag_name, attribute_map) {
  if (tag_name === "input") {
    const type = get_static_value2(attribute_map.get("type"));
    if (type === "hidden") {
      return true;
    }
  }
  const aria_hidden = attribute_map.get("aria-hidden");
  if (!aria_hidden) return false;
  const aria_hidden_value = get_static_value2(aria_hidden);
  if (aria_hidden_value === null) return true;
  return aria_hidden_value === true || aria_hidden_value === "true";
}
function has_disabled_attribute(attribute_map) {
  const disabled_attr_value = get_static_value2(attribute_map.get("disabled"));
  if (disabled_attr_value) {
    return true;
  }
  const aria_disabled_attr = attribute_map.get("aria-disabled");
  if (aria_disabled_attr) {
    const aria_disabled_attr_value = get_static_value2(aria_disabled_attr);
    if (aria_disabled_attr_value === "true") {
      return true;
    }
  }
  return false;
}
var non_interactive_element_role_schemas = [];
import_aria_query.elementRoles.entries().forEach(([schema, roles]) => {
  if ([...roles].every((role) => role !== "generic" && non_interactive_roles.includes(role))) {
    non_interactive_element_role_schemas.push(schema);
  }
});
var interactive_element_role_schemas = [];
import_aria_query.elementRoles.entries().forEach(([schema, roles]) => {
  if ([...roles].every((role) => interactive_roles.includes(role))) {
    interactive_element_role_schemas.push(schema);
  }
});
var interactive_ax_objects = [...import_axobject_query.AXObjects.keys()].filter(
  (name) => import_axobject_query.AXObjects.get(name).type === "widget"
);
var non_interactive_ax_objects = [...import_axobject_query.AXObjects.keys()].filter(
  (name) => ["windows", "structure"].includes(import_axobject_query.AXObjects.get(name).type)
);
var interactive_element_ax_object_schemas = [];
import_axobject_query.elementAXObjects.entries().forEach(
  /**
   * @param {any} _
   */
  ([schema, ax_object]) => {
    if ([...ax_object].every((role) => interactive_ax_objects.includes(role))) {
      interactive_element_ax_object_schemas.push(schema);
    }
  }
);
var non_interactive_element_ax_object_schemas = [];
import_axobject_query.elementAXObjects.entries().forEach(
  /**
   * @param {any} _
   */
  ([schema, ax_object]) => {
    if ([...ax_object].every((role) => non_interactive_ax_objects.includes(role))) {
      non_interactive_element_ax_object_schemas.push(schema);
    }
  }
);
function match_schema(schema, tag_name, attribute_map) {
  if (schema.name !== tag_name) return false;
  if (!schema.attributes) return true;
  return schema.attributes.every((schema_attribute) => {
    const attribute = attribute_map.get(schema_attribute.name);
    if (!attribute) return false;
    if (schema_attribute.value && schema_attribute.value !== get_static_text_value(attribute)) {
      return false;
    }
    return true;
  });
}
var ElementInteractivity = (
  /** @type {const} */
  {
    Interactive: "interactive",
    NonInteractive: "non-interactive",
    Static: "static"
  }
);
function element_interactivity(tag_name, attribute_map) {
  if (interactive_element_role_schemas.some((schema) => match_schema(schema, tag_name, attribute_map))) {
    return ElementInteractivity.Interactive;
  }
  if (tag_name !== "header" && non_interactive_element_role_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  if (interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.Interactive;
  }
  if (non_interactive_element_ax_object_schemas.some(
    (schema) => match_schema(schema, tag_name, attribute_map)
  )) {
    return ElementInteractivity.NonInteractive;
  }
  return ElementInteractivity.Static;
}
function is_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Interactive;
}
function is_non_interactive_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.NonInteractive;
}
function is_static_element(tag_name, attribute_map) {
  return element_interactivity(tag_name, attribute_map) === ElementInteractivity.Static;
}
function is_semantic_role_element(role, tag_name, attribute_map) {
  for (const [schema, ax_object] of import_axobject_query.elementAXObjects.entries()) {
    if (schema.name === tag_name && (!schema.attributes || schema.attributes.every(
      /** @param {any} attr */
      (attr) => attribute_map.has(attr.name) && get_static_value2(attribute_map.get(attr.name)) === attr.value
    ))) {
      for (const name of ax_object) {
        const roles = import_axobject_query.AXObjectRoles.get(name);
        if (roles) {
          for (const { name: name2 } of roles) {
            if (name2 === role) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}
var address_type_tokens = ["shipping", "billing"];
var autofill_field_name_tokens = [
  "",
  "on",
  "off",
  "name",
  "honorific-prefix",
  "given-name",
  "additional-name",
  "family-name",
  "honorific-suffix",
  "nickname",
  "username",
  "new-password",
  "current-password",
  "one-time-code",
  "organization-title",
  "organization",
  "street-address",
  "address-line1",
  "address-line2",
  "address-line3",
  "address-level4",
  "address-level3",
  "address-level2",
  "address-level1",
  "country",
  "country-name",
  "postal-code",
  "cc-name",
  "cc-given-name",
  "cc-additional-name",
  "cc-family-name",
  "cc-number",
  "cc-exp",
  "cc-exp-month",
  "cc-exp-year",
  "cc-csc",
  "cc-type",
  "transaction-currency",
  "transaction-amount",
  "language",
  "bday",
  "bday-day",
  "bday-month",
  "bday-year",
  "sex",
  "url",
  "photo"
];
var contact_type_tokens = ["home", "work", "mobile", "fax", "pager"];
var autofill_contact_field_name_tokens = [
  "tel",
  "tel-country-code",
  "tel-national",
  "tel-area-code",
  "tel-local",
  "tel-local-prefix",
  "tel-local-suffix",
  "tel-extension",
  "email",
  "impp"
];
function is_valid_autocomplete(autocomplete) {
  if (autocomplete === true) {
    return false;
  } else if (!autocomplete) {
    return true;
  }
  const tokens = autocomplete.trim().toLowerCase().split(regex_whitespaces);
  if (typeof tokens[0] === "string" && tokens[0].startsWith("section-")) {
    tokens.shift();
  }
  if (address_type_tokens.includes(tokens[0])) {
    tokens.shift();
  }
  if (autofill_field_name_tokens.includes(tokens[0])) {
    tokens.shift();
  } else {
    if (contact_type_tokens.includes(tokens[0])) {
      tokens.shift();
    }
    if (autofill_contact_field_name_tokens.includes(tokens[0])) {
      tokens.shift();
    } else {
      return false;
    }
  }
  if (tokens[0] === "webauthn") {
    tokens.shift();
  }
  return tokens.length === 0;
}
var aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(
  " "
);
var a11y_required_attributes = {
  a: ["href"],
  area: ["alt", "aria-label", "aria-labelledby"],
  // html-has-lang
  html: ["lang"],
  // iframe-has-title
  iframe: ["title"],
  img: ["alt"],
  object: ["title", "aria-label", "aria-labelledby"]
};
var a11y_distracting_elements2 = ["blink", "marquee"];
var a11y_required_content = [
  // heading-has-content
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6"
];
var a11y_labelable = [
  "button",
  "input",
  "keygen",
  "meter",
  "output",
  "progress",
  "select",
  "textarea"
];
var a11y_interactive_handlers = [
  // Keyboard events
  "keypress",
  "keydown",
  "keyup",
  // Click events
  "click",
  "contextmenu",
  "dblclick",
  "drag",
  "dragend",
  "dragenter",
  "dragexit",
  "dragleave",
  "dragover",
  "dragstart",
  "drop",
  "mousedown",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup"
];
var a11y_recommended_interactive_handlers = [
  "click",
  "mousedown",
  "mouseup",
  "keypress",
  "keydown",
  "keyup"
];
var a11y_nested_implicit_semantics = /* @__PURE__ */ new Map([
  ["header", "banner"],
  ["footer", "contentinfo"]
]);
var a11y_implicit_semantics = /* @__PURE__ */ new Map([
  ["a", "link"],
  ["area", "link"],
  ["article", "article"],
  ["aside", "complementary"],
  ["body", "document"],
  ["button", "button"],
  ["datalist", "listbox"],
  ["dd", "definition"],
  ["dfn", "term"],
  ["dialog", "dialog"],
  ["details", "group"],
  ["dt", "term"],
  ["fieldset", "group"],
  ["figure", "figure"],
  ["form", "form"],
  ["h1", "heading"],
  ["h2", "heading"],
  ["h3", "heading"],
  ["h4", "heading"],
  ["h5", "heading"],
  ["h6", "heading"],
  ["hr", "separator"],
  ["img", "img"],
  ["li", "listitem"],
  ["link", "link"],
  ["main", "main"],
  ["menu", "list"],
  ["meter", "progressbar"],
  ["nav", "navigation"],
  ["ol", "list"],
  ["option", "option"],
  ["optgroup", "group"],
  ["output", "status"],
  ["progress", "progressbar"],
  ["section", "region"],
  ["summary", "button"],
  ["table", "table"],
  ["tbody", "rowgroup"],
  ["textarea", "textbox"],
  ["tfoot", "rowgroup"],
  ["thead", "rowgroup"],
  ["tr", "row"],
  ["ul", "list"]
]);
var menuitem_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["command", "menuitem"],
  ["checkbox", "menuitemcheckbox"],
  ["radio", "menuitemradio"]
]);
var input_type_to_implicit_role = /* @__PURE__ */ new Map([
  ["button", "button"],
  ["image", "button"],
  ["reset", "button"],
  ["submit", "button"],
  ["checkbox", "checkbox"],
  ["radio", "radio"],
  ["range", "slider"],
  ["number", "spinbutton"],
  ["email", "textbox"],
  ["search", "searchbox"],
  ["tel", "textbox"],
  ["text", "textbox"],
  ["url", "textbox"]
]);
var a11y_non_interactive_element_to_interactive_role_exceptions = {
  ul: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  ol: ["listbox", "menu", "menubar", "radiogroup", "tablist", "tree", "treegrid"],
  li: ["menuitem", "option", "row", "tab", "treeitem"],
  table: ["grid"],
  td: ["gridcell"],
  fieldset: ["radiogroup", "presentation"]
};
var combobox_if_list = ["email", "search", "tel", "text", "url"];
function input_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute) return;
  const type = get_static_text_value(type_attribute);
  if (!type) return;
  const list_attribute_exists = attribute_map.has("list");
  if (list_attribute_exists && combobox_if_list.includes(type)) {
    return "combobox";
  }
  return input_type_to_implicit_role.get(type);
}
function menuitem_implicit_role(attribute_map) {
  const type_attribute = attribute_map.get("type");
  if (!type_attribute) return;
  const type = get_static_text_value(type_attribute);
  if (!type) return;
  return menuitem_type_to_implicit_role.get(type);
}
function get_implicit_role(name, attribute_map) {
  if (name === "menuitem") {
    return menuitem_implicit_role(attribute_map);
  } else if (name === "input") {
    return input_implicit_role(attribute_map);
  } else {
    return a11y_implicit_semantics.get(name);
  }
}
var invisible_elements = ["meta", "html", "script", "style"];
function is_parent(path, elements) {
  let i = path.length;
  while (i--) {
    const parent = path[i];
    if (parent.type === "SvelteElement") return true;
    if (parent.type === "RegularElement") {
      return elements.includes(parent.name);
    }
  }
  return false;
}
function validate_aria_attribute_value(attribute, name, schema, value) {
  const type = schema.type;
  if (value === null) return;
  if (value === true) value = "";
  if (type === "boolean" && value !== "true" && value !== "false") {
    a11y_incorrect_aria_attribute_type_boolean(attribute, name);
  } else if (type === "integer" && (value === "" || !Number.isInteger(+value))) {
    a11y_incorrect_aria_attribute_type_integer(attribute, name);
  } else if (type === "number" && (value === "" || isNaN(+value))) {
    a11y_incorrect_aria_attribute_type(attribute, name, "number");
  } else if ((type === "string" || type === "id") && value === "") {
    a11y_incorrect_aria_attribute_type(attribute, name, "non-empty string");
  } else if (type === "idlist" && value === "") {
    a11y_incorrect_aria_attribute_type_idlist(attribute, name);
  } else if (type === "token") {
    const values = (schema.values ?? []).map((value2) => value2.toString());
    if (!values.includes(value.toLowerCase())) {
      a11y_incorrect_aria_attribute_type_token(
        attribute,
        name,
        list(values.map((v) => `"${v}"`))
      );
    }
  } else if (type === "tokenlist") {
    const values = (schema.values ?? []).map((value2) => value2.toString());
    if (value.toLowerCase().split(regex_whitespaces).some((value2) => !values.includes(value2))) {
      a11y_incorrect_aria_attribute_type_tokenlist(
        attribute,
        name,
        list(values.map((v) => `"${v}"`))
      );
    }
  } else if (type === "tristate" && value !== "true" && value !== "false" && value !== "mixed") {
    a11y_incorrect_aria_attribute_type_tristate(attribute, name);
  }
}
function warn_missing_attribute(node, attributes, name = node.name) {
  const article = regex_starts_with_vowel.test(attributes[0]) || attributes[0] === "href" ? "an" : "a";
  const sequence2 = attributes.length > 1 ? attributes.slice(0, -1).join(", ") + ` or ${attributes[attributes.length - 1]}` : attributes[0];
  a11y_missing_attribute(node, name, article, sequence2);
}
function get_static_value2(attribute) {
  if (!attribute) return null;
  if (attribute.value === true) return true;
  if (is_text_attribute(attribute)) return attribute.value[0].data;
  return null;
}
function get_static_text_value(attribute) {
  const value = get_static_value2(attribute);
  if (value === true) return null;
  return value;
}
function check_element(node, context) {
  var _a2;
  const attribute_map = /* @__PURE__ */ new Map();
  const handlers = /* @__PURE__ */ new Set();
  const attributes = [];
  const is_dynamic_element = node.type === "SvelteElement";
  let has_spread = false;
  let has_contenteditable_attr = false;
  let has_contenteditable_binding = false;
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") {
      has_spread = true;
    } else if (attribute.type === "OnDirective") {
      handlers.add(attribute.name);
    } else if (attribute.type === "Attribute") {
      if (is_event_attribute(attribute)) {
        handlers.add(attribute.name.slice(2));
      } else {
        attributes.push(attribute);
        attribute_map.set(attribute.name, attribute);
        if (attribute.name === "contenteditable") {
          has_contenteditable_attr = true;
        }
      }
    } else if (attribute.type === "BindDirective" && is_content_editable_binding(attribute.name)) {
      has_contenteditable_binding = true;
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") continue;
    const name = attribute.name.toLowerCase();
    if (name.startsWith("aria-")) {
      if (invisible_elements.includes(node.name)) {
        a11y_aria_attributes(attribute, node.name);
      }
      const type = name.slice(5);
      if (!aria_attributes.includes(type)) {
        const match = fuzzymatch(type, aria_attributes);
        a11y_unknown_aria_attribute(attribute, type, match);
      }
      if (name === "aria-hidden" && regex_heading_tags.test(node.name)) {
        a11y_hidden(attribute, node.name);
      }
      let value = get_static_value2(attribute);
      const schema = import_aria_query.aria.get(
        /** @type {ARIAProperty} */
        name
      );
      if (schema !== void 0) {
        validate_aria_attribute_value(
          attribute,
          /** @type {ARIAProperty} */
          name,
          schema,
          value
        );
      }
      if (name === "aria-activedescendant" && !is_dynamic_element && !is_interactive_element(node.name, attribute_map) && !attribute_map.has("tabindex") && !has_spread) {
        a11y_aria_activedescendant_has_tabindex(attribute);
      }
    }
    if (name === "role") {
      if (invisible_elements.includes(node.name)) {
        a11y_misplaced_role(attribute, node.name);
      }
      const value = get_static_value2(attribute);
      if (typeof value === "string") {
        for (const c_r of value.split(regex_whitespaces)) {
          const current_role = (
            /** @type {ARIARoleDefinitionKey} current_role */
            c_r
          );
          if (current_role && is_abstract_role(current_role)) {
            a11y_no_abstract_role(attribute, current_role);
          } else if (current_role && !aria_roles.includes(current_role)) {
            const match = fuzzymatch(current_role, aria_roles);
            a11y_unknown_role(attribute, current_role, match);
          }
          if (current_role === get_implicit_role(node.name, attribute_map) && // <ul role="list"> is ok because CSS list-style:none removes the semantics and this is a way to bring them back
          !["ul", "ol", "li"].includes(node.name) && // <a role="link" /> is ok because without href the a tag doesn't have a role of link
          !(node.name === "a" && !attribute_map.has("href"))) {
            a11y_no_redundant_roles(attribute, current_role);
          }
          const is_parent_section_or_article = is_parent(context.path, ["section", "article"]);
          if (!is_parent_section_or_article) {
            const has_nested_redundant_role = current_role === a11y_nested_implicit_semantics.get(node.name);
            if (has_nested_redundant_role) {
              a11y_no_redundant_roles(attribute, current_role);
            }
          }
          if (!is_dynamic_element && !is_semantic_role_element(current_role, node.name, attribute_map)) {
            const role2 = import_aria_query.roles.get(current_role);
            if (role2) {
              const required_role_props = Object.keys(role2.requiredProps);
              const has_missing_props = !has_spread && required_role_props.some((prop2) => !attributes.find((a) => a.name === prop2));
              if (has_missing_props) {
                a11y_role_has_required_aria_props(
                  attribute,
                  current_role,
                  list(
                    required_role_props.map((v) => `"${v}"`),
                    "and"
                  )
                );
              }
            }
          }
          if (!has_spread && !has_disabled_attribute(attribute_map) && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(current_role) && is_interactive_roles(current_role) && is_static_element(node.name, attribute_map) && !attribute_map.get("tabindex")) {
            const has_interactive_handlers = [...handlers].some(
              (handler) => a11y_interactive_handlers.includes(handler)
            );
            if (has_interactive_handlers) {
              a11y_interactive_supports_focus(node, current_role);
            }
          }
          if (!has_spread && is_interactive_element(node.name, attribute_map) && (is_non_interactive_roles(current_role) || is_presentation_role(current_role))) {
            a11y_no_interactive_element_to_noninteractive_role(node, node.name, current_role);
          }
          if (!has_spread && is_non_interactive_element(node.name, attribute_map) && is_interactive_roles(current_role) && !((_a2 = a11y_non_interactive_element_to_interactive_role_exceptions[node.name]) == null ? void 0 : _a2.includes(
            current_role
          ))) {
            a11y_no_noninteractive_element_to_interactive_role(node, node.name, current_role);
          }
        }
      }
    }
    if (name === "accesskey") {
      a11y_accesskey(attribute);
    }
    if (name === "autofocus") {
      a11y_autofocus(attribute);
    }
    if (name === "scope" && !is_dynamic_element && node.name !== "th") {
      a11y_misplaced_scope(attribute);
    }
    if (name === "tabindex") {
      const value = get_static_value2(attribute);
      if (!isNaN(value) && +value > 0) {
        a11y_positive_tabindex(attribute);
      }
    }
  }
  const role = attribute_map.get("role");
  const role_static_value = (
    /** @type {ARIARoleDefinitionKey} */
    get_static_text_value(role)
  );
  if (handlers.has("click")) {
    const is_non_presentation_role = role_static_value !== null && !is_presentation_role(role_static_value);
    if (!is_dynamic_element && !is_hidden_from_screen_reader(node.name, attribute_map) && (!role || is_non_presentation_role) && !is_interactive_element(node.name, attribute_map) && !has_spread) {
      const has_key_event = handlers.has("keydown") || handlers.has("keyup") || handlers.has("keypress");
      if (!has_key_event) {
        a11y_click_events_have_key_events(node);
      }
    }
  }
  const role_value = (
    /** @type {ARIARoleDefinitionKey} */
    role ? role_static_value : get_implicit_role(node.name, attribute_map)
  );
  if (!is_dynamic_element && !is_interactive_element(node.name, attribute_map) && !is_interactive_roles(role_static_value)) {
    const tab_index = attribute_map.get("tabindex");
    const tab_index_value = get_static_text_value(tab_index);
    if (tab_index && (tab_index_value === null || Number(tab_index_value) >= 0)) {
      a11y_no_noninteractive_tabindex(node);
    }
  }
  if (typeof role_value === "string" && import_aria_query.roles.has(role_value)) {
    const { props } = (
      /** @type {ARIARoleDefinition} */
      import_aria_query.roles.get(role_value)
    );
    const invalid_aria_props = import_aria_query.aria.keys().filter((attribute) => !(attribute in props));
    const is_implicit = role_value && role === void 0;
    for (const attr of attributes) {
      if (invalid_aria_props.includes(
        /** @type {ARIAProperty} */
        attr.name
      )) {
        if (is_implicit) {
          a11y_role_supports_aria_props_implicit(attr, attr.name, role_value, node.name);
        } else {
          a11y_role_supports_aria_props(attr, attr.name, role_value);
        }
      }
    }
  }
  if (!has_spread && !has_contenteditable_attr && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(role_static_value) && (!is_interactive_element(node.name, attribute_map) && is_non_interactive_roles(role_static_value) || is_non_interactive_element(node.name, attribute_map) && !role)) {
    const has_interactive_handlers = [...handlers].some(
      (handler) => a11y_recommended_interactive_handlers.includes(handler)
    );
    if (has_interactive_handlers) {
      a11y_no_noninteractive_element_interactions(node, node.name);
    }
  }
  if (!has_spread && (!role || role_static_value !== null) && !is_hidden_from_screen_reader(node.name, attribute_map) && !is_presentation_role(role_static_value) && !is_interactive_element(node.name, attribute_map) && !is_interactive_roles(role_static_value) && !is_non_interactive_element(node.name, attribute_map) && !is_non_interactive_roles(role_static_value) && !is_abstract_role(role_static_value)) {
    const interactive_handlers = [...handlers].filter(
      (handler) => a11y_interactive_handlers.includes(handler)
    );
    if (interactive_handlers.length > 0) {
      a11y_no_static_element_interactions(node, node.name, list(interactive_handlers));
    }
  }
  if (!has_spread && handlers.has("mouseover") && !handlers.has("focus")) {
    a11y_mouse_events_have_key_events(node, "mouseover", "focus");
  }
  if (!has_spread && handlers.has("mouseout") && !handlers.has("blur")) {
    a11y_mouse_events_have_key_events(node, "mouseout", "blur");
  }
  const is_labelled = attribute_map.has("aria-label") || attribute_map.has("aria-labelledby");
  if (node.name === "a" || node.name === "button") {
    const is_hidden = get_static_value2(attribute_map.get("aria-hidden")) === "true";
    if (!has_spread && !is_hidden && !is_labelled && !has_content(node)) {
      a11y_consider_explicit_label(node);
    }
  }
  if (node.name === "a") {
    const href = attribute_map.get("href") || attribute_map.get("xlink:href");
    if (href) {
      const href_value = get_static_text_value(href);
      if (href_value !== null) {
        if (href_value === "" || href_value === "#" || /^\W*javascript:/i.test(href_value)) {
          a11y_invalid_attribute(href, href_value, href.name);
        }
      }
    } else if (!has_spread) {
      const id_attribute = get_static_value2(attribute_map.get("id"));
      const name_attribute = get_static_value2(attribute_map.get("name"));
      const aria_disabled_attribute = get_static_value2(attribute_map.get("aria-disabled"));
      if (!id_attribute && !name_attribute && aria_disabled_attribute !== "true") {
        warn_missing_attribute(node, ["href"]);
      }
    }
  } else if (!has_spread) {
    const required_attributes = a11y_required_attributes[node.name];
    if (required_attributes) {
      const has_attribute = required_attributes.some((name) => attribute_map.has(name));
      if (!has_attribute) {
        warn_missing_attribute(node, required_attributes);
      }
    }
  }
  if (node.name === "input") {
    const type = attribute_map.get("type");
    const type_value = get_static_text_value(type);
    if (type_value === "image" && !has_spread) {
      const required_attributes = ["alt", "aria-label", "aria-labelledby"];
      const has_attribute = required_attributes.some((name) => attribute_map.has(name));
      if (!has_attribute) {
        warn_missing_attribute(node, required_attributes, 'input type="image"');
      }
    }
    const autocomplete = attribute_map.get("autocomplete");
    if (type && autocomplete) {
      const autocomplete_value = get_static_value2(autocomplete);
      if (!is_valid_autocomplete(autocomplete_value)) {
        a11y_autocomplete_valid(
          autocomplete,
          /** @type {string} */
          autocomplete_value,
          type_value ?? "..."
        );
      }
    }
  }
  if (node.name === "img") {
    const alt_attribute = get_static_text_value(attribute_map.get("alt"));
    const aria_hidden = get_static_value2(attribute_map.get("aria-hidden"));
    if (alt_attribute && !aria_hidden && !has_spread) {
      if (/\b(image|picture|photo)\b/i.test(alt_attribute)) {
        a11y_img_redundant_alt(node);
      }
    }
  }
  if (node.name === "label") {
    const has_input_child = (node2) => {
      let has = false;
      walk(
        node2,
        {},
        {
          _(node3, { next: next2 }) {
            if (node3.type === "SvelteElement" || node3.type === "SlotElement" || node3.type === "Component" || node3.type === "RenderTag" || node3.type === "RegularElement" && (a11y_labelable.includes(node3.name) || node3.name === "slot")) {
              has = true;
            } else {
              next2();
            }
          }
        }
      );
      return has;
    };
    if (!has_spread && !attribute_map.has("for") && !has_input_child(node)) {
      a11y_label_has_associated_control(node);
    }
  }
  if (node.name === "video") {
    const aria_hidden_attribute = attribute_map.get("aria-hidden");
    const aria_hidden_exist = aria_hidden_attribute && get_static_value2(aria_hidden_attribute);
    if (attribute_map.has("muted") || aria_hidden_exist === "true" || has_spread) {
      return;
    }
    let has_caption = false;
    const track = (
      /** @type {AST.RegularElement | undefined} */
      node.fragment.nodes.find((i) => i.type === "RegularElement" && i.name === "track")
    );
    if (track) {
      has_caption = track.attributes.some(
        (a) => a.type === "SpreadAttribute" || a.type === "Attribute" && a.name === "kind" && get_static_value2(a) === "captions"
      );
    }
    if (!has_caption) {
      a11y_media_has_caption(node);
    }
  }
  if (node.name === "figcaption") {
    if (!is_parent(context.path, ["figure"])) {
      a11y_figcaption_parent(node);
    }
  }
  if (node.name === "figure") {
    const children = node.fragment.nodes.filter((node2) => {
      if (node2.type === "Comment") return false;
      if (node2.type === "Text") return regex_not_whitespace.test(node2.data);
      return true;
    });
    const index = children.findIndex(
      (child) => child.type === "RegularElement" && child.name === "figcaption"
    );
    if (index !== -1 && index !== 0 && index !== children.length - 1) {
      a11y_figcaption_index(children[index]);
    }
  }
  if (a11y_distracting_elements2.includes(node.name)) {
    a11y_distracting_elements(node, node.name);
  }
  if (!has_spread && !is_labelled && !has_contenteditable_binding && a11y_required_content.includes(node.name) && !has_content(node)) {
    a11y_missing_content(node, node.name);
  }
}
function has_content(element2) {
  for (const node of element2.fragment.nodes) {
    if (node.type === "Text") {
      if (node.data.trim() === "") {
        continue;
      }
    }
    if (node.type === "RegularElement" || node.type === "SvelteElement") {
      if (node.name === "img" && node.attributes.some((node2) => node2.type === "Attribute" && node2.name === "alt")) {
        return true;
      }
      if (!has_content(node)) {
        continue;
      }
    }
    return true;
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/shared/element.js
var EVENT_MODIFIERS = [
  "preventDefault",
  "stopPropagation",
  "stopImmediatePropagation",
  "capture",
  "once",
  "passive",
  "nonpassive",
  "self",
  "trusted"
];
function validate_element(node, context) {
  let has_animate_directive = false;
  let in_transition = null;
  let out_transition = null;
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      const is_expression = is_expression_attribute(attribute);
      if (context.state.analysis.runes) {
        validate_attribute(attribute, node);
        if (is_expression) {
          const expression = get_attribute_expression(attribute);
          if (expression.type === "SequenceExpression") {
            let i = (
              /** @type {number} */
              expression.start
            );
            while (--i > 0) {
              const char = context.state.analysis.source[i];
              if (char === "(") break;
              if (char === "{") attribute_invalid_sequence_expression(expression);
            }
          }
        }
      }
      if (regex_illegal_attribute_character.test(attribute.name)) {
        attribute_invalid_name(attribute, attribute.name);
      }
      if (attribute.name.startsWith("on") && attribute.name.length > 2) {
        if (!is_expression) {
          attribute_invalid_event_handler(attribute);
        }
        const value = get_attribute_expression(attribute);
        if (value.type === "Identifier" && value.name === attribute.name && !context.state.scope.get(value.name)) {
          attribute_global_event_reference(attribute, attribute.name);
        }
      }
      if (attribute.name === "slot") {
        validate_slot_attribute(context, attribute);
      }
      if (attribute.name === "is") {
        attribute_avoid_is(attribute);
      }
      const correct_name = react_attributes.get(attribute.name);
      if (correct_name) {
        attribute_invalid_property_name(attribute, attribute.name, correct_name);
      }
      validate_attribute_name(attribute);
    } else if (attribute.type === "AnimateDirective") {
      const parent = context.path.at(-2);
      if ((parent == null ? void 0 : parent.type) !== "EachBlock") {
        animation_invalid_placement(attribute);
      } else if (!parent.key) {
        animation_missing_key(attribute);
      } else if (parent.body.nodes.filter(
        (n) => n.type !== "Comment" && n.type !== "ConstTag" && (n.type !== "Text" || n.data.trim() !== "")
      ).length > 1) {
        animation_invalid_placement(attribute);
      }
      if (has_animate_directive) {
        animation_duplicate(attribute);
      } else {
        has_animate_directive = true;
      }
    } else if (attribute.type === "TransitionDirective") {
      const existing = (
        /** @type {AST.TransitionDirective | null} */
        attribute.intro && in_transition || attribute.outro && out_transition
      );
      if (existing) {
        const a = existing.intro ? existing.outro ? "transition" : "in" : "out";
        const b = attribute.intro ? attribute.outro ? "transition" : "in" : "out";
        if (a === b) {
          transition_duplicate(attribute, a);
        } else {
          transition_conflict(attribute, a, b);
        }
      }
      if (attribute.intro) in_transition = attribute;
      if (attribute.outro) out_transition = attribute;
    } else if (attribute.type === "OnDirective") {
      let has_passive_modifier = false;
      let conflicting_passive_modifier = "";
      for (const modifier of attribute.modifiers) {
        if (!EVENT_MODIFIERS.includes(modifier)) {
          const list3 = `${EVENT_MODIFIERS.slice(0, -1).join(", ")} or ${EVENT_MODIFIERS.at(-1)}`;
          event_handler_invalid_modifier(attribute, list3);
        }
        if (modifier === "passive") {
          has_passive_modifier = true;
        } else if (modifier === "nonpassive" || modifier === "preventDefault") {
          conflicting_passive_modifier = modifier;
        }
        if (has_passive_modifier && conflicting_passive_modifier) {
          event_handler_invalid_modifier_combination(
            attribute,
            "passive",
            conflicting_passive_modifier
          );
        }
      }
    }
  }
}
var react_attributes = /* @__PURE__ */ new Map([
  ["className", "class"],
  ["htmlFor", "for"]
]);

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/RegularElement.js
function RegularElement(node, context) {
  var _a2;
  validate_element(node, context);
  check_element(node, context);
  node.metadata.path = [...context.path];
  context.state.analysis.elements.push(node);
  if (node.name === "textarea" && node.fragment.nodes.length > 0) {
    for (const attribute of node.attributes) {
      if (attribute.type === "Attribute" && attribute.name === "value") {
        textarea_invalid_content(node);
      }
    }
    if (node.fragment.nodes.length > 1 || node.fragment.nodes[0].type !== "Text") {
      const first = node.fragment.nodes[0];
      if (first.type === "Text") {
        first.data = first.data.replace(regex_starts_with_newline, "");
        first.raw = first.raw.replace(regex_starts_with_newline, "");
      }
      node.attributes.push(
        create_attribute(
          "value",
          /** @type {AST.Text} */
          node.fragment.nodes.at(0).start,
          /** @type {AST.Text} */
          node.fragment.nodes.at(-1).end,
          // @ts-ignore
          node.fragment.nodes
        )
      );
      node.fragment.nodes = [];
    }
  }
  if (node.name === "option" && ((_a2 = node.fragment.nodes) == null ? void 0 : _a2.length) === 1 && node.fragment.nodes[0].type === "ExpressionTag" && !node.attributes.some(
    (attribute) => attribute.type === "Attribute" && attribute.name === "value"
  )) {
    const child = node.fragment.nodes[0];
    node.attributes.push(create_attribute("value", child.start, child.end, [child]));
  }
  const binding = context.state.scope.get(node.name);
  if (binding !== null && binding.declaration_kind === "import" && binding.references.length === 0) {
    component_name_lowercase(node, node.name);
  }
  node.metadata.has_spread = node.attributes.some(
    (attribute) => attribute.type === "SpreadAttribute"
  );
  const is_svg_element = () => {
    if (is_svg(node.name)) {
      return true;
    }
    if (node.name === "a" || node.name === "title") {
      let i = context.path.length;
      while (i--) {
        const ancestor = context.path[i];
        if (ancestor.type === "RegularElement") {
          return ancestor.metadata.svg;
        }
      }
    }
    return false;
  };
  node.metadata.svg = is_svg_element();
  node.metadata.mathml = is_mathml(node.name);
  if (is_custom_element_node(node) && node.attributes.length > 0) {
    mark_subtree_dynamic(context.path);
  }
  if (context.state.parent_element) {
    let past_parent = false;
    let only_warn = false;
    const ancestors = [context.state.parent_element];
    for (let i = context.path.length - 1; i >= 0; i--) {
      const ancestor = context.path[i];
      if (ancestor.type === "IfBlock" || ancestor.type === "EachBlock" || ancestor.type === "AwaitBlock" || ancestor.type === "KeyBlock") {
        only_warn = true;
      }
      if (!past_parent) {
        if (ancestor.type === "RegularElement" && ancestor.name === context.state.parent_element) {
          const message = is_tag_valid_with_parent(node.name, context.state.parent_element);
          if (message) {
            if (only_warn) {
              node_invalid_placement_ssr(node, message);
            } else {
              node_invalid_placement(node, message);
            }
          }
          past_parent = true;
        }
      } else if (ancestor.type === "RegularElement") {
        ancestors.push(ancestor.name);
        const message = is_tag_valid_with_ancestor(node.name, ancestors);
        if (message) {
          if (only_warn) {
            node_invalid_placement_ssr(node, message);
          } else {
            node_invalid_placement(node, message);
          }
        }
      } else if (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteElement" || ancestor.type === "SvelteSelf" || ancestor.type === "SnippetBlock") {
        break;
      }
    }
  }
  const node_name = node.name.replace(/[a-zA-Z-]*:/g, "");
  if (context.state.analysis.source[node.end - 2] === "/" && !is_void(node_name) && !is_svg(node_name) && !is_mathml(node_name)) {
    element_invalid_self_closing_tag(node, node.name);
  }
  context.next({ ...context.state, parent_element: node.name });
  if (node.name === "a" && !context.state.parent_element) {
    for (const child of node.fragment.nodes) {
      if (child.type === "RegularElement") {
        if (child.metadata.svg && child.name !== "svg") {
          node.metadata.svg = true;
          break;
        }
      }
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/RenderTag.js
function RenderTag(node, context) {
  var _a2;
  validate_opening_tag(node, context.state, "@");
  node.metadata.path = [...context.path];
  const expression = unwrap_optional(node.expression);
  const callee = expression.callee;
  const binding = callee.type === "Identifier" ? context.state.scope.get(callee.name) : null;
  node.metadata.dynamic = (binding == null ? void 0 : binding.kind) !== "normal";
  let resolved = callee.type === "Identifier" && is_resolved_snippet(binding);
  if (((_a2 = binding == null ? void 0 : binding.initial) == null ? void 0 : _a2.type) === "SnippetBlock") {
    node.metadata.snippets.add(binding.initial);
  }
  context.state.analysis.snippet_renderers.set(node, resolved);
  context.state.analysis.uses_render_tags = true;
  const raw_args = unwrap_optional(node.expression).arguments;
  for (const arg of raw_args) {
    if (arg.type === "SpreadElement") {
      render_tag_invalid_spread_argument(arg);
    }
  }
  if (callee.type === "MemberExpression" && callee.property.type === "Identifier" && ["bind", "apply", "call"].includes(callee.property.name)) {
    render_tag_invalid_call_expression(node);
  }
  mark_subtree_dynamic(context.path);
  context.visit(callee);
  for (const arg of expression.arguments) {
    const metadata = create_expression_metadata();
    node.metadata.arguments.push(metadata);
    context.visit(arg, {
      ...context.state,
      expression: metadata
    });
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SlotElement.js
function SlotElement(node, context) {
  if (context.state.analysis.runes && !context.state.analysis.custom_element) {
    slot_element_deprecated(node);
  }
  mark_subtree_dynamic(context.path);
  let name = "default";
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "name") {
        if (!is_text_attribute(attribute)) {
          slot_element_invalid_name(attribute);
        }
        name = attribute.value[0].data;
        if (name === "default") {
          slot_element_invalid_name_default(attribute);
        }
      }
    } else if (attribute.type !== "SpreadAttribute" && attribute.type !== "LetDirective") {
      slot_element_invalid_attribute(attribute);
    }
  }
  context.state.analysis.slot_names.set(name, node);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SnippetBlock.js
function SnippetBlock(node, context) {
  context.state.analysis.snippets.add(node);
  validate_block_not_empty(node.body, context);
  if (context.state.analysis.runes) {
    validate_opening_tag(node, context.state, "#");
  }
  for (const arg of node.parameters) {
    if (arg.type === "RestElement") {
      snippet_invalid_rest_parameter(arg);
    }
  }
  context.next({ ...context.state, parent_element: null });
  const can_hoist = context.path.length === 1 && context.path[0].type === "Fragment" && can_hoist_snippet(context.state.scope, context.state.scopes);
  const name = node.expression.name;
  if (can_hoist) {
    const binding = (
      /** @type {Binding} */
      context.state.scope.get(name)
    );
    context.state.analysis.module.scope.declarations.set(name, binding);
  } else {
    const undefined_export = context.state.analysis.undefined_exports.get(name);
    if (undefined_export) {
      snippet_invalid_export(undefined_export);
    }
  }
  node.metadata.can_hoist = can_hoist;
  const { path } = context;
  const parent = path.at(-2);
  if (!parent) return;
  if (parent.type === "Component" && parent.attributes.some(
    (attribute) => (attribute.type === "Attribute" || attribute.type === "BindDirective") && attribute.name === node.expression.name
  )) {
    snippet_shadowing_prop(node, node.expression.name);
  }
  if (node.expression.name !== "children") return;
  if (parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteSelf") {
    if (parent.fragment.nodes.some(
      (node2) => node2.type !== "SnippetBlock" && (node2.type !== "Text" || node2.data.trim()) && node2.type !== "Comment"
    )) {
      snippet_conflict(node);
    }
  }
}
function can_hoist_snippet(scope, scopes, visited = /* @__PURE__ */ new Set()) {
  var _a2;
  for (const [reference] of scope.references) {
    const binding = scope.get(reference);
    if (!binding || binding.scope.function_depth === 0) {
      continue;
    }
    if (binding.scope.function_depth >= scope.function_depth) {
      continue;
    }
    if (((_a2 = binding.initial) == null ? void 0 : _a2.type) === "SnippetBlock") {
      if (visited.has(binding)) continue;
      visited.add(binding);
      const snippet_scope = (
        /** @type {Scope} */
        scopes.get(binding.initial)
      );
      if (can_hoist_snippet(snippet_scope, scopes, visited)) {
        continue;
      }
    }
    return false;
  }
  return true;
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SpreadAttribute.js
function SpreadAttribute(node, context) {
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, expression: node.metadata.expression });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SpreadElement.js
function SpreadElement(node, context) {
  if (context.state.expression) {
    context.state.expression.has_call = true;
    context.state.expression.has_state = true;
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/StyleDirective.js
function StyleDirective(node, context) {
  var _a2, _b;
  if (node.modifiers.length > 1 || node.modifiers.length && node.modifiers[0] !== "important") {
    style_directive_invalid_modifier(node);
  }
  mark_subtree_dynamic(context.path);
  if (node.value === true) {
    let binding = context.state.scope.get(node.name);
    if (binding) {
      if (binding.kind !== "normal") {
        node.metadata.expression.has_state = true;
      }
    }
  } else {
    context.next();
    for (const chunk of get_attribute_chunks(node.value)) {
      if (chunk.type !== "ExpressionTag") continue;
      (_a2 = node.metadata.expression).has_state || (_a2.has_state = chunk.metadata.expression.has_state);
      (_b = node.metadata.expression).has_call || (_b.has_call = chunk.metadata.expression.has_call);
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteBody.js
function SvelteBody(node, context) {
  disallow_children(node);
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "Attribute" && !is_event_attribute(attribute)) {
      svelte_body_illegal_attribute(attribute);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteComponent.js
function SvelteComponent(node, context) {
  if (context.state.analysis.runes) {
    svelte_component_deprecated(node);
  }
  context.visit(node.expression);
  visit_component(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteDocument.js
function SvelteDocument(node, context) {
  disallow_children(node);
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "Attribute" && !is_event_attribute(attribute)) {
      illegal_element_attribute(attribute, "svelte:document");
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteElement.js
function SvelteElement(node, context) {
  validate_element(node, context);
  check_element(node, context);
  node.metadata.path = [...context.path];
  context.state.analysis.elements.push(node);
  const xmlns = (
    /** @type {AST.Attribute & { value: [AST.Text] } | undefined} */
    node.attributes.find(
      (a) => a.type === "Attribute" && a.name === "xmlns" && is_text_attribute(a)
    )
  );
  if (xmlns) {
    node.metadata.svg = xmlns.value[0].data === NAMESPACE_SVG;
    node.metadata.mathml = xmlns.value[0].data === NAMESPACE_MATHML;
  } else {
    let i = context.path.length;
    while (i--) {
      const ancestor = context.path[i];
      if (ancestor.type === "Component" || ancestor.type === "SvelteComponent" || ancestor.type === "SvelteFragment" || ancestor.type === "SnippetBlock" || i === 0) {
        node.metadata.svg = context.state.options.namespace === "svg";
        node.metadata.mathml = context.state.options.namespace === "mathml";
        break;
      }
      if (ancestor.type === "SvelteElement" || ancestor.type === "RegularElement") {
        node.metadata.svg = ancestor.type === "RegularElement" && ancestor.name === "foreignObject" ? false : ancestor.metadata.svg;
        node.metadata.mathml = ancestor.type === "RegularElement" && ancestor.name === "foreignObject" ? false : ancestor.metadata.mathml;
        break;
      }
    }
  }
  mark_subtree_dynamic(context.path);
  context.next({ ...context.state, parent_element: null });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteFragment.js
function SvelteFragment(node, context) {
  const parent = context.path.at(-2);
  if ((parent == null ? void 0 : parent.type) !== "Component" && (parent == null ? void 0 : parent.type) !== "SvelteComponent") {
    svelte_fragment_invalid_placement(node);
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "slot") {
        validate_slot_attribute(context, attribute);
      }
    } else if (attribute.type !== "LetDirective") {
      svelte_fragment_invalid_attribute(attribute);
    }
  }
  context.next({ ...context.state, parent_element: null });
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteHead.js
function SvelteHead(node, context) {
  for (const attribute of node.attributes) {
    svelte_head_illegal_attribute(attribute);
  }
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteSelf.js
function SvelteSelf(node, context) {
  const valid2 = context.path.some(
    (node2) => node2.type === "IfBlock" || node2.type === "EachBlock" || node2.type === "Component" || node2.type === "SnippetBlock"
  );
  if (!valid2) {
    svelte_self_invalid_placement(node);
  }
  if (context.state.analysis.runes) {
    const name = filename === "(unknown)" ? "Self" : context.state.analysis.name;
    const basename = filename === "(unknown)" ? "Self.svelte" : (
      /** @type {string} */
      filename.split(/[/\\]/).pop()
    );
    svelte_self_deprecated(node, name, basename);
  }
  visit_component(node, context);
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteWindow.js
function SvelteWindow(node, context) {
  disallow_children(node);
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute" || attribute.type === "Attribute" && !is_event_attribute(attribute)) {
      illegal_element_attribute(attribute, "svelte:window");
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/SvelteBoundary.js
var valid = ["onerror", "failed"];
function SvelteBoundary(node, context) {
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute" || !valid.includes(attribute.name)) {
      svelte_boundary_invalid_attribute(attribute);
    }
    if (attribute.value === true || Array.isArray(attribute.value) && (attribute.value.length !== 1 || attribute.value[0].type !== "ExpressionTag")) {
      svelte_boundary_invalid_attribute_value(attribute);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/TaggedTemplateExpression.js
function TaggedTemplateExpression(node, context) {
  if (context.state.expression && !is_pure(node.tag, context)) {
    context.state.expression.has_call = true;
    context.state.expression.has_state = true;
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/TemplateElement.js
function TemplateElement(node) {
  if (regex_bidirectional_control_characters.test(node.value.cooked ?? "")) {
    bidirectional_control_characters(node);
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/Text.js
function Text(node, context) {
  const parent = (
    /** @type {AST.SvelteNode} */
    context.path.at(-1)
  );
  if (parent.type === "Fragment" && context.state.parent_element && regex_not_whitespace.test(node.data)) {
    const message = is_tag_valid_with_parent("#text", context.state.parent_element);
    if (message) {
      node_invalid_placement(node, message);
    }
  }
  regex_bidirectional_control_characters.lastIndex = 0;
  for (const match of node.data.matchAll(regex_bidirectional_control_characters)) {
    let is_ignored2 = false;
    if (parent.type === "Fragment") {
      for (const child of parent.nodes) {
        if (child === node) break;
        if (child.type === "Comment") {
          is_ignored2 || (is_ignored2 = extract_svelte_ignore(
            child.start + 4,
            child.data,
            context.state.analysis.runes
          ).includes("bidirectional_control_characters"));
        }
      }
    }
    if (!is_ignored2) {
      let start = match.index + node.start;
      bidirectional_control_characters({ start, end: start + match[0].length });
    }
  }
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/TitleElement.js
function TitleElement(node, context) {
  for (const attribute of node.attributes) {
    title_illegal_attribute(attribute);
  }
  for (const child of node.fragment.nodes) {
    if (child.type !== "Text" && child.type !== "ExpressionTag") {
      title_invalid_content(child);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/TransitionDirective.js
function TransitionDirective(node, context) {
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/UpdateExpression.js
function UpdateExpression(node, context) {
  validate_assignment(node, node.argument, context.state);
  if (context.state.reactive_statement) {
    const id2 = node.argument.type === "MemberExpression" ? object2(node.argument) : node.argument;
    if ((id2 == null ? void 0 : id2.type) === "Identifier") {
      const binding = context.state.scope.get(id2.name);
      if (binding) {
        context.state.reactive_statement.assignments.add(binding);
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/UseDirective.js
function UseDirective(node, context) {
  mark_subtree_dynamic(context.path);
  context.next();
}

// node_modules/svelte/src/compiler/utils/assert.js
function equal(actual, expected) {
  if (actual !== expected) throw new Error("Assertion failed");
}

// node_modules/svelte/src/compiler/phases/2-analyze/visitors/VariableDeclarator.js
function VariableDeclarator(node, context) {
  var _a2, _b;
  ensure_no_module_import_conflict(node, context.state);
  if (context.state.analysis.runes) {
    const init2 = node.init;
    const rune = get_rune(init2, context.state.scope);
    const paths = extract_paths(node.id);
    for (const path of paths) {
      validate_identifier_name(context.state.scope.get(
        /** @type {Identifier} */
        path.node.name
      ));
    }
    if (rune === "$state" || rune === "$state.raw" || rune === "$derived" || rune === "$derived.by" || rune === "$props") {
      for (const path of paths) {
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(path.node.name)
        );
        binding.kind = rune === "$state" ? "state" : rune === "$state.raw" ? "raw_state" : rune === "$derived" || rune === "$derived.by" ? "derived" : path.is_rest ? "rest_prop" : "prop";
      }
    }
    if (rune === "$props") {
      if (node.id.type !== "ObjectPattern" && node.id.type !== "Identifier") {
        props_invalid_identifier(node);
      }
      context.state.analysis.needs_props = true;
      if (node.id.type === "Identifier") {
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(node.id.name)
        );
        binding.initial = null;
        binding.kind = "rest_prop";
      } else {
        equal(node.id.type, "ObjectPattern");
        for (const property of node.id.properties) {
          if (property.type !== "Property") continue;
          if (property.computed) {
            props_invalid_pattern(property);
          }
          if (property.key.type === "Identifier" && property.key.name.startsWith("$$")) {
            props_illegal_name(property);
          }
          const value = property.value.type === "AssignmentPattern" ? property.value.left : property.value;
          if (value.type !== "Identifier") {
            props_invalid_pattern(property);
          }
          const alias = property.key.type === "Identifier" ? property.key.name : String(
            /** @type {Literal} */
            property.key.value
          );
          let initial = property.value.type === "AssignmentPattern" ? property.value.right : null;
          const binding = (
            /** @type {Binding} */
            context.state.scope.get(value.name)
          );
          binding.prop_alias = alias;
          if ((initial == null ? void 0 : initial.type) === "CallExpression" && initial.callee.type === "Identifier" && initial.callee.name === "$bindable") {
            binding.initial = /** @type {Expression | null} */
            initial.arguments[0] ?? null;
            binding.kind = "bindable_prop";
          } else {
            binding.initial = initial;
          }
        }
      }
    }
  } else {
    if (((_a2 = node.init) == null ? void 0 : _a2.type) === "CallExpression") {
      const callee = node.init.callee;
      if (callee.type === "Identifier" && (callee.name === "$state" || callee.name === "$derived" || callee.name === "$props") && ((_b = context.state.scope.get(callee.name)) == null ? void 0 : _b.kind) !== "store_sub") {
        rune_invalid_usage(node.init, callee.name);
      }
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/2-analyze/index.js
var visitors3 = {
  _(node, { state, next: next2, path }) {
    const parent = path.at(-1);
    const ignores = [];
    if ((parent == null ? void 0 : parent.type) === "Fragment" && node.type !== "Comment" && node.type !== "Text") {
      const idx = parent.nodes.indexOf(
        /** @type {any} */
        node
      );
      for (let i = idx - 1; i >= 0; i--) {
        const prev = parent.nodes[i];
        if (prev.type === "Comment") {
          ignores.push(
            ...extract_svelte_ignore(
              prev.start + 4,
              prev.data,
              state.analysis.runes
            )
          );
        } else if (prev.type !== "Text") {
          break;
        }
      }
    } else {
      const comments = (
        /** @type {any} */
        node.leadingComments
      );
      if (comments) {
        for (const comment of comments) {
          ignores.push(
            ...extract_svelte_ignore(
              comment.start + 2,
              comment.value,
              state.analysis.runes
            )
          );
        }
      }
    }
    if (ignores.length > 0) {
      push_ignore(ignores);
    }
    ignore_map.set(node, structuredClone(ignore_stack));
    const scope = state.scopes.get(node);
    next2(scope !== void 0 && scope !== state.scope ? { ...state, scope } : state);
    if (ignores.length > 0) {
      pop_ignore();
    }
  },
  ArrowFunctionExpression,
  AssignmentExpression,
  Attribute,
  AwaitBlock,
  BindDirective,
  CallExpression,
  ClassBody,
  ClassDeclaration,
  ClassDirective,
  Component,
  ConstTag,
  DebugTag,
  EachBlock,
  ExportDefaultDeclaration,
  ExportNamedDeclaration,
  ExportSpecifier,
  ExpressionStatement,
  ExpressionTag,
  FunctionDeclaration,
  FunctionExpression,
  HtmlTag,
  Identifier,
  IfBlock,
  ImportDeclaration,
  KeyBlock,
  LabeledStatement,
  LetDirective,
  Literal,
  MemberExpression,
  NewExpression,
  OnDirective,
  RegularElement,
  RenderTag,
  SlotElement,
  SnippetBlock,
  SpreadAttribute,
  SpreadElement,
  StyleDirective,
  SvelteBody,
  SvelteComponent,
  SvelteDocument,
  SvelteElement,
  SvelteFragment,
  SvelteHead,
  SvelteSelf,
  SvelteWindow,
  SvelteBoundary,
  TaggedTemplateExpression,
  TemplateElement,
  Text,
  TransitionDirective,
  TitleElement,
  UpdateExpression,
  UseDirective,
  VariableDeclarator
};
function js(script, root, allow_reactive_declarations, parent) {
  const ast = (script == null ? void 0 : script.content) ?? {
    type: "Program",
    sourceType: "module",
    start: -1,
    end: -1,
    body: []
  };
  const { scope, scopes } = create_scopes(ast, root, allow_reactive_declarations, parent);
  return { ast, scope, scopes };
}
function get_component_name(filename2) {
  const parts = filename2.split(/[/\\]/);
  const basename = (
    /** @type {string} */
    parts.pop()
  );
  const last_dir = (
    /** @type {string} */
    parts.at(-1)
  );
  let name = basename.replace(".svelte", "");
  if (name === "index" && last_dir && last_dir !== "src") {
    name = last_dir;
  }
  return name[0].toUpperCase() + name.slice(1);
}
var RESERVED = ["$$props", "$$restProps", "$$slots"];
function analyze_module(ast, options) {
  const { scope, scopes } = create_scopes(ast, new ScopeRoot(), false, null);
  for (const [name, references] of scope.references) {
    if (name[0] !== "$" || RESERVED.includes(name)) continue;
    if (name === "$" || name[1] === "$") {
      global_reference_invalid(references[0].node, name);
    }
    const binding = scope.get(name.slice(1));
    if (binding !== null && !is_rune(name)) {
      store_invalid_subscription_module(references[0].node);
    }
  }
  const analysis = {
    module: { ast, scope, scopes },
    name: options.filename,
    accessors: false,
    runes: true,
    immutable: true,
    tracing: false
  };
  walk(
    /** @type {Node} */
    ast,
    {
      scope,
      scopes,
      analysis: (
        /** @type {ComponentAnalysis} */
        analysis
      ),
      derived_state: [],
      // TODO the following are not needed for modules, but we have to pass them in order to avoid type error,
      // and reducing the type would result in a lot of tedious type casts elsewhere - find a good solution one day
      ast_type: (
        /** @type {any} */
        null
      ),
      component_slots: /* @__PURE__ */ new Set(),
      expression: null,
      function_depth: 0,
      has_props_rune: false,
      options: (
        /** @type {ValidatedCompileOptions} */
        options
      ),
      parent_element: null,
      reactive_statement: null
    },
    visitors3
  );
  return analysis;
}
function analyze_component(root, source2, options) {
  var _a2, _b, _c;
  const scope_root = new ScopeRoot();
  const module = js(root.module, scope_root, false, null);
  const instance = js(root.instance, scope_root, true, module.scope);
  const { scope, scopes } = create_scopes(root.fragment, scope_root, false, instance.scope);
  const template3 = { ast: root.fragment, scope, scopes };
  let synthetic_stores_legacy_check = [];
  for (const [name, references] of module.scope.references) {
    if (name[0] !== "$" || RESERVED.includes(name)) continue;
    if (name === "$" || name[1] === "$") {
      global_reference_invalid(references[0].node, name);
    }
    const store_name = name.slice(1);
    const declaration2 = instance.scope.get(store_name);
    const init2 = (
      /** @type {Node | undefined} */
      declaration2 == null ? void 0 : declaration2.initial
    );
    if (options.runes === false || !is_rune(name) || declaration2 !== null && // const state = $state(0) is valid
    (get_rune(init2, instance.scope) === null || // rune-line names received as props are valid too (but we have to protect against $props as store)
    store_name !== "props" && get_rune(init2, instance.scope) === "$props") && // allow `import { derived } from 'svelte/store'` in the same file as `const x = $derived(..)` because one is not a subscription to the other
    !(name === "$derived" && ((_a2 = declaration2.initial) == null ? void 0 : _a2.type) === "ImportDeclaration" && declaration2.initial.source.value === "svelte/store")) {
      let is_nested_store_subscription_node = void 0;
      search: for (const reference of references) {
        for (let i = reference.path.length - 1; i >= 0; i--) {
          const scope2 = scopes.get(reference.path[i]) || module.scopes.get(reference.path[i]) || instance.scopes.get(reference.path[i]);
          if (scope2) {
            const owner = scope2 == null ? void 0 : scope2.owner(store_name);
            if (!!owner && owner !== module.scope && owner !== instance.scope) {
              is_nested_store_subscription_node = reference.node;
              break search;
            }
            break;
          }
        }
      }
      if (is_nested_store_subscription_node) {
        store_invalid_scoped_subscription(is_nested_store_subscription_node);
      }
      if (options.runes !== false) {
        if (declaration2 === null && /[a-z]/.test(store_name[0])) {
          global_reference_invalid(references[0].node, name);
        } else if (declaration2 !== null && is_rune(name)) {
          for (const { node, path } of references) {
            if (((_b = path.at(-1)) == null ? void 0 : _b.type) === "CallExpression") {
              store_rune_conflict(node, store_name);
            }
          }
        }
      }
      if (module.ast) {
        for (const { node, path } of references) {
          if (
            /** @type {number} */
            node.start > /** @type {number} */
            module.ast.start && /** @type {number} */
            node.end < /** @type {number} */
            module.ast.end && // const state = $state(0) is valid
            get_rune(
              /** @type {Node} */
              path.at(-1),
              module.scope
            ) === null
          ) {
            store_invalid_subscription(node);
          }
        }
      }
      synthetic_stores_legacy_check.push(() => {
        if (declaration2 !== null && declaration2.kind === "normal" && declaration2.declaration_kind === "let" && declaration2.reassigned) {
          declaration2.kind = "state";
        }
      });
      const binding = instance.scope.declare(id(name), "store_sub", "synthetic");
      binding.references = references;
      instance.scope.references.set(name, references);
      module.scope.references.delete(name);
    }
  }
  const component_name = get_component_name(options.filename);
  const runes = options.runes ?? Array.from(module.scope.references.keys()).some(is_rune);
  if (!runes) {
    for (let check of synthetic_stores_legacy_check) {
      check();
    }
  }
  if (runes && root.module) {
    const context = root.module.attributes.find((attribute) => attribute.name === "context");
    if (context) {
      script_context_deprecated(context);
    }
  }
  const analysis = {
    name: module.scope.generate(options.name ?? component_name),
    root: scope_root,
    module,
    instance,
    template: template3,
    elements: [],
    runes,
    tracing: false,
    immutable: runes || options.immutable,
    exports: [],
    uses_props: false,
    props_id: null,
    uses_rest_props: false,
    uses_slots: false,
    uses_component_bindings: false,
    uses_render_tags: false,
    needs_context: false,
    needs_mutation_validation: false,
    needs_props: false,
    event_directive_node: null,
    uses_event_attributes: false,
    custom_element: options.customElementOptions ?? options.customElement,
    inject_styles: options.css === "injected" || options.customElement,
    accessors: options.customElement ? true : (runes ? false : !!options.accessors) || // because $set method needs accessors
    ((_c = options.compatibility) == null ? void 0 : _c.componentApi) === 4,
    reactive_statements: /* @__PURE__ */ new Map(),
    binding_groups: /* @__PURE__ */ new Map(),
    slot_names: /* @__PURE__ */ new Map(),
    css: {
      ast: root.css,
      hash: root.css ? options.cssHash({
        css: root.css.content.styles,
        filename: options.filename,
        name: component_name,
        hash
      }) : "",
      keyframes: [],
      has_global: false
    },
    source: source2,
    undefined_exports: /* @__PURE__ */ new Map(),
    snippet_renderers: /* @__PURE__ */ new Map(),
    snippets: /* @__PURE__ */ new Set()
  };
  if (!runes) {
    for (const node of instance.ast.body) {
      if (node.type !== "ExportNamedDeclaration") continue;
      analysis.needs_props = true;
      if (node.declaration) {
        if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
          analysis.exports.push({
            name: (
              /** @type {import('estree').Identifier} */
              node.declaration.id.name
            ),
            alias: null
          });
        } else if (node.declaration.type === "VariableDeclaration") {
          if (node.declaration.kind === "const") {
            for (const declarator2 of node.declaration.declarations) {
              for (const node2 of extract_identifiers(declarator2.id)) {
                analysis.exports.push({ name: node2.name, alias: null });
              }
            }
          } else {
            for (const declarator2 of node.declaration.declarations) {
              for (const id2 of extract_identifiers(declarator2.id)) {
                const binding = (
                  /** @type {Binding} */
                  instance.scope.get(id2.name)
                );
                binding.kind = "bindable_prop";
              }
            }
          }
        }
      } else {
        for (const specifier of node.specifiers) {
          if (specifier.local.type !== "Identifier" || specifier.exported.type !== "Identifier") {
            continue;
          }
          const binding = instance.scope.get(specifier.local.name);
          if (binding && (binding.declaration_kind === "var" || binding.declaration_kind === "let")) {
            binding.kind = "bindable_prop";
            if (specifier.exported.name !== specifier.local.name) {
              binding.prop_alias = specifier.exported.name;
            }
          } else {
            analysis.exports.push({ name: specifier.local.name, alias: specifier.exported.name });
          }
        }
      }
    }
    for (const binding of instance.scope.declarations.values()) {
      if (binding.kind !== "normal") continue;
      for (const { node, path } of binding.references) {
        if (node === binding.node) continue;
        if (binding.updated) {
          if (path[path.length - 1].type === "StyleDirective" || path.some((node2) => node2.type === "Fragment") || path[1].type === "LabeledStatement" && path[1].label.name === "$") {
            binding.kind = "state";
          }
        }
      }
    }
    walk(
      /** @type {AST.SvelteNode} */
      template3.ast,
      null,
      {
        EachBlock(node) {
          const scope2 = (
            /** @type {Scope} */
            template3.scopes.get(node)
          );
          for (const binding of scope2.declarations.values()) {
            if (binding.updated) {
              const state = { scope: (
                /** @type {Scope} */
                scope2.parent
              ), scopes: template3.scopes };
              walk(node.expression, state, {
                // @ts-expect-error
                _: set_scope,
                Identifier(node2, context) {
                  const parent = (
                    /** @type {Expression} */
                    context.path.at(-1)
                  );
                  if (is_reference(node2, parent)) {
                    const binding2 = context.state.scope.get(node2.name);
                    if (binding2 && binding2.kind === "normal" && binding2.declaration_kind !== "import") {
                      binding2.kind = "state";
                      binding2.mutated = true;
                    }
                  }
                }
              });
              break;
            }
          }
        }
      }
    );
  }
  if (root.options) {
    for (const attribute of root.options.attributes) {
      if (attribute.name === "accessors" && analysis.runes) {
        options_deprecated_accessors(attribute);
      }
      if (attribute.name === "customElement" && !options.customElement) {
        options_missing_custom_element(attribute);
      }
      if (attribute.name === "immutable" && analysis.runes) {
        options_deprecated_immutable(attribute);
      }
    }
  }
  if (analysis.runes) {
    const props_refs = module.scope.references.get("$$props");
    if (props_refs) {
      legacy_props_invalid(props_refs[0].node);
    }
    const rest_props_refs = module.scope.references.get("$$restProps");
    if (rest_props_refs) {
      legacy_rest_props_invalid(rest_props_refs[0].node);
    }
    for (const { ast, scope: scope2, scopes: scopes2 } of [module, instance, template3]) {
      const state = {
        scope: scope2,
        scopes: scopes2,
        analysis,
        options,
        ast_type: ast === instance.ast ? "instance" : ast === template3.ast ? "template" : "module",
        parent_element: null,
        has_props_rune: false,
        component_slots: /* @__PURE__ */ new Set(),
        expression: null,
        derived_state: [],
        function_depth: scope2.function_depth,
        reactive_statement: null
      };
      walk(
        /** @type {AST.SvelteNode} */
        ast,
        state,
        visitors3
      );
    }
    for (const scope2 of [module.scope, instance.scope]) {
      outer: for (const [name, binding] of scope2.declarations) {
        if (binding.kind === "normal" && binding.reassigned) {
          inner: for (const { path } of binding.references) {
            if (path[0].type !== "Fragment") continue;
            for (let i = 1; i < path.length; i += 1) {
              const type = path[i].type;
              if (type === "FunctionDeclaration" || type === "FunctionExpression" || type === "ArrowFunctionExpression") {
                continue inner;
              }
              if (type === "BindDirective" && /** @type {AST.BindDirective} */
              path[i].name === "this") {
                for (let j = i - 1; j >= 0; j -= 1) {
                  const type2 = path[j].type;
                  if (type2 === "IfBlock" || type2 === "EachBlock" || type2 === "AwaitBlock" || type2 === "KeyBlock") {
                    non_reactive_update(binding.node, name);
                    continue outer;
                  }
                }
                continue inner;
              }
            }
            non_reactive_update(binding.node, name);
            continue outer;
          }
        }
      }
    }
  } else {
    instance.scope.declare(id("$$props"), "rest_prop", "synthetic");
    instance.scope.declare(id("$$restProps"), "rest_prop", "synthetic");
    for (const { ast, scope: scope2, scopes: scopes2 } of [module, instance, template3]) {
      const state = {
        scope: scope2,
        scopes: scopes2,
        analysis,
        options,
        parent_element: null,
        has_props_rune: false,
        ast_type: ast === instance.ast ? "instance" : ast === template3.ast ? "template" : "module",
        reactive_statement: null,
        component_slots: /* @__PURE__ */ new Set(),
        expression: null,
        derived_state: [],
        function_depth: scope2.function_depth
      };
      walk(
        /** @type {AST.SvelteNode} */
        ast,
        state,
        visitors3
      );
    }
    for (const [name, binding] of instance.scope.declarations) {
      if ((binding.kind === "prop" || binding.kind === "bindable_prop") && binding.node.name !== "$$props") {
        const references = binding.references.filter(
          (r) => {
            var _a3;
            return r.node !== binding.node && ((_a3 = r.path.at(-1)) == null ? void 0 : _a3.type) !== "ExportSpecifier";
          }
        );
        if (!references.length && !instance.scope.declarations.has(`$${name}`)) {
          export_let_unused(binding.node, name);
        }
      }
    }
    analysis.reactive_statements = order_reactive_statements(analysis.reactive_statements);
  }
  for (const node of analysis.module.ast.body) {
    if (node.type === "ExportNamedDeclaration" && node.specifiers !== null && node.source == null) {
      for (const specifier of node.specifiers) {
        if (specifier.local.type !== "Identifier") continue;
        const binding = analysis.module.scope.get(specifier.local.name);
        if (!binding) export_undefined(specifier, specifier.local.name);
      }
    }
  }
  if (analysis.event_directive_node && analysis.uses_event_attributes) {
    mixed_event_handler_syntaxes(
      analysis.event_directive_node,
      analysis.event_directive_node.name
    );
  }
  for (const [node, resolved] of analysis.snippet_renderers) {
    if (!resolved) {
      node.metadata.snippets = analysis.snippets;
    }
    for (const snippet of node.metadata.snippets) {
      snippet.metadata.sites.add(node);
    }
  }
  if (analysis.uses_render_tags && (analysis.uses_slots || !analysis.custom_element && analysis.slot_names.size > 0)) {
    const pos = analysis.slot_names.values().next().value ?? analysis.source.indexOf("$$slot");
    slot_snippet_conflict(pos);
  }
  if (analysis.css.ast) {
    analyze_css(analysis.css.ast, analysis);
    for (const node of analysis.elements) {
      prune(analysis.css.ast, node);
    }
    const { comment } = analysis.css.ast.content;
    const should_ignore_unused = comment && extract_svelte_ignore(comment.start, comment.data, analysis.runes).includes(
      "css_unused_selector"
    );
    if (!should_ignore_unused) {
      warn_unused(analysis.css.ast);
    }
  }
  for (const node of analysis.elements) {
    if (node.metadata.scoped && is_custom_element_node(node)) {
      mark_subtree_dynamic(node.metadata.path);
    }
    let has_class = false;
    let has_style = false;
    let has_spread = false;
    let has_class_directive = false;
    let has_style_directive = false;
    for (const attribute of node.attributes) {
      if (attribute.type === "SpreadAttribute") {
        has_spread = true;
        break;
      } else if (attribute.type === "Attribute") {
        has_class || (has_class = attribute.name.toLowerCase() === "class");
        has_style || (has_style = attribute.name.toLowerCase() === "style");
      } else if (attribute.type === "ClassDirective") {
        has_class_directive = true;
      } else if (attribute.type === "StyleDirective") {
        has_style_directive = true;
      }
    }
    if (!has_spread && !has_class && (node.metadata.scoped || has_class_directive)) {
      node.attributes.push(
        create_attribute("class", -1, -1, [
          {
            type: "Text",
            data: "",
            raw: "",
            start: -1,
            end: -1
          }
        ])
      );
    }
    if (!has_spread && !has_style && has_style_directive) {
      node.attributes.push(
        create_attribute("style", -1, -1, [
          {
            type: "Text",
            data: "",
            raw: "",
            start: -1,
            end: -1
          }
        ])
      );
    }
  }
  return analysis;
}
function order_reactive_statements(unsorted_reactive_declarations) {
  const lookup = /* @__PURE__ */ new Map();
  for (const [node, declaration2] of unsorted_reactive_declarations) {
    for (const binding of declaration2.assignments) {
      const statements = lookup.get(binding.node.name) ?? [];
      statements.push([node, declaration2]);
      lookup.set(binding.node.name, statements);
    }
  }
  const edges = [];
  for (const [, { assignments, dependencies }] of unsorted_reactive_declarations) {
    for (const assignment2 of assignments) {
      for (const dependency of dependencies) {
        if (!assignments.has(dependency)) {
          edges.push([assignment2.node.name, dependency.node.name]);
        }
      }
    }
  }
  const cycle = check_graph_for_cycles(edges);
  if (cycle == null ? void 0 : cycle.length) {
    const declaration2 = (
      /** @type {Tuple[]} */
      lookup.get(cycle[0])[0]
    );
    reactive_declaration_cycle(declaration2[0], cycle.join(" → "));
  }
  const reactive_declarations = /* @__PURE__ */ new Map();
  const add_declaration = (node, declaration2) => {
    if ([...reactive_declarations.values()].includes(declaration2)) return;
    for (const binding of declaration2.dependencies) {
      if (declaration2.assignments.has(binding)) continue;
      for (const [node2, earlier] of lookup.get(binding.node.name) ?? []) {
        add_declaration(node2, earlier);
      }
    }
    reactive_declarations.set(node, declaration2);
  };
  for (const [node, declaration2] of unsorted_reactive_declarations) {
    add_declaration(node, declaration2);
  }
  return reactive_declarations;
}

// node_modules/svelte/src/compiler/utils/mapped_code.js
var import_remapping = __toESM(require_remapping_umd(), 1);

// node_modules/svelte/src/compiler/utils/push_array.js
function push_array(array2, items) {
  for (let i = 0; i < items.length; i++) {
    array2.push(items[i]);
  }
}

// node_modules/svelte/src/compiler/utils/mapped_code.js
function last_line_length(s) {
  return s.length - s.lastIndexOf("\n") - 1;
}
function sourcemap_add_offset(map, offset, source_index) {
  if (map.mappings.length == 0) return;
  for (let line = 0; line < map.mappings.length; line++) {
    const segment_list = map.mappings[line];
    for (let segment = 0; segment < segment_list.length; segment++) {
      const seg = segment_list[segment];
      if (seg[1] === source_index) {
        if (seg[2] === 0) {
          seg[3] += offset.column;
        }
        seg[2] += offset.line;
      }
    }
  }
}
function merge_tables(this_table, other_table) {
  const new_table = this_table.slice();
  const idx_map = [];
  other_table = other_table || [];
  let val_changed = false;
  for (const [other_idx, other_val] of other_table.entries()) {
    const this_idx = this_table.indexOf(other_val);
    if (this_idx >= 0) {
      idx_map[other_idx] = this_idx;
    } else {
      const new_idx = new_table.length;
      new_table[new_idx] = other_val;
      idx_map[other_idx] = new_idx;
      val_changed = true;
    }
  }
  let idx_changed = val_changed;
  if (val_changed) {
    if (idx_map.find((val, idx) => val != idx) === void 0) {
      idx_changed = false;
    }
  }
  return [new_table, idx_map, val_changed, idx_changed];
}
var regex_line_token = /([^\w\s]|\s+)/g;
var MappedCode = class _MappedCode {
  /**
   * @param {string} string
   * @param {DecodedSourceMap | null} map
   */
  constructor(string2 = "", map = null) {
    /**
     * @type {string}
     */
    __publicField(this, "string");
    /**
     * @type {DecodedSourceMap}
     */
    __publicField(this, "map");
    this.string = string2;
    if (map) {
      this.map = map;
    } else {
      this.map = {
        version: 3,
        mappings: [],
        sources: [],
        names: []
      };
    }
  }
  /**
   * concat in-place (mutable), return this (chainable)
   * will also mutate the `other` object
   * @param {MappedCode} other
   * @returns {MappedCode}
   */
  concat(other) {
    if (other.string == "") return this;
    if (this.string == "") {
      this.string = other.string;
      this.map = other.map;
      return this;
    }
    const column_offset = last_line_length(this.string);
    this.string += other.string;
    const m1 = this.map;
    const m2 = other.map;
    if (m2.mappings.length == 0) return this;
    const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables(
      m1.sources,
      m2.sources
    );
    const [names, new_name_idx, names_changed, names_idx_changed] = merge_tables(
      m1.names,
      m2.names
    );
    if (sources_changed) m1.sources = sources;
    if (names_changed) m1.names = names;
    if (sources_idx_changed && names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]];
          if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]];
        }
      }
    } else if (sources_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[1] >= 0) seg[1] = new_source_idx[seg[1]];
        }
      }
    } else if (names_idx_changed) {
      for (let line = 0; line < m2.mappings.length; line++) {
        const segment_list = m2.mappings[line];
        for (let segment = 0; segment < segment_list.length; segment++) {
          const seg = segment_list[segment];
          if (seg[4] >= 0) seg[4] = new_name_idx[seg[4]];
        }
      }
    }
    if (m2.mappings.length > 0 && column_offset > 0) {
      const first_line = m2.mappings[0];
      for (let i = 0; i < first_line.length; i++) {
        first_line[i][0] += column_offset;
      }
    }
    push_array(
      m1.mappings[m1.mappings.length - 1],
      /** @type {SourceMapSegment[]} */
      m2.mappings.shift()
    );
    push_array(m1.mappings, m2.mappings);
    return this;
  }
  /**
   * @static
   * @param {string} string
   * @param {DecodedSourceMap} [map]
   * @returns {MappedCode}
   */
  static from_processed(string2, map) {
    const line_count = string2.split("\n").length;
    if (map) {
      const missing_lines = line_count - map.mappings.length;
      for (let i = 0; i < missing_lines; i++) {
        map.mappings.push([]);
      }
      return new _MappedCode(string2, map);
    }
    if (string2 == "") return new _MappedCode();
    map = { version: 3, names: [], sources: [], mappings: [] };
    for (let i = 0; i < line_count; i++) map.mappings.push([]);
    return new _MappedCode(string2, map);
  }
  /**
   * @static
   * @param {Source} opts
   * @returns {MappedCode}
   */
  static from_source({ source: source2, file_basename, get_location }) {
    let offset = get_location(0);
    if (!offset) offset = { line: 0, column: 0 };
    const map = { version: 3, names: [], sources: [file_basename], mappings: [] };
    if (source2 == "") return new _MappedCode(source2, map);
    const line_list = source2.split("\n");
    for (let line = 0; line < line_list.length; line++) {
      map.mappings.push([]);
      const token_list = line_list[line].split(regex_line_token);
      for (let token = 0, column = 0; token < token_list.length; token++) {
        if (token_list[token] == "") continue;
        map.mappings[line].push([column, 0, offset.line + line, column]);
        column += token_list[token].length;
      }
    }
    const segment_list = map.mappings[0];
    for (let segment = 0; segment < segment_list.length; segment++) {
      segment_list[segment][3] += offset.column;
    }
    return new _MappedCode(source2, map);
  }
};
var b64enc = typeof window !== "undefined" && typeof btoa === "function" ? (
  /** @param {string} str */
  (str) => btoa(unescape(encodeURIComponent(str)))
) : (
  /** @param {string} str */
  (str) => Buffer.from(str).toString("base64")
);
var b64dec = typeof window !== "undefined" && typeof atob === "function" ? atob : (
  /** @param {any} a */
  (a) => Buffer.from(a, "base64").toString()
);
function combine_sourcemaps(filename2, sourcemap_list) {
  if (sourcemap_list.length == 0) return null;
  let map_idx = 1;
  const map = sourcemap_list.slice(0, -1).find((m) => m.sources.length !== 1) === void 0 ? (0, import_remapping.default)(
    // use array interface
    // only the oldest sourcemap can have multiple sources
    sourcemap_list,
    () => null,
    true
    // skip optional field `sourcesContent`
  ) : (0, import_remapping.default)(
    // use loader interface
    sourcemap_list[0],
    // last map
    (sourcefile) => {
      if (sourcefile === filename2 && sourcemap_list[map_idx]) {
        return sourcemap_list[map_idx++];
      } else {
        return null;
      }
    },
    true
  );
  if (!map.file) delete map.file;
  if (!map.sources.length) map.sources = [filename2];
  return map;
}
function apply_preprocessor_sourcemap(filename2, svelte_map, preprocessor_map_input) {
  if (!svelte_map || !preprocessor_map_input) return svelte_map;
  const preprocessor_map = typeof preprocessor_map_input === "string" ? JSON.parse(preprocessor_map_input) : preprocessor_map_input;
  const result_map = combine_sourcemaps(filename2, [svelte_map, preprocessor_map]);
  Object.defineProperties(result_map, {
    toString: {
      enumerable: false,
      value: function toString() {
        return JSON.stringify(this);
      }
    },
    toUrl: {
      enumerable: false,
      value: function toUrl() {
        return "data:application/json;charset=utf-8;base64," + b64enc(this.toString());
      }
    }
  });
  return (
    /** @type {any} */
    result_map
  );
}
var regex_data_uri = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/;
function parse_attached_sourcemap(processed, tag_name) {
  const r_in = "[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)";
  const regex = tag_name == "script" ? new RegExp("(?://" + r_in + ")|(?:/\\*" + r_in + "\\s*\\*/)$") : new RegExp("/\\*" + r_in + "\\s*\\*/$");
  function log_warning(message) {
    const code_start = processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + " [...]";
    console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`);
  }
  processed.code = processed.code.replace(regex, (_, match1, match2) => {
    const map_url = tag_name == "script" ? match1 || match2 : match1;
    const map_data = (map_url.match(regex_data_uri) || [])[1];
    if (map_data) {
      if (processed.map) {
        log_warning(
          "Not implemented. Found sourcemap in both processed.code and processed.map. Please update your preprocessor to return only one sourcemap."
        );
        return "";
      }
      processed.map = b64dec(map_data);
      return "";
    }
    if (!processed.map) {
      log_warning(
        `Found sourcemap path ${JSON.stringify(
          map_url
        )} in processed.code, but no sourcemap data. Please update your preprocessor to return sourcemap data directly.`
      );
    }
    return "";
  });
}
function merge_with_preprocessor_map(result, options, source_name) {
  if (options.sourcemap) {
    const file_basename = get_basename(options.filename);
    result.map.sources = [file_basename];
    result.map = apply_preprocessor_sourcemap(
      file_basename,
      result.map,
      /** @type {any} */
      options.sourcemap
    );
    if (file_basename !== source_name) {
      result.map.sources = result.map.sources.map(
        /** @param {string} source */
        (source2) => get_relative_path(source_name, source2)
      );
    }
  }
}
function get_relative_path(from, to) {
  const from_parts = from.split(/[/\\]/);
  const to_parts = to.split(/[/\\]/);
  from_parts.pop();
  while (from_parts[0] === to_parts[0]) {
    from_parts.shift();
    to_parts.shift();
  }
  if (from_parts.length) {
    let i = from_parts.length;
    while (i--) from_parts[i] = "..";
  }
  return from_parts.concat(to_parts).join("/");
}
function get_basename(filename2) {
  return (
    /** @type {string} */
    filename2.split(/[/\\]/).pop()
  );
}
function get_source_name(filename2, output_filename, fallback) {
  return output_filename ? get_relative_path(output_filename, filename2) : get_basename(filename2);
}

// node_modules/svelte/src/compiler/phases/3-transform/css/index.js
function render_stylesheet(source2, analysis, options) {
  const code = new MagicString(source2);
  const state = {
    code,
    hash: analysis.css.hash,
    minify: analysis.inject_styles && !options.dev,
    selector: `.${analysis.css.hash}`,
    keyframes: analysis.css.keyframes,
    specificity: {
      bumped: false
    }
  };
  const ast = (
    /** @type {AST.CSS.StyleSheet} */
    analysis.css.ast
  );
  walk(
    /** @type {AST.CSS.Node} */
    ast,
    state,
    visitors4
  );
  code.remove(0, ast.content.start);
  code.remove(
    /** @type {number} */
    ast.content.end,
    source2.length
  );
  if (state.minify) {
    remove_preceding_whitespace(ast.content.end, state);
  }
  const css = {
    code: code.toString(),
    map: code.generateMap({
      // include source content; makes it easier/more robust looking up the source map code
      includeContent: true,
      // generateMap takes care of calculating source relative to file
      source: options.filename,
      file: options.cssOutputFilename || options.filename
    }),
    hasGlobal: analysis.css.has_global
  };
  merge_with_preprocessor_map(css, options, css.map.sources[0]);
  if (dev && options.css === "injected" && css.code) {
    css.code += `
/*# sourceMappingURL=${css.map.toUrl()} */`;
  }
  return css;
}
var visitors4 = {
  _: (node, context) => {
    context.state.code.addSourcemapLocation(node.start);
    context.state.code.addSourcemapLocation(node.end);
    context.next();
  },
  Atrule(node, { state, next: next2, path }) {
    if (is_keyframes_node(node)) {
      let start = node.start + node.name.length + 1;
      while (state.code.original[start] === " ") start += 1;
      let end = start;
      while (state.code.original[end] !== "{" && state.code.original[end] !== " ") end += 1;
      if (node.prelude.startsWith("-global-")) {
        state.code.remove(start, start + 8);
      } else if (!is_in_global_block2(path)) {
        state.code.prependRight(start, `${state.hash}-`);
      }
      return;
    }
    next2();
  },
  Declaration(node, { state }) {
    const property = node.property && remove_css_prefix(node.property.toLowerCase());
    if (property === "animation" || property === "animation-name") {
      let index = node.start + node.property.length + 1;
      let name = "";
      while (index < state.code.original.length) {
        const character = state.code.original[index];
        if (regex_css_name_boundary.test(character)) {
          if (state.keyframes.includes(name)) {
            state.code.prependRight(index - name.length, `${state.hash}-`);
          }
          if (character === ";" || character === "}") {
            break;
          }
          name = "";
        } else {
          name += character;
        }
        index++;
      }
    } else if (state.minify) {
      remove_preceding_whitespace(node.start, state);
      if (!node.property.startsWith("--")) {
        let start = node.start + node.property.length + 1;
        let end = start;
        while (/\s/.test(state.code.original[end])) end++;
        if (end > start) state.code.remove(start, end);
      }
    }
  },
  Rule(node, { state, next: next2, visit, path }) {
    if (state.minify) {
      remove_preceding_whitespace(node.start, state);
      remove_preceding_whitespace(node.block.end - 1, state);
    }
    if (!dev && is_empty(node, is_in_global_block2(path))) {
      if (state.minify) {
        state.code.remove(node.start, node.end);
      } else {
        state.code.prependRight(node.start, "/* (empty) ");
        state.code.appendLeft(node.end, "*/");
        escape_comment_close(node, state.code);
      }
      return;
    }
    if (!is_used(node) && !is_in_global_block2(path)) {
      if (state.minify) {
        state.code.remove(node.start, node.end);
      } else {
        state.code.prependRight(node.start, "/* (unused) ");
        state.code.appendLeft(node.end, "*/");
        escape_comment_close(node, state.code);
      }
      return;
    }
    if (node.metadata.is_global_block) {
      const selector = node.prelude.children[0];
      if (node.prelude.children.length === 1 && selector.children.length === 1 && selector.children[0].selectors.length === 1) {
        if (state.minify) {
          state.code.remove(node.start, node.block.start + 1);
          state.code.remove(node.block.end - 1, node.end);
        } else {
          state.code.prependRight(node.start, "/* ");
          state.code.appendLeft(node.block.start + 1, "*/");
          state.code.prependRight(node.block.end - 1, "/*");
          state.code.appendLeft(node.block.end, "*/");
        }
        visit(node.block);
        return;
      }
    }
    next2();
  },
  SelectorList(node, { state, next: next2, path }) {
    const parent = path.at(-1);
    if ((!is_in_global_block2(path) || node.children.length > 1 && (parent == null ? void 0 : parent.type) === "Rule" && parent.metadata.is_global_block) && !path.find((n) => n.type === "ComplexSelector" && !n.metadata.used)) {
      const children = node.children;
      let pruning = false;
      let prune_start = children[0].start;
      let last = prune_start;
      let has_previous_used = false;
      for (let i = 0; i < children.length; i += 1) {
        const selector = children[i];
        if (selector.metadata.used === pruning) {
          if (pruning) {
            let i2 = selector.start;
            while (state.code.original[i2] !== ",") i2--;
            if (state.minify) {
              state.code.remove(prune_start, has_previous_used ? i2 : i2 + 1);
            } else {
              state.code.appendRight(has_previous_used ? i2 : i2 + 1, "*/");
            }
          } else {
            if (i === 0) {
              if (state.minify) {
                prune_start = selector.start;
              } else {
                state.code.prependRight(selector.start, "/* (unused) ");
              }
            } else {
              if (state.minify) {
                prune_start = last;
              } else {
                state.code.overwrite(last, selector.start, ` /* (unused) `);
              }
            }
          }
          pruning = !pruning;
        }
        if (!pruning && selector.metadata.used) {
          has_previous_used = true;
        }
        last = selector.end;
      }
      if (pruning) {
        if (state.minify) {
          state.code.remove(prune_start, last);
        } else {
          state.code.appendLeft(last, "*/");
        }
      }
    }
    let specificity = state.specificity;
    if ((parent == null ? void 0 : parent.type) === "Rule") {
      specificity = { bumped: false };
      let rule = parent.metadata.parent_rule;
      while (rule) {
        if (rule.metadata.has_local_selectors) {
          specificity = { bumped: true };
          break;
        }
        rule = rule.metadata.parent_rule;
      }
    }
    next2({ ...state, specificity });
  },
  ComplexSelector(node, context) {
    var _a2;
    const before_bumped = context.state.specificity.bumped;
    for (const relative_selector of node.children) {
      if (relative_selector.metadata.is_global) {
        const global = (
          /** @type {AST.CSS.PseudoClassSelector} */
          relative_selector.selectors[0]
        );
        remove_global_pseudo_class(global, relative_selector.combinator, context.state);
        const parent_rule = (_a2 = node.metadata.rule) == null ? void 0 : _a2.metadata.parent_rule;
        if (parent_rule && global.args === null) {
          if (relative_selector.combinator === null) {
            context.state.code.prependRight(global.start, "&");
          }
          if (parent_rule.prelude.children.length > 1 && node.children.length === node.children.findIndex((s) => s === relative_selector) - 1) {
            const next_selector = parent_rule.prelude.children.find((s) => s.start > global.end);
            if (next_selector && next_selector.metadata.used) {
              context.state.code.update(global.end, next_selector.start, "");
            }
          }
        }
        continue;
      } else {
        for (const selector of relative_selector.selectors) {
          if (selector.type === "PseudoClassSelector" && selector.name === "global") {
            remove_global_pseudo_class(selector, null, context.state);
          }
        }
      }
      if (relative_selector.metadata.scoped) {
        if (relative_selector.selectors.length === 1) {
          const selector = relative_selector.selectors[0];
          if (selector.type === "PseudoClassSelector" && (selector.name === "is" || selector.name === "where")) {
            continue;
          }
        }
        if (relative_selector.selectors.some((s) => s.type === "NestingSelector")) {
          continue;
        }
        let modifier = context.state.selector;
        if (context.state.specificity.bumped) modifier = `:where(${modifier})`;
        context.state.specificity.bumped = true;
        let i = relative_selector.selectors.length;
        while (i--) {
          const selector = relative_selector.selectors[i];
          if (selector.type === "PseudoElementSelector" || selector.type === "PseudoClassSelector") {
            if (selector.name !== "root" && selector.name !== "host") {
              if (i === 0) context.state.code.prependRight(selector.start, modifier);
            }
            continue;
          }
          if (selector.type === "TypeSelector" && selector.name === "*") {
            context.state.code.update(selector.start, selector.end, modifier);
          } else {
            context.state.code.appendLeft(selector.end, modifier);
          }
          break;
        }
      }
    }
    context.next();
    context.state.specificity.bumped = before_bumped;
  },
  PseudoClassSelector(node, context) {
    if (node.name === "is" || node.name === "where" || node.name === "has" || node.name === "not") {
      context.next();
    }
  }
};
function is_in_global_block2(path) {
  return path.some((node) => node.type === "Rule" && node.metadata.is_global_block);
}
function remove_global_pseudo_class(selector, combinator, state) {
  if (selector.args === null) {
    let start = selector.start;
    if ((combinator == null ? void 0 : combinator.name) === " ") {
      while (/\s/.test(state.code.original[start - 1])) start--;
    }
    state.code.update(start, selector.start + ":global".length, "");
  } else {
    state.code.remove(selector.start, selector.start + ":global(".length).remove(selector.end - 1, selector.end);
  }
}
function remove_preceding_whitespace(end, state) {
  let start = end;
  while (/\s/.test(state.code.original[start - 1])) start--;
  if (start < end) state.code.remove(start, end);
}
function is_empty(rule, is_in_global_block3) {
  if (rule.metadata.is_global_block) {
    return rule.block.children.length === 0;
  }
  for (const child of rule.block.children) {
    if (child.type === "Declaration") {
      return false;
    }
    if (child.type === "Rule") {
      if ((is_used(child) || is_in_global_block3) && !is_empty(child, is_in_global_block3)) {
        return false;
      }
    }
    if (child.type === "Atrule") {
      if (child.block === null || child.block.children.length > 0) return false;
    }
  }
  return true;
}
function is_used(rule) {
  return rule.prelude.children.some((selector) => selector.metadata.used);
}
function escape_comment_close(node, code) {
  let escaped = false;
  let in_comment = false;
  for (let i = node.start; i < node.end; i++) {
    if (escaped) {
      escaped = false;
    } else {
      const char = code.original[i];
      if (in_comment) {
        if (char === "*" && code.original[i + 1] === "/") {
          code.prependRight(++i, "\\");
          in_comment = false;
        }
      } else if (char === "\\") {
        escaped = true;
      } else if (char === "/" && code.original[++i] === "*") {
        in_comment = true;
      }
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/shared/assignments.js
function visit_assignment_expression(node, context, build_assignment3) {
  if (node.left.type === "ArrayPattern" || node.left.type === "ObjectPattern" || node.left.type === "RestElement") {
    const value = (
      /** @type {Expression} */
      context.visit(node.right)
    );
    const should_cache = value.type !== "Identifier";
    const rhs = should_cache ? id("$$value") : value;
    let changed = false;
    const assignments = extract_paths(node.left).map((path) => {
      var _a2;
      const value2 = (_a2 = path.expression) == null ? void 0 : _a2.call(path, rhs);
      let assignment2 = build_assignment3("=", path.node, value2, context);
      if (assignment2 !== null) changed = true;
      return assignment2 ?? assignment(
        "=",
        /** @type {Pattern} */
        context.visit(path.node),
        /** @type {Expression} */
        context.visit(value2)
      );
    });
    if (!changed) {
      return null;
    }
    const is_standalone = (
      /** @type {Node} */
      context.path.at(-1).type.endsWith("Statement")
    );
    const sequence2 = sequence(assignments);
    if (!is_standalone) {
      sequence2.expressions.push(rhs);
    }
    if (should_cache) {
      const iife = arrow([rhs], sequence2);
      const iife_is_async = is_expression_async(value) || assignments.some((assignment2) => is_expression_async(assignment2));
      return iife_is_async ? await_builder(call(async(iife), value)) : call(iife, value);
    }
    return sequence2;
  }
  if (node.left.type !== "Identifier" && node.left.type !== "MemberExpression") {
    throw new Error(`Unexpected assignment type ${node.left.type}`);
  }
  return build_assignment3(node.operator, node.left, node.right, context);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/AssignmentExpression.js
function AssignmentExpression2(node, context) {
  return visit_assignment_expression(node, context, build_assignment) ?? context.next();
}
function build_assignment(operator, left, right, context) {
  let object4 = left;
  while (object4.type === "MemberExpression") {
    object4 = object4.object;
  }
  if (object4.type !== "Identifier" || !is_store_name(object4.name)) {
    return null;
  }
  const name = object4.name.slice(1);
  if (!context.state.scope.get(name)) {
    return null;
  }
  if (object4 === left) {
    let value = (
      /** @type {Expression} */
      context.visit(build_assignment_value(operator, left, right))
    );
    return call("$.store_set", id(name), value);
  }
  return call(
    "$.store_mutate",
    assignment("??=", id("$$store_subs"), object([])),
    literal(object4.name),
    id(name),
    assignment(
      operator,
      /** @type {Pattern} */
      context.visit(left),
      /** @type {Expression} */
      context.visit(right)
    )
  );
}
function is_store_name(name) {
  return name[0] === "$" && /[A-Za-z_]/.test(name[1]);
}

// node_modules/svelte/src/internal/server/hydration.js
var BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
var BLOCK_OPEN_ELSE = `<!--${HYDRATION_START_ELSE}-->`;
var BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
var EMPTY_COMMENT = `<!---->`;

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/utils.js
var block_open = literal(BLOCK_OPEN);
var block_close = literal(BLOCK_CLOSE);
var empty_comment = literal(EMPTY_COMMENT);
function process_children(nodes, { visit, state }) {
  let sequence2 = [];
  function flush() {
    let quasi2 = quasi("", false);
    const quasis = [quasi2];
    const expressions = [];
    for (let i = 0; i < sequence2.length; i++) {
      const node = sequence2[i];
      if (node.type === "Text" || node.type === "Comment") {
        quasi2.value.cooked += node.type === "Comment" ? `<!--${node.data}-->` : escape_html(node.data);
      } else {
        const evaluated = state.scope.evaluate(node.expression);
        if (evaluated.is_known) {
          quasi2.value.cooked += escape_html((evaluated.value ?? "") + "");
        } else {
          expressions.push(call(
            "$.escape",
            /** @type {Expression} */
            visit(node.expression)
          ));
          quasi2 = quasi("", i + 1 === sequence2.length);
          quasis.push(quasi2);
        }
      }
    }
    for (const quasi3 of quasis) {
      quasi3.value.raw = sanitize_template_string(
        /** @type {string} */
        quasi3.value.cooked
      );
    }
    state.template.push(template(quasis, expressions));
  }
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];
    if (node.type === "Text" || node.type === "Comment" || node.type === "ExpressionTag") {
      sequence2.push(node);
    } else {
      if (sequence2.length > 0) {
        flush();
        sequence2 = [];
      }
      visit(node, { ...state });
    }
  }
  if (sequence2.length > 0) {
    flush();
  }
}
function is_statement(node) {
  return node.type.endsWith("Statement") || node.type.endsWith("Declaration");
}
function build_template(template3, out = id("$$payload.out"), operator = "+=") {
  let strings = [];
  let expressions = [];
  const statements = [];
  const flush = () => {
    statements.push(
      stmt(
        assignment(
          operator,
          out,
          template(
            strings.map((cooked, i) => quasi(cooked, i === strings.length - 1)),
            expressions
          )
        )
      )
    );
    strings = [];
    expressions = [];
  };
  for (let i = 0; i < template3.length; i++) {
    const node = template3[i];
    if (is_statement(node)) {
      if (strings.length !== 0) {
        flush();
      }
      statements.push(node);
    } else {
      if (strings.length === 0) {
        strings.push("");
      }
      if (node.type === "Literal") {
        strings[strings.length - 1] += node.value;
      } else if (node.type === "TemplateLiteral") {
        strings[strings.length - 1] += node.quasis[0].value.cooked;
        strings.push(...node.quasis.slice(1).map((q) => (
          /** @type {string} */
          q.value.cooked
        )));
        expressions.push(...node.expressions);
      } else {
        expressions.push(node);
        strings.push("");
      }
    }
  }
  if (strings.length !== 0) {
    flush();
  }
  return statements;
}
function build_attribute_value(value, context, trim_whitespace = false, is_component = false) {
  if (value === true) {
    return true_instance;
  }
  if (!Array.isArray(value) || value.length === 1) {
    const chunk = Array.isArray(value) ? value[0] : value;
    if (chunk.type === "Text") {
      const data = trim_whitespace ? chunk.data.replace(regex_whitespaces_strict, " ").trim() : chunk.data;
      return literal(is_component ? data : escape_html(data, true));
    }
    return (
      /** @type {Expression} */
      context.visit(chunk.expression)
    );
  }
  let quasi2 = quasi("", false);
  const quasis = [quasi2];
  const expressions = [];
  for (let i = 0; i < value.length; i++) {
    const node = value[i];
    if (node.type === "Text") {
      quasi2.value.raw += trim_whitespace ? node.data.replace(regex_whitespaces_strict, " ") : node.data;
    } else {
      expressions.push(
        call(
          "$.stringify",
          /** @type {Expression} */
          context.visit(node.expression)
        )
      );
      quasi2 = quasi("", i + 1 === value.length);
      quasis.push(quasi2);
    }
  }
  return template(quasis, expressions);
}
function build_getter2(node, state) {
  const binding = state.scope.get(node.name);
  if (binding === null || node === binding.node) {
    return node;
  }
  if (binding.kind === "store_sub") {
    const store_id = id(node.name.slice(1));
    return call(
      "$.store_get",
      assignment("??=", id("$$store_subs"), object([])),
      literal(node.name),
      build_getter2(store_id, state)
    );
  }
  return node;
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/AwaitBlock.js
function AwaitBlock2(node, context) {
  context.state.template.push(
    stmt(
      call(
        "$.await",
        id("$$payload"),
        /** @type {Expression} */
        context.visit(node.expression),
        thunk(
          node.pending ? (
            /** @type {BlockStatement} */
            context.visit(node.pending)
          ) : block([])
        ),
        arrow(
          node.value ? [
            /** @type {Pattern} */
            context.visit(node.value)
          ] : [],
          node.then ? (
            /** @type {BlockStatement} */
            context.visit(node.then)
          ) : block([])
        )
      )
    ),
    block_close
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/utils.js
function is_hoisted_function(node) {
  var _a2;
  if (node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression" || node.type === "FunctionDeclaration") {
    return ((_a2 = node.metadata) == null ? void 0 : _a2.hoisted) === true;
  }
  return false;
}
function sort_const_tags(nodes, state) {
  const other = [];
  const tags = /* @__PURE__ */ new Map();
  for (const node of nodes) {
    if (node.type === "ConstTag") {
      const declaration2 = node.declaration.declarations[0];
      const bindings = extract_identifiers(declaration2.id).map((id2) => {
        return (
          /** @type {Binding} */
          state.scope.get(id2.name)
        );
      });
      const deps = /* @__PURE__ */ new Set();
      walk(declaration2.init, state, {
        // @ts-expect-error don't know, don't care
        _: set_scope,
        Identifier(node2, context) {
          const parent = (
            /** @type {Expression} */
            context.path.at(-1)
          );
          if (is_reference(node2, parent)) {
            const binding = context.state.scope.get(node2.name);
            if (binding) deps.add(binding);
          }
        }
      });
      for (const binding of bindings) {
        tags.set(binding, { node, deps });
      }
    } else {
      other.push(node);
    }
  }
  if (tags.size === 0) {
    return nodes;
  }
  const edges = [];
  for (const [id2, tag2] of tags) {
    for (const dep of tag2.deps) {
      if (tags.has(dep)) {
        edges.push([id2, dep]);
      }
    }
  }
  const cycle = check_graph_for_cycles(edges);
  if (cycle == null ? void 0 : cycle.length) {
    const tag2 = (
      /** @type {Tag} */
      tags.get(cycle[0])
    );
    const_tag_cycle(tag2.node, cycle.map((binding) => binding.node.name).join(" → "));
  }
  const sorted = [];
  function add(tag2) {
    if (sorted.includes(tag2.node)) {
      return;
    }
    for (const dep of tag2.deps) {
      const dep_tag = tags.get(dep);
      if (dep_tag) add(dep_tag);
    }
    sorted.push(tag2.node);
  }
  for (const tag2 of tags.values()) {
    add(tag2);
  }
  return [...sorted, ...other];
}
function clean_nodes(parent, nodes, path, namespace = "html", state, preserve_whitespace, preserve_comments) {
  if (!state.analysis.runes) {
    nodes = sort_const_tags(nodes, state);
  }
  const hoisted = [];
  const regular = [];
  for (const node of nodes) {
    if (node.type === "Comment" && !preserve_comments) {
      continue;
    }
    if (node.type === "ConstTag" || node.type === "DebugTag" || node.type === "SvelteBody" || node.type === "SvelteWindow" || node.type === "SvelteDocument" || node.type === "SvelteHead" || node.type === "TitleElement" || node.type === "SnippetBlock") {
      hoisted.push(node);
    } else {
      regular.push(node);
    }
  }
  let trimmed = regular;
  if (!preserve_whitespace) {
    trimmed = [];
    let first2, last;
    while ((first2 = regular[0]) && first2.type === "Text" && !regex_not_whitespace.test(first2.data)) {
      regular.shift();
    }
    if ((first2 == null ? void 0 : first2.type) === "Text") {
      first2.raw = first2.raw.replace(regex_starts_with_whitespaces, "");
      first2.data = first2.data.replace(regex_starts_with_whitespaces, "");
    }
    while ((last = regular.at(-1)) && last.type === "Text" && !regex_not_whitespace.test(last.data)) {
      regular.pop();
    }
    if ((last == null ? void 0 : last.type) === "Text") {
      last.raw = last.raw.replace(regex_ends_with_whitespaces, "");
      last.data = last.data.replace(regex_ends_with_whitespaces, "");
    }
    const can_remove_entirely = namespace === "svg" && (parent.type !== "RegularElement" || parent.name !== "text") && !path.some((n) => n.type === "RegularElement" && n.name === "text") || parent.type === "RegularElement" && // TODO others?
    (parent.name === "select" || parent.name === "tr" || parent.name === "table" || parent.name === "tbody" || parent.name === "thead" || parent.name === "tfoot" || parent.name === "colgroup" || parent.name === "datalist");
    for (let i = 0; i < regular.length; i++) {
      const prev = regular[i - 1];
      const node = regular[i];
      const next2 = regular[i + 1];
      if (node.type === "Text") {
        if ((prev == null ? void 0 : prev.type) !== "ExpressionTag") {
          const prev_is_text_ending_with_whitespace = (prev == null ? void 0 : prev.type) === "Text" && regex_ends_with_whitespaces.test(prev.data);
          node.data = node.data.replace(
            regex_starts_with_whitespaces,
            prev_is_text_ending_with_whitespace ? "" : " "
          );
          node.raw = node.raw.replace(
            regex_starts_with_whitespaces,
            prev_is_text_ending_with_whitespace ? "" : " "
          );
        }
        if ((next2 == null ? void 0 : next2.type) !== "ExpressionTag") {
          node.data = node.data.replace(regex_ends_with_whitespaces, " ");
          node.raw = node.raw.replace(regex_ends_with_whitespaces, " ");
        }
        if (node.data && (node.data !== " " || !can_remove_entirely)) {
          trimmed.push(node);
        }
      } else {
        trimmed.push(node);
      }
    }
  }
  var first = trimmed[0];
  if (parent.type === "RegularElement" && parent.name === "pre" && (first == null ? void 0 : first.type) === "Text") {
    const text2 = first.data.replace(regex_starts_with_newline, "");
    if (text2 !== first.data) {
      const tmp = text2.replace(regex_starts_with_newline, "");
      if (text2 === tmp) {
        first.data = text2;
        first.raw = first.raw.replace(regex_starts_with_newline, "");
        if (first.data === "") {
          trimmed.shift();
          first = trimmed[0];
        }
      }
    }
  }
  if (trimmed.length === 1 && first.type === "RegularElement" && first.name === "script") {
    trimmed.push({
      type: "Comment",
      data: "",
      start: -1,
      end: -1
    });
  }
  return {
    hoisted,
    trimmed,
    /**
     * In a case like `{#if x}<Foo />{/if}`, we don't need to wrap the child in
     * comments — we can just use the parent block's anchor for the component.
     * TODO extend this optimisation to other cases
     */
    is_standalone: trimmed.length === 1 && (first.type === "RenderTag" && !first.metadata.dynamic || first.type === "Component" && !state.options.hmr && !first.metadata.dynamic && !first.attributes.some(
      (attribute) => attribute.type === "Attribute" && attribute.name.startsWith("--")
    )),
    /** if a component/snippet/each block starts with text, we need to add an anchor comment so that its text node doesn't get fused with its surroundings */
    is_text_first: (parent.type === "Fragment" || parent.type === "SnippetBlock" || parent.type === "EachBlock" || parent.type === "SvelteComponent" || parent.type === "SvelteBoundary" || parent.type === "Component" || parent.type === "SvelteSelf") && first && ((first == null ? void 0 : first.type) === "Text" || (first == null ? void 0 : first.type) === "ExpressionTag")
  };
}
function infer_namespace(namespace, parent, nodes) {
  if (parent.type === "RegularElement" && parent.name === "foreignObject") {
    return "html";
  }
  if (parent.type === "RegularElement" || parent.type === "SvelteElement") {
    if (parent.metadata.svg) {
      return "svg";
    }
    return parent.metadata.mathml ? "mathml" : "html";
  }
  if (parent.type === "Fragment" || parent.type === "Root" || parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteFragment" || parent.type === "SnippetBlock" || parent.type === "SlotElement") {
    const new_namespace2 = check_nodes_for_namespace(nodes, "keep");
    if (new_namespace2 !== "keep" && new_namespace2 !== "maybe_html") {
      return new_namespace2;
    }
  }
  let new_namespace = null;
  for (const node of nodes) {
    if (node.type !== "RegularElement") continue;
    if (node.metadata.mathml) {
      new_namespace = new_namespace === null || new_namespace === "mathml" ? "mathml" : "html";
    } else if (node.metadata.svg) {
      new_namespace = new_namespace === null || new_namespace === "svg" ? "svg" : "html";
    } else {
      return "html";
    }
  }
  return new_namespace ?? namespace;
}
function check_nodes_for_namespace(nodes, namespace) {
  const RegularElement4 = (node, { stop }) => {
    if (!node.metadata.svg && !node.metadata.mathml) {
      namespace = "html";
      stop();
    } else if (namespace === "keep") {
      namespace = node.metadata.svg ? "svg" : "mathml";
    }
  };
  for (const node of nodes) {
    walk(
      node,
      {},
      {
        _(node2, { next: next2 }) {
          if (node2.type === "EachBlock" || node2.type === "IfBlock" || node2.type === "AwaitBlock" || node2.type === "Fragment" || node2.type === "KeyBlock" || node2.type === "RegularElement" || node2.type === "SvelteElement" || node2.type === "Text") {
            next2();
          }
        },
        SvelteElement: RegularElement4,
        RegularElement: RegularElement4,
        Text(node2) {
          if (node2.data.trim() !== "") {
            namespace = "maybe_html";
          }
        }
      }
    );
    if (namespace === "html") return namespace;
  }
  return namespace;
}
function determine_namespace_for_children(node, namespace) {
  if (node.name === "foreignObject") {
    return "html";
  }
  if (node.metadata.svg) {
    return "svg";
  }
  return node.metadata.mathml ? "mathml" : "html";
}
function transform_inspect_rune(node, context) {
  const { state, visit } = context;
  const as_fn = state.options.generate === "client";
  if (!dev) return empty;
  if (node.callee.type === "MemberExpression") {
    const raw_inspect_args = (
      /** @type {CallExpression} */
      node.callee.object.arguments
    );
    const inspect_args = (
      /** @type {Array<Expression>} */
      raw_inspect_args.map((arg) => visit(arg))
    );
    const with_arg = (
      /** @type {Expression} */
      visit(node.arguments[0])
    );
    return call(
      "$.inspect",
      as_fn ? thunk(array(inspect_args)) : array(inspect_args),
      with_arg
    );
  } else {
    const arg = node.arguments.map((arg2) => (
      /** @type {Expression} */
      visit(arg2)
    ));
    return call("$.inspect", as_fn ? thunk(array(arg)) : array(arg));
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/CallExpression.js
function CallExpression2(node, context) {
  const rune = get_rune(node, context.state.scope);
  if (rune === "$host") {
    return void0;
  }
  if (rune === "$effect.tracking") {
    return false_instance;
  }
  if (rune === "$effect.root") {
    return arrow([], block([]));
  }
  if (rune === "$state.snapshot") {
    return call(
      "$.snapshot",
      /** @type {Expression} */
      context.visit(node.arguments[0]),
      is_ignored(node, "state_snapshot_uncloneable") && true_instance
    );
  }
  if (rune === "$inspect" || rune === "$inspect().with") {
    return transform_inspect_rune(node, context);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/ClassBody.js
function ClassBody2(node, context) {
  var _a2, _b;
  if (!context.state.analysis.runes) {
    context.next();
    return;
  }
  const public_derived = /* @__PURE__ */ new Map();
  const private_derived = /* @__PURE__ */ new Map();
  const private_ids = [];
  for (const definition of node.body) {
    if (definition.type === "PropertyDefinition" && (definition.key.type === "Identifier" || definition.key.type === "PrivateIdentifier")) {
      const { type, name } = definition.key;
      const is_private = type === "PrivateIdentifier";
      if (is_private) private_ids.push(name);
      if (((_a2 = definition.value) == null ? void 0 : _a2.type) === "CallExpression") {
        const rune = get_rune(definition.value, context.state.scope);
        if (rune === "$derived" || rune === "$derived.by") {
          const field = {
            kind: rune === "$derived.by" ? "derived_by" : "derived",
            // @ts-expect-error this is set in the next pass
            id: is_private ? definition.key : null
          };
          if (is_private) {
            private_derived.set(name, field);
          } else {
            public_derived.set(name, field);
          }
        }
      }
    }
  }
  for (const [name, field] of public_derived) {
    let deconflicted = name;
    while (private_ids.includes(deconflicted)) {
      deconflicted = "_" + deconflicted;
    }
    private_ids.push(deconflicted);
    field.id = private_id(deconflicted);
  }
  const body = [];
  const child_state = { ...context.state, private_derived };
  for (const definition of node.body) {
    if (definition.type === "PropertyDefinition" && (definition.key.type === "Identifier" || definition.key.type === "PrivateIdentifier")) {
      const name = definition.key.name;
      const is_private = definition.key.type === "PrivateIdentifier";
      const field = (is_private ? private_derived : public_derived).get(name);
      if (((_b = definition.value) == null ? void 0 : _b.type) === "CallExpression" && field !== void 0) {
        const init2 = (
          /** @type {Expression} **/
          context.visit(definition.value.arguments[0], child_state)
        );
        const value = field.kind === "derived_by" ? call("$.once", init2) : call("$.once", thunk(init2));
        if (is_private) {
          body.push(prop_def(field.id, value));
        } else {
          const member2 = member(this_instance, field.id);
          body.push(prop_def(field.id, value));
          body.push(method("get", definition.key, [], [return_builder(call(member2))]));
          if (dev && (field.kind === "derived" || field.kind === "derived_by")) {
            body.push(
              method(
                "set",
                definition.key,
                [id("_")],
                [throw_error(`Cannot update a derived property ('${name}')`)]
              )
            );
          }
        }
        continue;
      }
    }
    body.push(
      /** @type {MethodDefinition} **/
      context.visit(definition, child_state)
    );
  }
  return { ...node, body };
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/component.js
function build_inline_component(node, expression, context) {
  const props_and_spreads = [];
  const delayed_props = [];
  const custom_css_props = [];
  const lets = { default: [] };
  const child_state = {
    ...context.state,
    scope: node.metadata.scopes.default
  };
  const children = {};
  const slot_scope_applies_to_itself = node.attributes.some(
    (node2) => node2.type === "Attribute" && node2.name === "slot"
  );
  let has_children_prop = false;
  function push_prop(prop2, delay = false) {
    const do_push = () => {
      const current = props_and_spreads.at(-1);
      const current_is_props = Array.isArray(current);
      const props = current_is_props ? current : [];
      props.push(prop2);
      if (!current_is_props) {
        props_and_spreads.push(props);
      }
    };
    if (delay) {
      delayed_props.push(do_push);
    } else {
      do_push();
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      if (!slot_scope_applies_to_itself) {
        lets.default.push(attribute);
      }
    } else if (attribute.type === "SpreadAttribute") {
      props_and_spreads.push(
        /** @type {Expression} */
        context.visit(attribute)
      );
    } else if (attribute.type === "Attribute") {
      if (attribute.name.startsWith("--")) {
        const value2 = build_attribute_value(attribute.value, context, false, true);
        custom_css_props.push(init(attribute.name, value2));
        continue;
      }
      if (attribute.name === "children") {
        has_children_prop = true;
      }
      const value = build_attribute_value(attribute.value, context, false, true);
      push_prop(prop("init", key(attribute.name), value));
    } else if (attribute.type === "BindDirective" && attribute.name !== "this") {
      if (attribute.expression.type === "SequenceExpression") {
        const [get2, set2] = (
          /** @type {SequenceExpression} */
          context.visit(attribute.expression).expressions
        );
        const get_id = id(context.state.scope.generate("bind_get"));
        const set_id = id(context.state.scope.generate("bind_set"));
        context.state.init.push(var_builder(get_id, get2));
        context.state.init.push(var_builder(set_id, set2));
        push_prop(get(attribute.name, [return_builder(call(get_id))]));
        push_prop(set(attribute.name, [stmt(call(set_id, id("$$value")))]));
      } else {
        push_prop(
          get(attribute.name, [
            return_builder(
              /** @type {Expression} */
              context.visit(attribute.expression)
            )
          ]),
          true
        );
        push_prop(
          set(attribute.name, [
            stmt(
              /** @type {Expression} */
              context.visit(assignment("=", attribute.expression, id("$$value")))
            ),
            stmt(assignment("=", id("$$settled"), false_instance))
          ]),
          true
        );
      }
    }
  }
  delayed_props.forEach((fn) => fn());
  const snippet_declarations = [];
  const serialized_slots = [];
  for (const child of node.fragment.nodes) {
    if (child.type === "SnippetBlock") {
      context.visit(child, {
        ...context.state,
        init: snippet_declarations
      });
      push_prop(prop("init", child.expression, child.expression));
      serialized_slots.push(
        init(child.expression.name === "children" ? "default" : child.expression.name, true_instance)
      );
      continue;
    }
    let slot_name = "default";
    if (is_element_node(child)) {
      const slot = (
        /** @type {AST.Attribute | undefined} */
        child.attributes.find(
          (attribute) => attribute.type === "Attribute" && attribute.name === "slot"
        )
      );
      if (slot !== void 0) {
        slot_name = /** @type {AST.Text[]} */
        slot.value[0].data;
        lets[slot_name] = child.attributes.filter((attribute) => attribute.type === "LetDirective");
      } else if (child.type === "SvelteFragment") {
        lets.default.push(
          ...child.attributes.filter((attribute) => attribute.type === "LetDirective")
        );
      }
    }
    children[slot_name] = children[slot_name] || [];
    children[slot_name].push(child);
  }
  for (const slot_name of Object.keys(children)) {
    const block2 = (
      /** @type {BlockStatement} */
      context.visit(
        {
          ...node.fragment,
          // @ts-expect-error
          nodes: children[slot_name]
        },
        slot_name === "default" ? child_state : {
          ...context.state,
          scope: node.metadata.scopes[slot_name]
        }
      )
    );
    if (block2.body.length === 0) continue;
    const params = [id("$$payload")];
    if (lets[slot_name].length > 0) {
      const pattern = object_pattern(
        lets[slot_name].map((node2) => {
          if (node2.expression === null) {
            return init(node2.name, id(node2.name));
          }
          if (node2.expression.type === "ObjectExpression") {
            return init(node2.name, object_pattern(node2.expression.properties));
          }
          if (node2.expression.type === "ArrayExpression") {
            return init(node2.name, array_pattern(node2.expression.elements));
          }
          return init(node2.name, node2.expression);
        })
      );
      params.push(pattern);
    }
    const slot_fn = arrow(params, block(block2.body));
    if (slot_name === "default" && !has_children_prop) {
      if (lets.default.length === 0 && children.default.every(
        (node2) => node2.type !== "SvelteFragment" || !node2.attributes.some((attr) => attr.type === "LetDirective")
      )) {
        push_prop(
          prop(
            "init",
            id("children"),
            dev ? call("$.prevent_snippet_stringification", slot_fn) : slot_fn
          )
        );
        serialized_slots.push(init(slot_name, true_instance));
      } else {
        serialized_slots.push(init(slot_name, slot_fn));
        push_prop(init("children", id("$.invalid_default_snippet")));
      }
    } else {
      serialized_slots.push(init(slot_name, slot_fn));
    }
  }
  if (serialized_slots.length > 0) {
    push_prop(prop("init", id("$$slots"), object(serialized_slots)));
  }
  const props_expression = props_and_spreads.length === 0 || props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]) ? object(
    /** @type {Property[]} */
    props_and_spreads[0] || []
  ) : call(
    "$.spread_props",
    array(props_and_spreads.map((p) => Array.isArray(p) ? object(p) : p))
  );
  let statement = stmt(
    (node.type === "SvelteComponent" ? maybe_call : call)(
      expression,
      id("$$payload"),
      props_expression
    )
  );
  if (snippet_declarations.length > 0) {
    statement = block([...snippet_declarations, statement]);
  }
  const dynamic = node.type === "SvelteComponent" || node.type === "Component" && node.metadata.dynamic;
  if (custom_css_props.length > 0) {
    context.state.template.push(
      stmt(
        call(
          "$.css_props",
          id("$$payload"),
          literal(context.state.namespace === "svg" ? false : true),
          object(custom_css_props),
          thunk(block([statement])),
          dynamic && true_instance
        )
      )
    );
  } else {
    if (dynamic) {
      context.state.template.push(empty_comment);
    }
    context.state.template.push(statement);
    if (!context.state.skip_hydration_boundaries) {
      context.state.template.push(empty_comment);
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Component.js
function Component2(node, context) {
  build_inline_component(node, id(node.name), context);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/ConstTag.js
function ConstTag2(node, context) {
  const declaration2 = node.declaration.declarations[0];
  const id2 = (
    /** @type {Pattern} */
    context.visit(declaration2.id)
  );
  const init2 = (
    /** @type {Expression} */
    context.visit(declaration2.init)
  );
  context.state.init.push(const_builder(id2, init2));
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/DebugTag.js
function DebugTag2(node, context) {
  context.state.template.push(
    stmt(
      call(
        "console.log",
        object(
          node.identifiers.map(
            (identifier) => prop(
              "init",
              identifier,
              /** @type {Expression} */
              context.visit(identifier)
            )
          )
        )
      )
    ),
    debugger_builder
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/EachBlock.js
function EachBlock2(node, context) {
  const state = context.state;
  const each_node_meta = node.metadata;
  const collection = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const index = each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : id(node.index);
  const array_id = state.scope.root.unique("each_array");
  state.init.push(const_builder(array_id, call("$.ensure_array_like", collection)));
  const each = [];
  if (node.context) {
    each.push(let_builder(node.context, member(array_id, index, true)));
  }
  if (index.name !== node.index && node.index != null) {
    each.push(let_builder(node.index, index));
  }
  each.push(.../** @type {BlockStatement} */
  context.visit(node.body).body);
  const for_loop = for_builder(
    declaration("let", [
      declarator(index, literal(0)),
      declarator("$$length", member(array_id, "length"))
    ]),
    binary("<", index, id("$$length")),
    update("++", index, false),
    block(each)
  );
  if (node.fallback) {
    const open2 = stmt(assignment("+=", id("$$payload.out"), block_open));
    const fallback = (
      /** @type {BlockStatement} */
      context.visit(node.fallback)
    );
    fallback.body.unshift(
      stmt(assignment("+=", id("$$payload.out"), literal(BLOCK_OPEN_ELSE)))
    );
    state.template.push(
      if_builder(
        binary("!==", member(array_id, "length"), literal(0)),
        block([open2, for_loop]),
        fallback
      ),
      block_close
    );
  } else {
    state.template.push(block_open, for_loop, block_close);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/ExpressionStatement.js
function ExpressionStatement2(node, context) {
  const rune = get_rune(node.expression, context.state.scope);
  if (rune === "$effect" || rune === "$effect.pre" || rune === "$effect.root" || rune === "$inspect.trace") {
    return empty;
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Fragment.js
function Fragment(node, context) {
  const parent = context.path.at(-1) ?? node;
  const namespace = infer_namespace(context.state.namespace, parent, node.nodes);
  const { hoisted, trimmed, is_standalone, is_text_first } = clean_nodes(
    parent,
    node.nodes,
    context.path,
    namespace,
    context.state,
    context.state.preserve_whitespace,
    context.state.options.preserveComments
  );
  const state = {
    ...context.state,
    init: [],
    template: [],
    namespace,
    skip_hydration_boundaries: is_standalone
  };
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (is_text_first) {
    state.template.push(empty_comment);
  }
  process_children(trimmed, { ...context, state });
  return block([...state.init, ...build_template(state.template)]);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/HtmlTag.js
function HtmlTag2(node, context) {
  const expression = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  context.state.template.push(call("$.html", expression));
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/Identifier.js
function Identifier2(node, context) {
  if (is_reference(
    node,
    /** @type {Node} */
    context.path.at(-1)
  )) {
    if (node.name === "$$props") {
      return id("$$sanitized_props");
    }
    return build_getter2(node, context.state);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/IfBlock.js
function IfBlock2(node, context) {
  const consequent = (
    /** @type {BlockStatement} */
    context.visit(node.consequent)
  );
  consequent.body.unshift(stmt(assignment("+=", id("$$payload.out"), block_open)));
  let if_statement = if_builder(
    /** @type {Expression} */
    context.visit(node.test),
    consequent
  );
  context.state.template.push(if_statement, block_close);
  let index = 1;
  let alt = node.alternate;
  while (alt && alt.nodes.length === 1 && alt.nodes[0].type === "IfBlock" && alt.nodes[0].elseif) {
    const elseif = alt.nodes[0];
    const alternate = (
      /** @type {BlockStatement} */
      context.visit(elseif.consequent)
    );
    alternate.body.unshift(
      stmt(assignment("+=", id("$$payload.out"), literal(`<!--[${index++}-->`)))
    );
    if_statement = if_statement.alternate = if_builder(
      /** @type {Expression} */
      context.visit(elseif.test),
      alternate
    );
    alt = elseif.alternate;
  }
  if_statement.alternate = alt ? (
    /** @type {BlockStatement} */
    context.visit(alt)
  ) : block([]);
  if_statement.alternate.body.unshift(
    stmt(assignment("+=", id("$$payload.out"), literal(BLOCK_OPEN_ELSE)))
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/KeyBlock.js
function KeyBlock2(node, context) {
  context.state.template.push(
    empty_comment,
    /** @type {BlockStatement} */
    context.visit(node.fragment),
    empty_comment
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/LabeledStatement.js
function LabeledStatement2(node, context) {
  if (context.state.analysis.runes || context.path.length > 1 || node.label.name !== "$") {
    return;
  }
  context.state.legacy_reactive_statements.set(
    node,
    // people could do "break $" inside, so we need to keep the label
    labeled(
      "$",
      /** @type {ExpressionStatement} */
      context.visit(node.body)
    )
  );
  return empty;
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/MemberExpression.js
function MemberExpression2(node, context) {
  if (context.state.analysis.runes && node.object.type === "ThisExpression" && node.property.type === "PrivateIdentifier") {
    const field = context.state.private_derived.get(node.property.name);
    if (field) {
      return call(node);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/PropertyDefinition.js
function PropertyDefinition(node, context) {
  if (context.state.analysis.runes && node.value != null && node.value.type === "CallExpression") {
    const rune = get_rune(node.value, context.state.scope);
    if (rune === "$state" || rune === "$state.raw" || rune === "$derived") {
      return {
        ...node,
        value: node.value.arguments.length === 0 ? null : (
          /** @type {Expression} */
          context.visit(node.value.arguments[0])
        )
      };
    }
    if (rune === "$derived.by") {
      return {
        ...node,
        value: node.value.arguments.length === 0 ? null : call(
          /** @type {Expression} */
          context.visit(node.value.arguments[0])
        )
      };
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/shared/element.js
var WHITESPACE_INSENSITIVE_ATTRIBUTES = ["class", "style"];
function build_element_attributes(node, context) {
  const attributes = [];
  const class_directives = [];
  const style_directives = [];
  let content = null;
  let has_spread = false;
  let events_to_capture = /* @__PURE__ */ new Set();
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "value") {
        if (node.name === "textarea") {
          if (attribute.value !== true && Array.isArray(attribute.value) && attribute.value[0].type === "Text" && regex_starts_with_newline.test(attribute.value[0].data)) {
            attribute.value[0].data = "\n" + attribute.value[0].data;
          }
          content = call("$.escape", build_attribute_value(attribute.value, context));
        } else if (node.name !== "select") {
          attributes.push(attribute);
        }
      } else if (is_event_attribute(attribute)) {
        if ((attribute.name === "onload" || attribute.name === "onerror") && is_load_error_element(node.name)) {
          events_to_capture.add(attribute.name);
        }
      } else if (attribute.name !== "defaultValue" && attribute.name !== "defaultChecked") {
        if (attribute.name === "class") {
          if (attribute.metadata.needs_clsx) {
            attributes.push({
              ...attribute,
              value: {
                .../** @type {AST.ExpressionTag} */
                attribute.value,
                expression: call(
                  "$.clsx",
                  /** @type {AST.ExpressionTag} */
                  attribute.value.expression
                )
              }
            });
          } else {
            attributes.push(attribute);
          }
        } else {
          attributes.push(attribute);
        }
      }
    } else if (attribute.type === "BindDirective") {
      if (attribute.name === "value" && node.name === "select") continue;
      if (attribute.name === "value" && attributes.some(
        (attr) => attr.type === "Attribute" && attr.name === "type" && is_text_attribute(attr) && attr.value[0].data === "file"
      )) {
        continue;
      }
      if (attribute.name === "this") continue;
      const binding = binding_properties[attribute.name];
      if (binding == null ? void 0 : binding.omit_in_ssr) continue;
      let expression = (
        /** @type {Expression} */
        context.visit(attribute.expression)
      );
      if (expression.type === "SequenceExpression") {
        expression = call(expression.expressions[0]);
      }
      if (is_content_editable_binding(attribute.name)) {
        content = expression;
      } else if (attribute.name === "value" && node.name === "textarea") {
        content = call("$.escape", expression);
      } else if (attribute.name === "group" && attribute.expression.type !== "SequenceExpression") {
        const value_attribute = (
          /** @type {AST.Attribute | undefined} */
          node.attributes.find((attr) => attr.type === "Attribute" && attr.name === "value")
        );
        if (!value_attribute) continue;
        const is_checkbox = node.attributes.some(
          (attr) => attr.type === "Attribute" && attr.name === "type" && is_text_attribute(attr) && attr.value[0].data === "checkbox"
        );
        attributes.push(
          create_attribute("checked", -1, -1, [
            {
              type: "ExpressionTag",
              start: -1,
              end: -1,
              expression: is_checkbox ? call(
                member(attribute.expression, "includes"),
                build_attribute_value(value_attribute.value, context)
              ) : binary(
                "===",
                attribute.expression,
                build_attribute_value(value_attribute.value, context)
              ),
              metadata: {
                expression: create_expression_metadata()
              }
            }
          ])
        );
      } else {
        attributes.push(
          create_attribute(attribute.name, -1, -1, [
            {
              type: "ExpressionTag",
              start: -1,
              end: -1,
              expression,
              metadata: {
                expression: create_expression_metadata()
              }
            }
          ])
        );
      }
    } else if (attribute.type === "SpreadAttribute") {
      attributes.push(attribute);
      has_spread = true;
      if (is_load_error_element(node.name)) {
        events_to_capture.add("onload");
        events_to_capture.add("onerror");
      }
    } else if (attribute.type === "UseDirective") {
      if (is_load_error_element(node.name)) {
        events_to_capture.add("onload");
        events_to_capture.add("onerror");
      }
    } else if (attribute.type === "ClassDirective") {
      class_directives.push(attribute);
    } else if (attribute.type === "StyleDirective") {
      style_directives.push(attribute);
    } else if (attribute.type === "LetDirective") {
    } else {
      context.visit(attribute);
    }
  }
  if (has_spread) {
    build_element_spread_attributes(node, attributes, style_directives, class_directives, context);
  } else {
    const css_hash = node.metadata.scoped ? context.state.analysis.css.hash : null;
    for (
      const attribute of
      /** @type {AST.Attribute[]} */
      attributes
    ) {
      const name = get_attribute_name(node, attribute);
      const can_use_literal = (name !== "class" || class_directives.length === 0) && (name !== "style" || style_directives.length === 0);
      if (can_use_literal && (attribute.value === true || is_text_attribute(attribute))) {
        let literal_value = (
          /** @type {Literal} */
          build_attribute_value(
            attribute.value,
            context,
            WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
          ).value
        );
        if (name === "class" && css_hash) {
          literal_value = (String(literal_value) + " " + css_hash).trim();
        }
        if (name !== "class" || literal_value) {
          context.state.template.push(
            literal(
              ` ${attribute.name}${is_boolean_attribute(name) && literal_value === true ? "" : `="${literal_value === true ? "" : String(literal_value)}"`}`
            )
          );
        }
        continue;
      }
      const value = build_attribute_value(
        attribute.value,
        context,
        WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
      );
      if (can_use_literal && value.type === "Literal" && typeof value.value === "string") {
        if (name === "class" && css_hash) {
          value.value = (value.value + " " + css_hash).trim();
        }
        context.state.template.push(literal(` ${name}="${escape_html(value.value, true)}"`));
      } else if (name === "class") {
        context.state.template.push(build_attr_class(class_directives, value, context, css_hash));
      } else if (name === "style") {
        context.state.template.push(build_attr_style(style_directives, value, context));
      } else {
        context.state.template.push(
          call("$.attr", literal(name), value, is_boolean_attribute(name) && true_instance)
        );
      }
    }
  }
  if (events_to_capture.size !== 0) {
    for (const event of events_to_capture) {
      context.state.template.push(literal(` ${event}="this.__e=event"`));
    }
  }
  return content;
}
function get_attribute_name(element2, attribute) {
  let name = attribute.name;
  if (!element2.metadata.svg && !element2.metadata.mathml) {
    name = name.toLowerCase();
  }
  return name;
}
function build_element_spread_attributes(element2, attributes, style_directives, class_directives, context) {
  let classes;
  let styles;
  let flags = 0;
  if (class_directives.length) {
    const properties = class_directives.map(
      (directive) => init(
        directive.name,
        directive.expression.type === "Identifier" && directive.expression.name === directive.name ? id(directive.name) : (
          /** @type {Expression} */
          context.visit(directive.expression)
        )
      )
    );
    classes = object(properties);
  }
  if (style_directives.length > 0) {
    const properties = style_directives.map(
      (directive) => init(
        directive.name,
        directive.value === true ? id(directive.name) : build_attribute_value(directive.value, context, true)
      )
    );
    styles = object(properties);
  }
  if (element2.metadata.svg || element2.metadata.mathml) {
    flags |= ELEMENT_IS_NAMESPACED | ELEMENT_PRESERVE_ATTRIBUTE_CASE;
  } else if (is_custom_element_node(element2)) {
    flags |= ELEMENT_PRESERVE_ATTRIBUTE_CASE;
  }
  const object4 = object(
    attributes.map((attribute) => {
      if (attribute.type === "Attribute") {
        const name = get_attribute_name(element2, attribute);
        const value = build_attribute_value(
          attribute.value,
          context,
          WHITESPACE_INSENSITIVE_ATTRIBUTES.includes(name)
        );
        return prop("init", key(name), value);
      }
      return spread(
        /** @type {Expression} */
        context.visit(attribute)
      );
    })
  );
  const css_hash = element2.metadata.scoped && context.state.analysis.css.hash ? literal(context.state.analysis.css.hash) : null_instance;
  const args = [object4, css_hash, classes, styles, flags ? literal(flags) : void 0];
  context.state.template.push(call("$.spread_attributes", ...args));
}
function build_attr_class(class_directives, expression, context, hash2) {
  let directives;
  if (class_directives.length) {
    directives = object(
      class_directives.map(
        (directive) => prop(
          "init",
          literal(directive.name),
          /** @type {Expression} */
          context.visit(directive.expression, context.state)
        )
      )
    );
  }
  let css_hash;
  if (hash2) {
    if (expression.type === "Literal" && typeof expression.value === "string") {
      expression.value = (expression.value + " " + hash2).trim();
    } else {
      css_hash = literal(hash2);
    }
  }
  return call("$.attr_class", expression, css_hash, directives);
}
function build_attr_style(style_directives, expression, context) {
  let directives;
  if (style_directives.length) {
    let normal_properties = [];
    let important_properties = [];
    for (const directive of style_directives) {
      const expression2 = directive.value === true ? id(directive.name) : build_attribute_value(directive.value, context, true);
      let name = directive.name;
      if (name[0] !== "-" || name[1] !== "-") {
        name = name.toLowerCase();
      }
      const property = init(directive.name, expression2);
      if (directive.modifiers.includes("important")) {
        important_properties.push(property);
      } else {
        normal_properties.push(property);
      }
    }
    if (important_properties.length) {
      directives = array([object(normal_properties), object(important_properties)]);
    } else {
      directives = object(normal_properties);
    }
  }
  return call("$.attr_style", expression, directives);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/RegularElement.js
function RegularElement2(node, context) {
  const namespace = determine_namespace_for_children(node, context.state.namespace);
  const state = {
    ...context.state,
    namespace,
    preserve_whitespace: context.state.preserve_whitespace || node.name === "pre" || node.name === "textarea"
  };
  context.state.template.push(literal(`<${node.name}`));
  const body = build_element_attributes(node, { ...context, state });
  context.state.template.push(literal(">"));
  if ((node.name === "script" || node.name === "style") && node.fragment.nodes.length === 1) {
    context.state.template.push(
      literal(
        /** @type {AST.Text} */
        node.fragment.nodes[0].data
      ),
      literal(`</${node.name}>`)
    );
    return;
  }
  const { hoisted, trimmed } = clean_nodes(
    node,
    node.fragment.nodes,
    context.path,
    namespace,
    {
      ...state,
      scope: (
        /** @type {Scope} */
        state.scopes.get(node.fragment)
      )
    },
    state.preserve_whitespace,
    state.options.preserveComments
  );
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (dev) {
    const location = (
      /** @type {Location} */
      locator(node.start)
    );
    state.template.push(
      stmt(
        call(
          "$.push_element",
          id("$$payload"),
          literal(node.name),
          literal(location.line),
          literal(location.column)
        )
      )
    );
  }
  if (body === null) {
    process_children(trimmed, { ...context, state });
  } else {
    let id2 = body;
    if (body.type !== "Identifier") {
      id2 = id(state.scope.generate("$$body"));
      state.template.push(const_builder(id2, body));
    }
    const inner_state = { ...state, template: [], init: [] };
    process_children(trimmed, { ...context, state: inner_state });
    state.template.push(
      if_builder(
        id2,
        block(build_template([id2])),
        block([...inner_state.init, ...build_template(inner_state.template)])
      )
    );
  }
  if (!is_void(node.name)) {
    state.template.push(literal(`</${node.name}>`));
  }
  if (dev) {
    state.template.push(stmt(call("$.pop_element")));
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/RenderTag.js
function RenderTag2(node, context) {
  const callee = unwrap_optional(node.expression).callee;
  const raw_args = unwrap_optional(node.expression).arguments;
  const snippet_function = (
    /** @type {Expression} */
    context.visit(callee)
  );
  const snippet_args = raw_args.map((arg) => {
    return (
      /** @type {Expression} */
      context.visit(arg)
    );
  });
  context.state.template.push(
    stmt(
      (node.expression.type === "CallExpression" ? call : maybe_call)(
        snippet_function,
        id("$$payload"),
        ...snippet_args
      )
    )
  );
  if (!context.state.skip_hydration_boundaries) {
    context.state.template.push(empty_comment);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SlotElement.js
function SlotElement2(node, context) {
  const props = [];
  const spreads = [];
  let name = literal("default");
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") {
      spreads.push(
        /** @type {Expression} */
        context.visit(attribute)
      );
    } else if (attribute.type === "Attribute") {
      const value = build_attribute_value(attribute.value, context, false, true);
      if (attribute.name === "name") {
        name = /** @type {Literal} */
        value;
      } else if (attribute.name !== "slot") {
        props.push(init(attribute.name, value));
      }
    }
  }
  const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", array([object(props), ...spreads]));
  const fallback = node.fragment.nodes.length === 0 ? null_instance : thunk(
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
  const slot = call(
    "$.slot",
    id("$$payload"),
    id("$$props"),
    name,
    props_expression,
    fallback
  );
  context.state.template.push(empty_comment, stmt(slot), empty_comment);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SnippetBlock.js
function SnippetBlock2(node, context) {
  let fn = function_declaration(
    node.expression,
    [id("$$payload"), ...node.parameters],
    /** @type {BlockStatement} */
    context.visit(node.body)
  );
  fn.___snippet = true;
  const statements = node.metadata.can_hoist ? context.state.hoisted : context.state.init;
  if (dev) {
    fn.body.body.unshift(stmt(call("$.validate_snippet_args", id("$$payload"))));
    statements.push(stmt(call("$.prevent_snippet_stringification", fn.id)));
  }
  statements.push(fn);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SpreadAttribute.js
function SpreadAttribute2(node, context) {
  return context.visit(node.expression);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteComponent.js
function SvelteComponent2(node, context) {
  build_inline_component(
    node,
    /** @type {Expression} */
    context.visit(node.expression),
    context
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteElement.js
function SvelteElement2(node, context) {
  let tag2 = (
    /** @type {Expression} */
    context.visit(node.tag)
  );
  if (dev) {
    if (tag2.type !== "Identifier") {
      const tag_id = context.state.scope.generate("$$tag");
      context.state.init.push(const_builder(tag_id, tag2));
      tag2 = id(tag_id);
    }
    if (node.fragment.nodes.length > 0) {
      context.state.init.push(stmt(call("$.validate_void_dynamic_element", thunk(tag2))));
    }
    context.state.init.push(stmt(call("$.validate_dynamic_element_tag", thunk(tag2))));
  }
  const state = {
    ...context.state,
    namespace: determine_namespace_for_children(node, context.state.namespace),
    template: [],
    init: []
  };
  build_element_attributes(node, { ...context, state });
  if (dev) {
    const location = (
      /** @type {Location} */
      locator(node.start)
    );
    context.state.template.push(
      stmt(
        call(
          "$.push_element",
          id("$$payload"),
          tag2,
          literal(location.line),
          literal(location.column)
        )
      )
    );
  }
  const attributes = block([...state.init, ...build_template(state.template)]);
  const children = (
    /** @type {BlockStatement} */
    context.visit(node.fragment, state)
  );
  context.state.template.push(
    stmt(
      call(
        "$.element",
        id("$$payload"),
        tag2,
        attributes.body.length > 0 && thunk(attributes),
        children.body.length > 0 && thunk(children)
      )
    )
  );
  if (dev) {
    context.state.template.push(stmt(call("$.pop_element")));
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteFragment.js
function SvelteFragment2(node, context) {
  context.state.template.push(
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteHead.js
function SvelteHead2(node, context) {
  const block2 = (
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
  context.state.template.push(
    stmt(call("$.head", id("$$payload"), arrow([id("$$payload")], block2)))
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteSelf.js
function SvelteSelf2(node, context) {
  build_inline_component(node, id(context.state.analysis.name), context);
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/TitleElement.js
function TitleElement2(node, context) {
  const template3 = [literal("<title>")];
  process_children(node.fragment.nodes, { ...context, state: { ...context.state, template: template3 } });
  template3.push(literal("</title>"));
  context.state.init.push(...build_template(template3, id("$$payload.title"), "="));
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/UpdateExpression.js
function UpdateExpression2(node, context) {
  var _a2;
  const argument = node.argument;
  if (argument.type === "Identifier" && ((_a2 = context.state.scope.get(argument.name)) == null ? void 0 : _a2.kind) === "store_sub") {
    return call(
      node.prefix ? "$.update_store_pre" : "$.update_store",
      assignment("??=", id("$$store_subs"), object([])),
      literal(argument.name),
      id(argument.name.slice(1)),
      node.operator === "--" && literal(-1)
    );
  }
  return context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/VariableDeclaration.js
function VariableDeclaration(node, context) {
  var _a2;
  const declarations = [];
  if (context.state.analysis.runes) {
    for (const declarator2 of node.declarations) {
      const init2 = declarator2.init;
      const rune = get_rune(init2, context.state.scope);
      if (!rune || rune === "$effect.tracking" || rune === "$inspect" || rune === "$effect.root") {
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (rune === "$props.id") {
        continue;
      }
      if (rune === "$props") {
        let has_rest = false;
        let id2 = walk(declarator2.id, null, {
          RestElement(node2, context2) {
            if (context2.path.at(-1) === declarator2.id) {
              has_rest = true;
            }
          },
          AssignmentPattern(node2) {
            if (node2.right.type === "CallExpression" && get_rune(node2.right, context.state.scope) === "$bindable") {
              const right = node2.right.arguments.length ? (
                /** @type {Expression} */
                context.visit(node2.right.arguments[0])
              ) : void0;
              return assignment_pattern(node2.left, right);
            }
          }
        });
        const slots_name = (
          /** @type {ComponentAnalysis} */
          context.state.analysis.uses_slots ? id("$$slots_") : id("$$slots")
        );
        if (id2.type === "ObjectPattern" && has_rest) {
          id2.properties.splice(
            id2.properties.length - 1,
            0,
            // @ts-ignore
            prop("init", id("$$slots"), slots_name),
            prop("init", id("$$events"), id("$$events"))
          );
        } else if (id2.type === "Identifier") {
          id2 = object_pattern([
            prop("init", id("$$slots"), slots_name),
            prop("init", id("$$events"), id("$$events")),
            rest(id(id2.name))
          ]);
        }
        declarations.push(
          declarator(
            /** @type {Pattern} */
            context.visit(id2),
            id("$$props")
          )
        );
        continue;
      }
      const args = (
        /** @type {CallExpression} */
        init2.arguments
      );
      const value = args.length > 0 ? (
        /** @type {Expression} */
        context.visit(args[0])
      ) : void0;
      if (rune === "$derived.by") {
        declarations.push(
          declarator(
            /** @type {Pattern} */
            context.visit(declarator2.id),
            call(value)
          )
        );
        continue;
      }
      if (declarator2.id.type === "Identifier") {
        declarations.push(declarator(declarator2.id, value));
        continue;
      }
      if (rune === "$derived") {
        declarations.push(
          declarator(
            /** @type {Pattern} */
            context.visit(declarator2.id),
            value
          )
        );
        continue;
      }
      declarations.push(...create_state_declarators(declarator2, context.state.scope, value));
    }
  } else {
    for (const declarator2 of node.declarations) {
      const bindings = (
        /** @type {Binding[]} */
        context.state.scope.get_bindings(declarator2)
      );
      const has_state = bindings.some((binding) => binding.kind === "state");
      const has_props = bindings.some((binding) => binding.kind === "bindable_prop");
      if (!has_state && !has_props) {
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (has_props) {
        if (declarator2.id.type !== "Identifier") {
          const tmp = context.state.scope.generate("tmp");
          const paths = extract_paths(declarator2.id);
          declarations.push(
            declarator(
              id(tmp),
              /** @type {Expression} */
              context.visit(
                /** @type {Expression} */
                declarator2.init
              )
            )
          );
          for (const path of paths) {
            const value = (_a2 = path.expression) == null ? void 0 : _a2.call(path, id(tmp));
            const name = (
              /** @type {Identifier} */
              path.node.name
            );
            const binding2 = (
              /** @type {Binding} */
              context.state.scope.get(name)
            );
            const prop3 = member(id("$$props"), literal(binding2.prop_alias ?? name), true);
            declarations.push(declarator(path.node, build_fallback(prop3, value)));
          }
          continue;
        }
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(declarator2.id.name)
        );
        const prop2 = member(
          id("$$props"),
          literal(binding.prop_alias ?? declarator2.id.name),
          true
        );
        let init2 = prop2;
        if (declarator2.init) {
          const default_value = (
            /** @type {Expression} */
            context.visit(declarator2.init)
          );
          init2 = build_fallback(prop2, default_value);
        }
        declarations.push(declarator(declarator2.id, init2));
        continue;
      }
      declarations.push(
        ...create_state_declarators(
          declarator2,
          context.state.scope,
          /** @type {Expression} */
          declarator2.init && context.visit(declarator2.init)
        )
      );
    }
  }
  if (declarations.length === 0) {
    return empty;
  }
  return {
    ...node,
    declarations
  };
}
function create_state_declarators(declarator2, scope, value) {
  if (declarator2.id.type === "Identifier") {
    return [declarator(declarator2.id, value)];
  }
  const tmp = scope.generate("tmp");
  const paths = extract_paths(declarator2.id);
  return [
    declarator(id(tmp), value),
    // TODO inject declarator for opts, so we can use it below
    ...paths.map((path) => {
      var _a2;
      const value2 = (_a2 = path.expression) == null ? void 0 : _a2.call(path, id(tmp));
      return declarator(path.node, value2);
    })
  ];
}

// node_modules/svelte/src/compiler/phases/3-transform/server/visitors/SvelteBoundary.js
function SvelteBoundary2(node, context) {
  context.state.template.push(
    literal(BLOCK_OPEN),
    /** @type {BlockStatement} */
    context.visit(node.fragment),
    literal(BLOCK_CLOSE)
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/server/transform-server.js
var global_visitors = {
  _: set_scope,
  AssignmentExpression: AssignmentExpression2,
  CallExpression: CallExpression2,
  ClassBody: ClassBody2,
  ExpressionStatement: ExpressionStatement2,
  Identifier: Identifier2,
  LabeledStatement: LabeledStatement2,
  MemberExpression: MemberExpression2,
  PropertyDefinition,
  UpdateExpression: UpdateExpression2,
  VariableDeclaration
};
var template_visitors = {
  AwaitBlock: AwaitBlock2,
  Component: Component2,
  ConstTag: ConstTag2,
  DebugTag: DebugTag2,
  EachBlock: EachBlock2,
  Fragment,
  HtmlTag: HtmlTag2,
  IfBlock: IfBlock2,
  KeyBlock: KeyBlock2,
  RegularElement: RegularElement2,
  RenderTag: RenderTag2,
  SlotElement: SlotElement2,
  SnippetBlock: SnippetBlock2,
  SpreadAttribute: SpreadAttribute2,
  SvelteComponent: SvelteComponent2,
  SvelteElement: SvelteElement2,
  SvelteFragment: SvelteFragment2,
  SvelteHead: SvelteHead2,
  SvelteSelf: SvelteSelf2,
  TitleElement: TitleElement2,
  SvelteBoundary: SvelteBoundary2
};
function server_component(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    hoisted: [import_all("$", "svelte/internal/server")],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    // these are set inside the `Fragment` visitor, and cannot be used until then
    init: (
      /** @type {any} */
      null
    ),
    template: (
      /** @type {any} */
      null
    ),
    namespace: options.namespace,
    preserve_whitespace: options.preserveWhitespace,
    private_derived: /* @__PURE__ */ new Map(),
    skip_hydration_boundaries: false
  };
  const module = (
    /** @type {Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.module.ast,
      state,
      global_visitors
    )
  );
  const instance = (
    /** @type {Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.instance.ast,
      { ...state, scopes: analysis.instance.scopes },
      {
        ...global_visitors,
        ImportDeclaration(node) {
          state.hoisted.push(node);
          return empty;
        },
        ExportNamedDeclaration(node, context) {
          if (node.declaration) {
            return context.visit(node.declaration);
          }
          return empty;
        }
      }
    )
  );
  const template3 = (
    /** @type {Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.template.ast,
      { ...state, scopes: analysis.template.scopes },
      // @ts-expect-error don't know, don't care
      { ...global_visitors, ...template_visitors }
    )
  );
  const legacy_reactive_declarations = [];
  for (const [node] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n]) => n === node);
    if (statement === void 0) {
      throw new Error("Could not find reactive statement");
    }
    if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
      for (const id2 of extract_identifiers(node.body.expression.left)) {
        const binding = analysis.instance.scope.get(id2.name);
        if ((binding == null ? void 0 : binding.kind) === "legacy_reactive") {
          legacy_reactive_declarations.push(declarator(id2));
        }
      }
    }
    instance.body.push(statement[1]);
  }
  if (legacy_reactive_declarations.length > 0) {
    instance.body.unshift({
      type: "VariableDeclaration",
      kind: "let",
      declarations: legacy_reactive_declarations
    });
  }
  if (analysis.uses_component_bindings) {
    const snippets = template3.body.filter(
      // @ts-expect-error
      (node) => node.type === "FunctionDeclaration" && node.___snippet
    );
    const rest2 = template3.body.filter(
      // @ts-expect-error
      (node) => node.type !== "FunctionDeclaration" || !node.___snippet
    );
    template3.body = [
      ...snippets,
      let_builder("$$settled", true_instance),
      let_builder("$$inner_payload"),
      function_declaration(
        id("$$render_inner"),
        [id("$$payload")],
        block(
          /** @type {Statement[]} */
          rest2
        )
      ),
      do_while(
        unary("!", id("$$settled")),
        block([
          stmt(assignment("=", id("$$settled"), true_instance)),
          stmt(
            assignment("=", id("$$inner_payload"), call("$.copy_payload", id("$$payload")))
          ),
          stmt(call("$$render_inner", id("$$inner_payload")))
        ])
      ),
      stmt(call("$.assign_payload", id("$$payload"), id("$$inner_payload")))
    ];
  }
  if ([...analysis.instance.scope.declarations.values()].some(
    (binding) => binding.kind === "store_sub"
  )) {
    instance.body.unshift(var_builder("$$store_subs"));
    template3.body.push(
      if_builder(id("$$store_subs"), stmt(call("$.unsubscribe_stores", id("$$store_subs"))))
    );
  }
  const props = [];
  for (const [name, binding] of analysis.instance.scope.declarations) {
    if (binding.kind === "bindable_prop" && !name.startsWith("$$")) {
      props.push(init(binding.prop_alias ?? name, id(name)));
    }
  }
  for (const { name, alias } of analysis.exports) {
    props.push(init(alias ?? name, id(name)));
  }
  if (props.length > 0) {
    template3.body.push(stmt(call("$.bind_props", id("$$props"), object(props))));
  }
  const component_block = block([
    .../** @type {Statement[]} */
    instance.body,
    .../** @type {Statement[]} */
    template3.body
  ]);
  if (analysis.props_id) {
    component_block.body.unshift(
      const_builder(analysis.props_id, call("$.props_id", id("$$payload")))
    );
  }
  let should_inject_context = dev || analysis.needs_context;
  if (should_inject_context) {
    component_block.body.unshift(stmt(call("$.push", dev && id(analysis.name))));
    component_block.body.push(stmt(call("$.pop")));
  }
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name, alias }) => alias ?? name);
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "bindable_prop") named_props.push(binding.prop_alias ?? name);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call(
          "$.rest_props",
          id("$$sanitized_props"),
          array(named_props.map((name) => literal(name)))
        )
      )
    );
  }
  if (analysis.uses_props || analysis.uses_rest_props) {
    component_block.body.unshift(
      const_builder("$$sanitized_props", call("$.sanitize_props", id("$$props")))
    );
  }
  if (analysis.uses_slots) {
    component_block.body.unshift(const_builder("$$slots", call("$.sanitize_slots", id("$$props"))));
  }
  const body = [...state.hoisted, ...module.body];
  if (analysis.css.ast !== null && options.css === "injected" && !options.customElement) {
    const hash2 = literal(analysis.css.hash);
    const code = literal(render_stylesheet(analysis.source, analysis, options).code);
    body.push(const_builder("$$css", object([init("hash", hash2), init("code", code)])));
    component_block.body.unshift(stmt(call("$$payload.css.add", id("$$css"))));
  }
  let should_inject_props = should_inject_context || props.length > 0 || analysis.needs_props || analysis.uses_props || analysis.uses_rest_props || analysis.uses_slots || analysis.slot_names.size > 0;
  const component_function = function_declaration(
    id(analysis.name),
    should_inject_props ? [id("$$payload"), id("$$props")] : [id("$$payload")],
    component_block
  );
  if (options.compatibility.componentApi === 4) {
    body.unshift(imports([["render", "$$_render"]], "svelte/server"));
    body.push(
      component_function,
      stmt(
        assignment(
          "=",
          member_id(`${analysis.name}.render`),
          function_builder(
            null,
            [id("$$props"), id("$$opts")],
            block([
              return_builder(
                call(
                  "$$_render",
                  id(analysis.name),
                  object([
                    init("props", id("$$props")),
                    init("context", member(id("$$opts"), "context", false, true))
                  ])
                )
              )
            ])
          )
        )
      ),
      export_default(id(analysis.name))
    );
  } else if (dev) {
    body.push(
      component_function,
      stmt(
        assignment(
          "=",
          member_id(`${analysis.name}.render`),
          function_builder(
            null,
            [],
            block([
              throw_error(
                `Component.render(...) is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information`
              )
            ])
          )
        )
      ),
      export_default(id(analysis.name))
    );
  } else {
    body.push(export_default(component_function));
  }
  if (dev) {
    body.unshift(
      stmt(
        assignment("=", member(id(analysis.name), "$.FILENAME", true), literal(filename))
      )
    );
  }
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}
function server_module(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    // this is an anomaly — it can only be used in components, but it needs
    // to be present for `javascript_visitors_legacy` and so is included in module
    // transform state as well as component transform state
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    private_derived: /* @__PURE__ */ new Map()
  };
  const module = (
    /** @type {Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.module.ast,
      state,
      global_visitors
    )
  );
  return {
    type: "Program",
    sourceType: "module",
    body: [import_all("$", "svelte/internal/server"), ...module.body]
  };
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AnimateDirective.js
function AnimateDirective(node, context) {
  const expression = node.expression === null ? null_instance : thunk(
    /** @type {Expression} */
    context.visit(node.expression)
  );
  context.state.after_update.push(
    stmt(
      call(
        "$.animation",
        context.state.node,
        thunk(
          /** @type {Expression} */
          context.visit(parse_directive_name(node.name))
        ),
        expression
      )
    )
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/function.js
var visit_function2 = (node, context) => {
  const metadata = node.metadata;
  let state = { ...context.state, in_constructor: false };
  if (node.type === "FunctionExpression") {
    const parent = (
      /** @type {Node} */
      context.path.at(-1)
    );
    state.in_constructor = parent.type === "MethodDefinition" && parent.kind === "constructor";
  }
  if ((metadata == null ? void 0 : metadata.hoisted) === true) {
    const params = build_hoisted_params(node, context);
    return (
      /** @type {FunctionExpression} */
      {
        ...node,
        params,
        body: context.visit(node.body, state)
      }
    );
  }
  context.next(state);
};

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ArrowFunctionExpression.js
function ArrowFunctionExpression2(node, context) {
  return visit_function2(node, context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AssignmentExpression.js
function AssignmentExpression3(node, context) {
  const expression = (
    /** @type {Expression} */
    visit_assignment_expression(node, context, build_assignment2) ?? context.next()
  );
  return validate_mutation(node, context, expression);
}
function is_non_coercive_operator(operator) {
  return ["=", "||=", "&&=", "??="].includes(operator);
}
var callees = {
  "=": "$.assign",
  "&&=": "$.assign_and",
  "||=": "$.assign_or",
  "??=": "$.assign_nullish"
};
function build_assignment2(operator, left, right, context) {
  if (context.state.analysis.runes && left.type === "MemberExpression" && left.property.type === "PrivateIdentifier") {
    const private_state = context.state.private_state.get(left.property.name);
    if (private_state !== void 0) {
      let value = (
        /** @type {Expression} */
        context.visit(build_assignment_value(operator, left, right))
      );
      const needs_proxy = private_state.kind === "state" && is_non_coercive_operator(operator) && should_proxy(value, context.state.scope);
      return call("$.set", left, value, needs_proxy && true_instance);
    }
  }
  let object4 = left;
  while (object4.type === "MemberExpression") {
    object4 = object4.object;
  }
  if (object4.type !== "Identifier") {
    return null;
  }
  const binding = context.state.scope.get(object4.name);
  if (!binding) return null;
  const transform = Object.hasOwn(context.state.transform, object4.name) ? context.state.transform[object4.name] : null;
  const path = context.path.map((node) => node.type);
  if (object4 === left && (transform == null ? void 0 : transform.assign)) {
    const is_primitive = path.at(-1) === "BindDirective" && path.at(-2) === "RegularElement";
    let value = (
      /** @type {Expression} */
      context.visit(build_assignment_value(operator, left, right))
    );
    return transform.assign(
      object4,
      value,
      !is_primitive && binding.kind !== "prop" && binding.kind !== "bindable_prop" && binding.kind !== "raw_state" && binding.kind !== "store_sub" && context.state.analysis.runes && should_proxy(right, context.state.scope) && is_non_coercive_operator(operator)
    );
  }
  if (transform == null ? void 0 : transform.mutate) {
    return transform.mutate(
      object4,
      assignment(
        operator,
        /** @type {Pattern} */
        context.visit(left),
        /** @type {Expression} */
        context.visit(right)
      )
    );
  }
  let should_transform = dev && path.at(-1) !== "ExpressionStatement" && is_non_coercive_operator(operator);
  if (path.at(-1) === "ArrowFunctionExpression" && (path.at(-2) === "RegularElement" || path.at(-2) === "SvelteElement")) {
    const element2 = (
      /** @type {AST.RegularElement} */
      context.path.at(-2)
    );
    const attribute = element2.attributes.find((attribute2) => {
      if (attribute2.type !== "Attribute" || !is_event_attribute(attribute2)) {
        return false;
      }
      const expression = get_attribute_expression(attribute2);
      return expression === context.path.at(-1);
    });
    if (attribute) {
      should_transform = false;
    }
  }
  if (path.at(-1) === "BindDirective" || path.at(-1) === "Component" || path.at(-1) === "SvelteComponent" || path.at(-1) === "ArrowFunctionExpression" && path.at(-2) === "SequenceExpression" && (path.at(-3) === "Component" || path.at(-3) === "SvelteComponent" || path.at(-3) === "BindDirective")) {
    should_transform = false;
  }
  if (left.type === "MemberExpression" && should_transform) {
    const callee = callees[operator];
    return (
      /** @type {Expression} */
      context.visit(
        call(
          callee,
          /** @type {Expression} */
          left.object,
          /** @type {Expression} */
          left.computed ? left.property : literal(
            /** @type {Identifier} */
            left.property.name
          ),
          right,
          literal(locate_node(left))
        )
      )
    );
  }
  return null;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/events.js
function visit_event_attribute(node, context) {
  let capture = false;
  let event_name = node.name.slice(2);
  if (is_capture_event(event_name)) {
    event_name = event_name.slice(0, -7);
    capture = true;
  }
  const tag2 = Array.isArray(node.value) ? (
    /** @type {AST.ExpressionTag} */
    node.value[0]
  ) : (
    /** @type {AST.ExpressionTag} */
    node.value
  );
  let handler = build_event_handler(tag2.expression, tag2.metadata.expression, context);
  if (node.metadata.delegated) {
    let delegated_assignment;
    if (!context.state.events.has(event_name)) {
      context.state.events.add(event_name);
    }
    if (node.metadata.delegated.hoisted) {
      if (node.metadata.delegated.function === tag2.expression) {
        const func_name = context.state.scope.root.unique("on_" + event_name);
        context.state.hoisted.push(var_builder(func_name, handler));
        handler = func_name;
      }
      const hoisted_params = (
        /** @type {Expression[]} */
        node.metadata.delegated.function.metadata.hoisted_params
      );
      if (hoisted_params) {
        const args = [handler, ...hoisted_params];
        delegated_assignment = array(args);
      } else {
        delegated_assignment = handler;
      }
    } else {
      delegated_assignment = handler;
    }
    context.state.init.push(
      stmt(
        assignment("=", member(context.state.node, "__" + event_name), delegated_assignment)
      )
    );
  } else {
    const statement = stmt(
      build_event(
        event_name,
        context.state.node,
        handler,
        capture,
        is_passive_event(event_name) ? true : void 0
      )
    );
    const type = (
      /** @type {AST.SvelteNode} */
      context.path.at(-1).type
    );
    if (type === "SvelteDocument" || type === "SvelteWindow" || type === "SvelteBody") {
      context.state.init.push(statement);
    } else {
      context.state.after_update.push(statement);
    }
  }
}
function build_event(event_name, node, handler, capture, passive) {
  return call(
    "$.event",
    literal(event_name),
    node,
    handler,
    capture && true_instance,
    passive === void 0 ? void 0 : literal(passive)
  );
}
function build_event_handler(node, metadata, context) {
  if (node === null) {
    return function_builder(
      null,
      [id("$$arg")],
      block([stmt(call("$.bubble_event.call", this_instance, id("$$props"), id("$$arg")))])
    );
  }
  let handler = (
    /** @type {Expression} */
    context.visit(node)
  );
  if (handler.type === "ArrowFunctionExpression" || handler.type === "FunctionExpression") {
    return handler;
  }
  if (handler.type === "Identifier") {
    const binding = context.state.scope.get(handler.name);
    if (binding == null ? void 0 : binding.is_function()) {
      return handler;
    }
    if (!dev && (binding == null ? void 0 : binding.declaration_kind) !== "import") {
      return handler;
    }
  }
  if (metadata.has_call) {
    const id2 = id(context.state.scope.generate("event_handler"));
    context.state.init.push(var_builder(id2, call("$.derived", thunk(handler))));
    handler = call("$.get", id2);
  }
  let call2 = call(member(handler, "apply", false, true), this_instance, id("$$args"));
  if (dev) {
    const loc = locator(
      /** @type {number} */
      node.start
    );
    const remove_parens = node.type === "CallExpression" && node.arguments.length === 0 && node.callee.type === "Identifier";
    call2 = call(
      "$.apply",
      thunk(handler),
      this_instance,
      id("$$args"),
      id(context.state.analysis.name),
      loc && array([literal(loc.line), literal(loc.column)]),
      has_side_effects(node) && true_instance,
      remove_parens && true_instance
    );
  }
  return function_builder(null, [rest(id("$$args"))], block([stmt(call2)]));
}
function has_side_effects(node) {
  if (node.type === "CallExpression" || node.type === "NewExpression" || node.type === "AssignmentExpression" || node.type === "UpdateExpression") {
    return true;
  }
  if (node.type === "SequenceExpression") {
    return node.expressions.some(has_side_effects);
  }
  return false;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Attribute.js
function Attribute2(node, context) {
  if (is_event_attribute(node)) {
    visit_event_attribute(node, context);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/declarations.js
function get_value(node) {
  return call("$.get", node);
}
function add_state_transformers(context) {
  for (const [name, binding] of context.state.scope.declarations) {
    if (is_state_source(binding, context.state.analysis) || binding.kind === "derived" || binding.kind === "legacy_reactive") {
      context.state.transform[name] = {
        read: binding.declaration_kind === "var" ? (node) => call("$.safe_get", node) : get_value,
        assign: (node, value, proxy = false) => {
          var _a2;
          let call2 = call("$.set", node, value, proxy && true_instance);
          if (((_a2 = context.state.scope.get(`$${node.name}`)) == null ? void 0 : _a2.kind) === "store_sub") {
            call2 = call("$.store_unsub", call2, literal(`$${node.name}`), id("$$stores"));
          }
          return call2;
        },
        mutate: (node, mutation) => {
          if (context.state.analysis.runes) {
            return mutation;
          }
          return call("$.mutate", node, mutation);
        },
        update: (node) => {
          return call(
            node.prefix ? "$.update_pre" : "$.update",
            node.argument,
            node.operator === "--" && literal(-1)
          );
        }
      };
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/AwaitBlock.js
function AwaitBlock3(node, context) {
  context.state.template.push("<!>");
  const expression = thunk(
    /** @type {Expression} */
    context.visit(node.expression)
  );
  let then_block;
  let catch_block;
  if (node.then) {
    const then_context = {
      ...context,
      state: { ...context.state, transform: { ...context.state.transform } }
    };
    const argument = node.value && create_derived_block_argument(node.value, then_context);
    const args = [id("$$anchor")];
    if (argument) args.push(argument.id);
    const declarations = (argument == null ? void 0 : argument.declarations) ?? [];
    const block2 = (
      /** @type {BlockStatement} */
      then_context.visit(node.then, then_context.state)
    );
    then_block = arrow(args, block([...declarations, ...block2.body]));
  }
  if (node.catch) {
    const catch_context = { ...context, state: { ...context.state } };
    const argument = node.error && create_derived_block_argument(node.error, catch_context);
    const args = [id("$$anchor")];
    if (argument) args.push(argument.id);
    const declarations = (argument == null ? void 0 : argument.declarations) ?? [];
    const block2 = (
      /** @type {BlockStatement} */
      catch_context.visit(node.catch, catch_context.state)
    );
    catch_block = arrow(args, block([...declarations, ...block2.body]));
  }
  context.state.init.push(
    stmt(
      call(
        "$.await",
        context.state.node,
        expression,
        node.pending ? arrow(
          [id("$$anchor")],
          /** @type {BlockStatement} */
          context.visit(node.pending)
        ) : null_instance,
        then_block,
        catch_block
      )
    )
  );
}
function create_derived_block_argument(node, context) {
  if (node.type === "Identifier") {
    context.state.transform[node.name] = { read: get_value };
    return { id: node, declarations: null };
  }
  const pattern = (
    /** @type {Pattern} */
    context.visit(node)
  );
  const identifiers = extract_identifiers(node);
  const id2 = id("$$source");
  const value = id("$$value");
  const block2 = block([
    var_builder(pattern, call("$.get", id2)),
    return_builder(object(identifiers.map((identifier) => prop("init", identifier, identifier))))
  ]);
  const declarations = [var_builder(value, create_derived(context.state, thunk(block2)))];
  for (const id3 of identifiers) {
    context.state.transform[id3.name] = { read: get_value };
    declarations.push(
      var_builder(id3, create_derived(context.state, thunk(member(call("$.get", value), id3))))
    );
  }
  return { id: id2, declarations };
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BinaryExpression.js
function BinaryExpression(node, context) {
  if (dev) {
    const operator = node.operator;
    if (operator === "===" || operator === "!==") {
      return call(
        "$.strict_equals",
        /** @type {Expression} */
        context.visit(node.left),
        /** @type {Expression} */
        context.visit(node.right),
        operator === "!==" && false_instance
      );
    }
    if (operator === "==" || operator === "!=") {
      return call(
        "$.equals",
        /** @type {Expression} */
        context.visit(node.left),
        /** @type {Expression} */
        context.visit(node.right),
        operator === "!=" && false_instance
      );
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/fragment.js
function process_children2(nodes, initial, is_element, { visit, state }) {
  const within_bound_contenteditable = state.metadata.bound_contenteditable;
  let prev = initial;
  let skipped = 0;
  let sequence2 = [];
  function get_node(is_text) {
    if (skipped === 0) {
      return prev(is_text);
    }
    return call(
      "$.sibling",
      prev(false),
      (is_text || skipped !== 1) && literal(skipped),
      is_text && true_instance
    );
  }
  function flush_node(is_text, name) {
    const expression = get_node(is_text);
    let id2 = expression;
    if (id2.type !== "Identifier") {
      id2 = id(state.scope.generate(name));
      state.init.push(var_builder(id2, expression));
    }
    prev = () => id2;
    skipped = 1;
    return id2;
  }
  function flush_sequence(sequence3) {
    if (sequence3.every((node) => node.type === "Text")) {
      skipped += 1;
      state.template.push(sequence3.map((node) => node.raw).join(""));
      return;
    }
    state.template.push(" ");
    const { has_state, value } = build_template_chunk(sequence3, visit, state);
    const is_text = sequence3.length === 1;
    const id2 = flush_node(is_text, "text");
    const update2 = stmt(call("$.set_text", id2, value));
    if (has_state && !within_bound_contenteditable) {
      state.update.push(update2);
    } else {
      state.init.push(stmt(assignment("=", member(id2, "nodeValue"), value)));
    }
  }
  for (const node of nodes) {
    if (node.type === "Text" || node.type === "ExpressionTag") {
      sequence2.push(node);
    } else {
      if (sequence2.length > 0) {
        flush_sequence(sequence2);
        sequence2 = [];
      }
      let child_state = state;
      if (is_static_element2(node, state)) {
        skipped += 1;
      } else if (node.type === "EachBlock" && nodes.length === 1 && is_element) {
        node.metadata.is_controlled = true;
      } else {
        const id2 = flush_node(false, node.type === "RegularElement" ? node.name : "node");
        child_state = { ...state, node: id2 };
      }
      visit(node, child_state);
    }
  }
  if (sequence2.length > 0) {
    flush_sequence(sequence2);
  }
  if (skipped > 1) {
    skipped -= 1;
    state.init.push(stmt(call("$.next", skipped !== 1 && literal(skipped))));
  }
}
function is_static_element2(node, state) {
  if (node.type !== "RegularElement") return false;
  if (node.fragment.metadata.dynamic) return false;
  if (is_custom_element_node(node)) return false;
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute") {
      return false;
    }
    if (is_event_attribute(attribute)) {
      return false;
    }
    if (cannot_be_set_statically(attribute.name)) {
      return false;
    }
    if (attribute.name === "dir") {
      return false;
    }
    if (["input", "textarea"].includes(node.name) && ["value", "checked"].includes(attribute.name)) {
      return false;
    }
    if (node.name === "option" && attribute.name === "value") {
      return false;
    }
    if (node.name === "img" && attribute.name === "loading") {
      return false;
    }
    if (attribute.value !== true && !is_text_attribute(attribute)) {
      return false;
    }
  }
  return true;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/RegularElement.js
function RegularElement3(node, context) {
  let location = [-1, -1];
  if (dev) {
    const loc = locator(node.start);
    if (loc) {
      location[0] = loc.line;
      location[1] = loc.column;
      context.state.locations.push(location);
    }
  }
  if (node.name === "noscript") {
    context.state.template.push("<noscript></noscript>");
    return;
  }
  const is_custom_element = is_custom_element_node(node);
  if (node.name === "video" || is_custom_element) {
    context.state.metadata.context.template_needs_import_node = true;
  }
  if (node.name === "script") {
    context.state.metadata.context.template_contains_script_tag = true;
  }
  context.state.template.push(`<${node.name}`);
  const attributes = [];
  const class_directives = [];
  const style_directives = [];
  const other_directives = [];
  const lets = [];
  const lookup = /* @__PURE__ */ new Map();
  const bindings = /* @__PURE__ */ new Map();
  let has_spread = node.metadata.has_spread;
  let has_use = false;
  for (const attribute of node.attributes) {
    switch (attribute.type) {
      case "AnimateDirective":
        other_directives.push(attribute);
        break;
      case "Attribute":
        if (attribute.name === "is" && context.state.metadata.namespace === "html") {
          const { value } = build_attribute_value2(attribute.value, context);
          if (value.type === "Literal" && typeof value.value === "string") {
            context.state.template.push(` is="${escape_html(value.value, true)}"`);
            continue;
          }
        }
        attributes.push(attribute);
        lookup.set(attribute.name, attribute);
        break;
      case "BindDirective":
        bindings.set(attribute.name, attribute);
        other_directives.push(attribute);
        break;
      case "ClassDirective":
        class_directives.push(attribute);
        break;
      case "LetDirective":
        lets.push(
          /** @type {ExpressionStatement} */
          context.visit(attribute)
        );
        break;
      case "OnDirective":
        other_directives.push(attribute);
        break;
      case "SpreadAttribute":
        attributes.push(attribute);
        break;
      case "StyleDirective":
        style_directives.push(attribute);
        break;
      case "TransitionDirective":
        other_directives.push(attribute);
        break;
      case "UseDirective":
        has_use = true;
        other_directives.push(attribute);
        break;
    }
  }
  const element_state = { ...context.state, init: [], after_update: [] };
  for (const attribute of other_directives) {
    if (attribute.type === "OnDirective") {
      const handler = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      if (has_use) {
        element_state.init.push(stmt(call("$.effect", thunk(handler))));
      } else {
        element_state.after_update.push(stmt(handler));
      }
    } else {
      context.visit(attribute, element_state);
    }
  }
  if (node.name === "input") {
    const has_value_attribute = attributes.some(
      (attribute) => attribute.type === "Attribute" && (attribute.name === "value" || attribute.name === "checked") && !is_text_attribute(attribute)
    );
    const has_default_value_attribute = attributes.some(
      (attribute) => attribute.type === "Attribute" && (attribute.name === "defaultValue" || attribute.name === "defaultChecked")
    );
    if (!has_default_value_attribute && (has_spread || bindings.has("value") || bindings.has("checked") || bindings.has("group") || !bindings.has("group") && has_value_attribute)) {
      context.state.init.push(stmt(call("$.remove_input_defaults", context.state.node)));
    }
  }
  if (node.name === "textarea") {
    const attribute = lookup.get("value") ?? lookup.get("checked");
    const needs_content_reset = attribute && !is_text_attribute(attribute);
    if (has_spread || bindings.has("value") || needs_content_reset) {
      context.state.init.push(stmt(call("$.remove_textarea_child", context.state.node)));
    }
  }
  if (node.name === "select" && bindings.has("value")) {
    setup_select_synchronization(
      /** @type {AST.BindDirective} */
      bindings.get("value"),
      context
    );
  }
  context.state.init.push(...lets);
  const node_id = context.state.node;
  if (has_spread) {
    const attributes_id = id(context.state.scope.generate("attributes"));
    build_set_attributes(
      attributes,
      class_directives,
      style_directives,
      context,
      node,
      node_id,
      attributes_id
    );
    if (node.name === "select" && !bindings.has("value")) {
      context.state.init.push(
        stmt(call("$.init_select", node_id, thunk(member(attributes_id, "value"))))
      );
      context.state.update.push(
        if_builder(
          binary("in", literal("value"), attributes_id),
          block([
            // This ensures a one-way street to the DOM in case it's <select {value}>
            // and not <select bind:value>. We need it in addition to $.init_select
            // because the select value is not reflected as an attribute, so the
            // mutation observer wouldn't notice.
            stmt(call("$.select_option", node_id, member(attributes_id, "value")))
          ])
        )
      );
    }
  } else {
    const needs_special_value_handling = node.name === "option" || node.name === "select" || bindings.has("group") || bindings.has("checked");
    for (
      const attribute of
      /** @type {AST.Attribute[]} */
      attributes
    ) {
      if (is_event_attribute(attribute)) {
        visit_event_attribute(attribute, context);
        continue;
      }
      if (needs_special_value_handling && attribute.name === "value") {
        build_element_special_value_attribute(node.name, node_id, attribute, context);
        continue;
      }
      const name = get_attribute_name2(node, attribute);
      if (!is_custom_element && !cannot_be_set_statically(attribute.name) && (attribute.value === true || is_text_attribute(attribute)) && (name !== "class" || class_directives.length === 0) && (name !== "style" || style_directives.length === 0)) {
        let value = is_text_attribute(attribute) ? attribute.value[0].data : true;
        if (name === "class" && node.metadata.scoped && context.state.analysis.css.hash) {
          if (value === true || value === "") {
            value = context.state.analysis.css.hash;
          } else {
            value += " " + context.state.analysis.css.hash;
          }
        }
        if (name !== "class" || value) {
          context.state.template.push(
            ` ${attribute.name}${is_boolean_attribute(name) && value === true ? "" : `="${value === true ? "" : escape_html(value, true)}"`}`
          );
        }
      } else if (name === "autofocus") {
        let { value } = build_attribute_value2(attribute.value, context);
        context.state.init.push(stmt(call("$.autofocus", node_id, value)));
      } else if (name === "class") {
        const is_html = context.state.metadata.namespace === "html" && node.name !== "svg";
        build_set_class(node, node_id, attribute, class_directives, context, is_html);
      } else if (name === "style") {
        build_set_style(node_id, attribute, style_directives, context);
      } else if (is_custom_element) {
        build_custom_element_attribute_update_assignment(node_id, attribute, context);
      } else {
        const { value, has_state } = build_attribute_value2(
          attribute.value,
          context,
          (value2, metadata2) => metadata2.has_call ? get_expression_id(context.state, value2) : value2
        );
        const update2 = build_element_attribute_update(node, node_id, name, value, attributes);
        (has_state ? context.state.update : context.state.init).push(stmt(update2));
      }
    }
  }
  if (is_load_error_element(node.name) && (has_spread || has_use || lookup.has("onload") || lookup.has("onerror"))) {
    context.state.after_update.push(stmt(call("$.replay_events", node_id)));
  }
  context.state.template.push(">");
  const metadata = {
    ...context.state.metadata,
    namespace: determine_namespace_for_children(node, context.state.metadata.namespace)
  };
  if (bindings.has("innerHTML") || bindings.has("innerText") || bindings.has("textContent")) {
    const contenteditable = lookup.get("contenteditable");
    if (contenteditable && (contenteditable.value === true || is_text_attribute(contenteditable) && contenteditable.value[0].data === "true")) {
      metadata.bound_contenteditable = true;
    }
  }
  const state = {
    ...context.state,
    metadata,
    locations: [],
    scope: (
      /** @type {Scope} */
      context.state.scopes.get(node.fragment)
    ),
    preserve_whitespace: context.state.preserve_whitespace || node.name === "pre" || node.name === "textarea"
  };
  const { hoisted, trimmed } = clean_nodes(
    node,
    node.fragment.nodes,
    context.path,
    state.metadata.namespace,
    state,
    node.name === "script" || state.preserve_whitespace,
    state.options.preserveComments
  );
  const child_state = { ...state, init: [], update: [], after_update: [] };
  for (const node2 of hoisted) {
    context.visit(node2, child_state);
  }
  const use_text_content = trimmed.every((node2) => node2.type === "Text" || node2.type === "ExpressionTag") && trimmed.every((node2) => node2.type === "Text" || !node2.metadata.expression.has_state) && trimmed.some((node2) => node2.type === "ExpressionTag");
  if (use_text_content) {
    const { value } = build_template_chunk(trimmed, context.visit, child_state);
    const empty_string = value.type === "Literal" && value.value === "";
    if (!empty_string) {
      child_state.init.push(
        stmt(assignment("=", member(context.state.node, "textContent"), value))
      );
    }
  } else {
    let arg = context.state.node;
    let needs_reset = trimmed.some((node2) => node2.type !== "Text");
    if (node.name === "template") {
      needs_reset = true;
      child_state.init.push(stmt(call("$.hydrate_template", arg)));
      arg = member(arg, "content");
    }
    process_children2(trimmed, (is_text) => call("$.child", arg, is_text && true_instance), true, {
      ...context,
      state: child_state
    });
    if (needs_reset) {
      child_state.init.push(stmt(call("$.reset", context.state.node)));
    }
  }
  if (node.fragment.nodes.some((node2) => node2.type === "SnippetBlock")) {
    context.state.init.push(
      block([
        ...child_state.init,
        ...element_state.init,
        child_state.update.length > 0 ? build_render_statement(child_state) : empty,
        ...child_state.after_update,
        ...element_state.after_update
      ])
    );
  } else if (node.fragment.metadata.dynamic) {
    context.state.init.push(...child_state.init, ...element_state.init);
    context.state.update.push(...child_state.update);
    context.state.after_update.push(...child_state.after_update, ...element_state.after_update);
  } else {
    context.state.init.push(...element_state.init);
    context.state.after_update.push(...element_state.after_update);
  }
  if (lookup.has("dir")) {
    const dir = member(node_id, "dir");
    context.state.update.push(stmt(assignment("=", dir, dir)));
  }
  if (state.locations.length > 0) {
    location.push(state.locations);
  }
  if (!is_void(node.name)) {
    context.state.template.push(`</${node.name}>`);
  }
}
function setup_select_synchronization(value_binding, context) {
  if (context.state.analysis.runes) return;
  let bound = value_binding.expression;
  if (bound.type === "SequenceExpression") {
    return;
  }
  while (bound.type === "MemberExpression") {
    bound = /** @type {Identifier | MemberExpression} */
    bound.object;
  }
  const names = [];
  for (const [name, refs] of context.state.scope.references) {
    if (refs.length > 0 && // prevent infinite loop
    name !== bound.name) {
      names.push(name);
    }
  }
  const invalidator = call(
    "$.invalidate_inner_signals",
    thunk(
      block(
        names.map((name) => {
          const serialized = build_getter(id(name), context.state);
          return stmt(serialized);
        })
      )
    )
  );
  context.state.init.push(
    stmt(
      call(
        "$.template_effect",
        thunk(
          block([stmt(
            /** @type {Expression} */
            context.visit(bound)
          ), stmt(invalidator)])
        )
      )
    )
  );
}
function build_class_directives_object(class_directives, context) {
  let properties = [];
  let has_call_or_state = false;
  for (const d of class_directives) {
    const expression = (
      /** @type Expression */
      context.visit(d.expression)
    );
    properties.push(init(d.name, expression));
    has_call_or_state || (has_call_or_state = d.metadata.expression.has_call || d.metadata.expression.has_state);
  }
  const directives = object(properties);
  return has_call_or_state ? get_expression_id(context.state, directives) : directives;
}
function build_style_directives_object(style_directives, context) {
  let normal_properties = [];
  let important_properties = [];
  for (const directive of style_directives) {
    const expression = directive.value === true ? build_getter({ name: directive.name, type: "Identifier" }, context.state) : build_attribute_value2(
      directive.value,
      context,
      (value, metadata) => metadata.has_call ? get_expression_id(context.state, value) : value
    ).value;
    const property = init(directive.name, expression);
    if (directive.modifiers.includes("important")) {
      important_properties.push(property);
    } else {
      normal_properties.push(property);
    }
  }
  return important_properties.length ? array([object(normal_properties), object(important_properties)]) : object(normal_properties);
}
function build_element_attribute_update(element2, node_id, name, value, attributes) {
  if (name === "muted") {
    return assignment("=", member(node_id, id("muted")), value);
  }
  if (name === "value") {
    return call("$.set_value", node_id, value);
  }
  if (name === "checked") {
    return call("$.set_checked", node_id, value);
  }
  if (name === "selected") {
    return call("$.set_selected", node_id, value);
  }
  if (
    // If we would just set the defaultValue property, it would override the value property,
    // because it is set in the template which implicitly means it's also setting the default value,
    // and if one updates the default value while the input is pristine it will also update the
    // current value, which is not what we want, which is why we need to do some extra work.
    name === "defaultValue" && (attributes.some(
      (attr) => attr.type === "Attribute" && attr.name === "value" && is_text_attribute(attr)
    ) || element2.name === "textarea" && element2.fragment.nodes.length > 0)
  ) {
    return call("$.set_default_value", node_id, value);
  }
  if (
    // See defaultValue comment
    name === "defaultChecked" && attributes.some(
      (attr) => attr.type === "Attribute" && attr.name === "checked" && attr.value === true
    )
  ) {
    return call("$.set_default_checked", node_id, value);
  }
  if (is_dom_property(name)) {
    return assignment("=", member(node_id, name), value);
  }
  return call(
    name.startsWith("xlink") ? "$.set_xlink_attribute" : "$.set_attribute",
    node_id,
    literal(name),
    value,
    is_ignored(element2, "hydration_attribute_changed") && true_instance
  );
}
function build_custom_element_attribute_update_assignment(node_id, attribute, context) {
  const { value, has_state } = build_attribute_value2(attribute.value, context);
  const call2 = call("$.set_custom_element_data", node_id, literal(attribute.name), value);
  const update2 = has_state ? call("$.template_effect", thunk(call2)) : call2;
  context.state.init.push(stmt(update2));
}
function build_element_special_value_attribute(element2, node_id, attribute, context) {
  const state = context.state;
  const is_select_with_value = (
    // attribute.metadata.dynamic would give false negatives because even if the value does not change,
    // the inner options could still change, so we need to always treat it as reactive
    element2 === "select" && attribute.value !== true && !is_text_attribute(attribute)
  );
  const { value, has_state } = build_attribute_value2(
    attribute.value,
    context,
    (value2, metadata) => metadata.has_call ? (
      // if is a select with value we will also invoke `init_select` which need a reference before the template effect so we memoize separately
      is_select_with_value ? memoize_expression(state, value2) : get_expression_id(state, value2)
    ) : value2
  );
  const evaluated = context.state.scope.evaluate(value);
  const assignment2 = assignment("=", member(node_id, "__value"), value);
  const inner_assignment = assignment(
    "=",
    member(node_id, "value"),
    evaluated.is_defined ? assignment2 : logical("??", assignment2, literal(""))
  );
  const update2 = stmt(
    is_select_with_value ? sequence([
      inner_assignment,
      // This ensures a one-way street to the DOM in case it's <select {value}>
      // and not <select bind:value>. We need it in addition to $.init_select
      // because the select value is not reflected as an attribute, so the
      // mutation observer wouldn't notice.
      call("$.select_option", node_id, value)
    ]) : inner_assignment
  );
  if (is_select_with_value) {
    state.init.push(stmt(call("$.init_select", node_id, thunk(value))));
  }
  if (has_state) {
    const id2 = state.scope.generate(`${node_id.name}_value`);
    build_update_assignment(
      state,
      id2,
      // `<option>` is a special case: The value property reflects to the DOM. If the value is set to undefined,
      // that means the value should be set to the empty string. To be able to do that when the value is
      // initially undefined, we need to set a value that is guaranteed to be different.
      element2 === "option" ? object([]) : void 0,
      value,
      update2
    );
  } else {
    state.init.push(update2);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/element.js
function build_set_attributes(attributes, class_directives, style_directives, context, element2, element_id, attributes_id) {
  let is_dynamic = false;
  const values = [];
  for (const attribute of attributes) {
    if (attribute.type === "Attribute") {
      const { value, has_state } = build_attribute_value2(
        attribute.value,
        context,
        (value2, metadata) => metadata.has_call ? get_expression_id(context.state, value2) : value2
      );
      if (is_event_attribute(attribute) && (value.type === "ArrowFunctionExpression" || value.type === "FunctionExpression")) {
        const id2 = context.state.scope.generate("event_handler");
        context.state.init.push(var_builder(id2, value));
        values.push(init(attribute.name, id(id2)));
      } else {
        values.push(init(attribute.name, value));
      }
      is_dynamic || (is_dynamic = has_state);
    } else {
      is_dynamic = true;
      let value = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      if (attribute.metadata.expression.has_call) {
        value = get_expression_id(context.state, value);
      }
      values.push(spread(value));
    }
  }
  if (class_directives.length) {
    values.push(
      prop(
        "init",
        array([id("$.CLASS")]),
        build_class_directives_object(class_directives, context)
      )
    );
    is_dynamic || (is_dynamic = class_directives.find((directive) => directive.metadata.expression.has_state) !== null);
  }
  if (style_directives.length) {
    values.push(
      prop(
        "init",
        array([id("$.STYLE")]),
        build_style_directives_object(style_directives, context)
      )
    );
    is_dynamic || (is_dynamic = style_directives.some((directive) => directive.metadata.expression.has_state));
  }
  const call2 = call(
    "$.set_attributes",
    element_id,
    is_dynamic ? attributes_id : null_instance,
    object(values),
    element2.metadata.scoped && context.state.analysis.css.hash !== "" && literal(context.state.analysis.css.hash),
    is_ignored(element2, "hydration_attribute_changed") && true_instance
  );
  if (is_dynamic) {
    context.state.init.push(let_builder(attributes_id));
    const update2 = stmt(assignment("=", attributes_id, call2));
    context.state.update.push(update2);
  } else {
    context.state.init.push(stmt(call2));
  }
}
function build_attribute_value2(value, context, memoize = (value2) => value2) {
  if (value === true) {
    return { value: true_instance, has_state: false };
  }
  if (!Array.isArray(value) || value.length === 1) {
    const chunk = Array.isArray(value) ? value[0] : value;
    if (chunk.type === "Text") {
      return { value: literal(chunk.data), has_state: false };
    }
    let expression = (
      /** @type {Expression} */
      context.visit(chunk.expression)
    );
    return {
      value: memoize(expression, chunk.metadata.expression),
      has_state: chunk.metadata.expression.has_state
    };
  }
  return build_template_chunk(value, context.visit, context.state, memoize);
}
function get_attribute_name2(element2, attribute) {
  if (!element2.metadata.svg && !element2.metadata.mathml) {
    return normalize_attribute(attribute.name);
  }
  return attribute.name;
}
function build_set_class(element2, node_id, attribute, class_directives, context, is_html) {
  let { value, has_state } = build_attribute_value2(attribute.value, context, (value2, metadata) => {
    if (attribute.metadata.needs_clsx) {
      value2 = call("$.clsx", value2);
    }
    return metadata.has_call ? get_expression_id(context.state, value2) : value2;
  });
  let previous_id;
  let prev;
  let next2;
  if (class_directives.length) {
    next2 = build_class_directives_object(class_directives, context);
    has_state || (has_state = class_directives.some((d) => d.metadata.expression.has_state));
    if (has_state) {
      previous_id = id(context.state.scope.generate("classes"));
      context.state.init.push(declaration("let", [declarator(previous_id)]));
      prev = previous_id;
    } else {
      prev = object([]);
    }
  }
  let css_hash;
  if (element2.metadata.scoped && context.state.analysis.css.hash) {
    if (value.type === "Literal" && (value.value === "" || value.value === null)) {
      value = literal(context.state.analysis.css.hash);
    } else if (value.type === "Literal" && typeof value.value === "string") {
      value = literal(escape_html(value.value, true) + " " + context.state.analysis.css.hash);
    } else {
      css_hash = literal(context.state.analysis.css.hash);
    }
  }
  if (!css_hash && next2) {
    css_hash = null_instance;
  }
  let set_class = call(
    "$.set_class",
    node_id,
    is_html ? literal(1) : literal(0),
    value,
    css_hash,
    prev,
    next2
  );
  if (previous_id) {
    set_class = assignment("=", previous_id, set_class);
  }
  (has_state ? context.state.update : context.state.init).push(stmt(set_class));
}
function build_set_style(node_id, attribute, style_directives, context) {
  let { value, has_state } = build_attribute_value2(
    attribute.value,
    context,
    (value2, metadata) => metadata.has_call ? get_expression_id(context.state, value2) : value2
  );
  let previous_id;
  let prev;
  let next2;
  if (style_directives.length) {
    next2 = build_style_directives_object(style_directives, context);
    has_state || (has_state = style_directives.some((d) => d.metadata.expression.has_state));
    if (has_state) {
      previous_id = id(context.state.scope.generate("styles"));
      context.state.init.push(declaration("let", [declarator(previous_id)]));
      prev = previous_id;
    } else {
      prev = object([]);
    }
  }
  let set_style = call("$.set_style", node_id, value, prev, next2);
  if (previous_id) {
    set_style = assignment("=", previous_id, set_style);
  }
  (has_state ? context.state.update : context.state.init).push(stmt(set_style));
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BindDirective.js
function BindDirective2(node, context) {
  var _a2;
  const expression = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const property = binding_properties[node.name];
  const parent = (
    /** @type {AST.SvelteNode} */
    context.path.at(-1)
  );
  let get2, set2;
  if (expression.type === "SequenceExpression") {
    [get2, set2] = expression.expressions;
  } else {
    if (dev && context.state.analysis.runes && expression.type === "MemberExpression" && (node.name !== "this" || context.path.some(
      ({ type }) => type === "IfBlock" || type === "EachBlock" || type === "AwaitBlock" || type === "KeyBlock"
    )) && !is_ignored(node, "binding_property_non_reactive")) {
      validate_binding(context.state, node, expression);
    }
    get2 = thunk(expression);
    set2 = unthunk(
      arrow(
        [id("$$value")],
        /** @type {Expression} */
        context.visit(
          assignment(
            "=",
            /** @type {Pattern} */
            node.expression,
            id("$$value")
          )
        )
      )
    );
    if (get2 === set2) {
      set2 = void 0;
    }
  }
  let call2;
  if (property == null ? void 0 : property.event) {
    call2 = call(
      "$.bind_property",
      literal(node.name),
      literal(property.event),
      context.state.node,
      set2 ?? get2,
      property.bidirectional && get2
    );
  } else {
    switch (node.name) {
      // window
      case "online":
        call2 = call(`$.bind_online`, set2 ?? get2);
        break;
      case "scrollX":
      case "scrollY":
        call2 = call(
          "$.bind_window_scroll",
          literal(node.name === "scrollX" ? "x" : "y"),
          get2,
          set2
        );
        break;
      case "innerWidth":
      case "innerHeight":
      case "outerWidth":
      case "outerHeight":
        call2 = call("$.bind_window_size", literal(node.name), set2 ?? get2);
        break;
      // document
      case "activeElement":
        call2 = call("$.bind_active_element", set2 ?? get2);
        break;
      // media
      case "muted":
        call2 = call(`$.bind_muted`, context.state.node, get2, set2);
        break;
      case "paused":
        call2 = call(`$.bind_paused`, context.state.node, get2, set2);
        break;
      case "volume":
        call2 = call(`$.bind_volume`, context.state.node, get2, set2);
        break;
      case "playbackRate":
        call2 = call(`$.bind_playback_rate`, context.state.node, get2, set2);
        break;
      case "currentTime":
        call2 = call(`$.bind_current_time`, context.state.node, get2, set2);
        break;
      case "buffered":
        call2 = call(`$.bind_buffered`, context.state.node, set2 ?? get2);
        break;
      case "played":
        call2 = call(`$.bind_played`, context.state.node, set2 ?? get2);
        break;
      case "seekable":
        call2 = call(`$.bind_seekable`, context.state.node, set2 ?? get2);
        break;
      case "seeking":
        call2 = call(`$.bind_seeking`, context.state.node, set2 ?? get2);
        break;
      case "ended":
        call2 = call(`$.bind_ended`, context.state.node, set2 ?? get2);
        break;
      case "readyState":
        call2 = call(`$.bind_ready_state`, context.state.node, set2 ?? get2);
        break;
      // dimensions
      case "contentRect":
      case "contentBoxSize":
      case "borderBoxSize":
      case "devicePixelContentBoxSize":
        call2 = call(
          "$.bind_resize_observer",
          context.state.node,
          literal(node.name),
          set2 ?? get2
        );
        break;
      case "clientWidth":
      case "clientHeight":
      case "offsetWidth":
      case "offsetHeight":
        call2 = call("$.bind_element_size", context.state.node, literal(node.name), set2 ?? get2);
        break;
      // various
      case "value": {
        if ((parent == null ? void 0 : parent.type) === "RegularElement" && parent.name === "select") {
          call2 = call(`$.bind_select_value`, context.state.node, get2, set2);
        } else {
          call2 = call(`$.bind_value`, context.state.node, get2, set2);
        }
        break;
      }
      case "files":
        call2 = call(`$.bind_files`, context.state.node, get2, set2);
        break;
      case "this":
        call2 = build_bind_this(node.expression, context.state.node, context);
        break;
      case "textContent":
      case "innerHTML":
      case "innerText":
        call2 = call(
          "$.bind_content_editable",
          literal(node.name),
          context.state.node,
          get2,
          set2
        );
        break;
      // checkbox/radio
      case "checked":
        call2 = call(`$.bind_checked`, context.state.node, get2, set2);
        break;
      case "focused":
        call2 = call(`$.bind_focused`, context.state.node, set2 ?? get2);
        break;
      case "group": {
        const indexes = node.metadata.parent_each_blocks.map((each) => {
          return each.metadata.keyed && each.index ? call("$.get", each.metadata.index) : each.metadata.index;
        });
        let group_getter = get2;
        if ((parent == null ? void 0 : parent.type) === "RegularElement") {
          const value = (
            /** @type {any[]} */
            /** @type {AST.Attribute} */
            (_a2 = parent.attributes.find(
              (a) => a.type === "Attribute" && a.name === "value" && !is_text_attribute(a) && a.value !== true
            )) == null ? void 0 : _a2.value
          );
          if (value !== void 0) {
            group_getter = thunk(
              block([stmt(build_attribute_value2(value, context).value), return_builder(expression)])
            );
          }
        }
        call2 = call(
          "$.bind_group",
          node.metadata.binding_group_name,
          array(indexes),
          context.state.node,
          group_getter,
          set2 ?? get2
        );
        break;
      }
      default:
        throw new Error("unknown binding " + node.name);
    }
  }
  if (node.name === "this") {
    context.state.init.push(stmt(call2));
  } else {
    const has_use = parent.type === "RegularElement" && parent.attributes.find((a) => a.type === "UseDirective");
    if (has_use) {
      context.state.init.push(stmt(call("$.effect", thunk(call2))));
    } else {
      context.state.after_update.push(stmt(call2));
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BlockStatement.js
function BlockStatement(node, context) {
  add_state_transformers(context);
  const tracing = context.state.scope.tracing;
  if (tracing !== null) {
    const parent = (
      /** @type {ArrowFunctionExpression | FunctionDeclaration | FunctionExpression} */
      context.path.at(-1)
    );
    const is_async = parent.async;
    const call2 = call(
      "$.trace",
      /** @type {Expression} */
      tracing,
      thunk(block(node.body.map((n) => (
        /** @type {Statement} */
        context.visit(n)
      ))), is_async)
    );
    return block([return_builder(is_async ? await_builder(call2) : call2)]);
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/BreakStatement.js
function BreakStatement(node, context) {
  if (context.state.analysis.runes || !node.label || node.label.name !== "$") {
    return;
  }
  const in_reactive_statement = context.path[1].type === "LabeledStatement" && context.path[1].label.name === "$";
  if (in_reactive_statement) {
    return return_builder();
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/CallExpression.js
function CallExpression3(node, context) {
  switch (get_rune(node, context.state.scope)) {
    case "$host":
      return id("$$props.$$host");
    case "$effect.tracking":
      return call("$.effect_tracking");
    case "$state.snapshot":
      return call(
        "$.snapshot",
        /** @type {Expression} */
        context.visit(node.arguments[0]),
        is_ignored(node, "state_snapshot_uncloneable") && true_instance
      );
    case "$effect.root":
      return call(
        "$.effect_root",
        .../** @type {Expression[]} */
        node.arguments.map((arg) => context.visit(arg))
      );
    case "$inspect":
    case "$inspect().with":
      return transform_inspect_rune(node, context);
  }
  if (dev && node.callee.type === "MemberExpression" && node.callee.object.type === "Identifier" && node.callee.object.name === "console" && context.state.scope.get("console") === null && node.callee.property.type === "Identifier" && ["debug", "dir", "error", "group", "groupCollapsed", "info", "log", "trace", "warn"].includes(
    node.callee.property.name
  ) && node.arguments.some((arg) => arg.type !== "Literal")) {
    return call(
      node.callee,
      spread(
        call(
          "$.log_if_contains_state",
          literal(node.callee.property.name),
          .../** @type {Expression[]} */
          node.arguments.map((arg) => context.visit(arg))
        )
      )
    );
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ClassBody.js
function ClassBody3(node, context) {
  var _a2, _b;
  if (!context.state.analysis.runes) {
    context.next();
    return;
  }
  const public_state = /* @__PURE__ */ new Map();
  const private_state = /* @__PURE__ */ new Map();
  const definition_names = /* @__PURE__ */ new Map();
  const private_ids = [];
  for (const definition of node.body) {
    if ((definition.type === "PropertyDefinition" || definition.type === "MethodDefinition") && (definition.key.type === "Identifier" || definition.key.type === "PrivateIdentifier" || definition.key.type === "Literal")) {
      const type = definition.key.type;
      const name = get_name(definition.key, public_state);
      if (!name) continue;
      definition_names.set(definition.key, name);
      const is_private = type === "PrivateIdentifier";
      if (is_private) private_ids.push(name);
      if (((_a2 = definition.value) == null ? void 0 : _a2.type) === "CallExpression") {
        const rune = get_rune(definition.value, context.state.scope);
        if (rune === "$state" || rune === "$state.raw" || rune === "$derived" || rune === "$derived.by") {
          const field = {
            kind: rune === "$state" ? "state" : rune === "$state.raw" ? "raw_state" : rune === "$derived.by" ? "derived_by" : "derived",
            // @ts-expect-error this is set in the next pass
            id: is_private ? definition.key : null
          };
          if (is_private) {
            private_state.set(name, field);
          } else {
            public_state.set(name, field);
          }
        }
      }
    }
  }
  for (const [name, field] of public_state) {
    let deconflicted = name;
    while (private_ids.includes(deconflicted)) {
      deconflicted = "_" + deconflicted;
    }
    private_ids.push(deconflicted);
    field.id = private_id(deconflicted);
  }
  const body = [];
  const child_state = { ...context.state, public_state, private_state };
  for (const definition of node.body) {
    if (definition.type === "PropertyDefinition" && (definition.key.type === "Identifier" || definition.key.type === "PrivateIdentifier" || definition.key.type === "Literal")) {
      const name = definition_names.get(definition.key);
      if (!name) continue;
      const is_private = definition.key.type === "PrivateIdentifier";
      const field = (is_private ? private_state : public_state).get(name);
      if (((_b = definition.value) == null ? void 0 : _b.type) === "CallExpression" && field !== void 0) {
        let value = null;
        if (definition.value.arguments.length > 0) {
          const init2 = (
            /** @type {Expression} **/
            context.visit(definition.value.arguments[0], child_state)
          );
          value = field.kind === "state" ? call(
            "$.state",
            should_proxy(init2, context.state.scope) ? call("$.proxy", init2) : init2
          ) : field.kind === "raw_state" ? call("$.state", init2) : field.kind === "derived_by" ? call("$.derived", init2) : call("$.derived", thunk(init2));
        } else {
          value = call("$.state");
        }
        if (is_private) {
          body.push(prop_def(field.id, value));
        } else {
          const member2 = member(this_instance, field.id);
          body.push(prop_def(field.id, value));
          body.push(method("get", definition.key, [], [return_builder(call("$.get", member2))]));
          const val = id("value");
          body.push(
            method(
              "set",
              definition.key,
              [val],
              [stmt(call("$.set", member2, val, field.kind === "state" && true_instance))]
            )
          );
        }
        continue;
      }
    }
    body.push(
      /** @type {MethodDefinition} **/
      context.visit(definition, child_state)
    );
  }
  return { ...node, body };
}
function get_name(node, public_state) {
  var _a2;
  if (node.type === "Literal") {
    let name = (_a2 = node.value) == null ? void 0 : _a2.toString().replace(regex_invalid_identifier_chars, "_");
    while (name && public_state.has(name)) {
      name = "_" + name;
    }
    return name;
  } else {
    return node.name;
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Comment.js
function Comment(node, context) {
  context.state.template.push(`<!--${node.data}-->`);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/component.js
function build_component(node, component_name, context, anchor = context.state.node) {
  var _a2, _b;
  const props_and_spreads = [];
  const delayed_props = [];
  const lets = [];
  const states = {
    default: {
      ...context.state,
      scope: node.metadata.scopes.default,
      transform: { ...context.state.transform }
    }
  };
  const children = {};
  const events = {};
  const custom_css_props = [];
  let bind_this = null;
  const binding_initializers = [];
  let slot_scope_applies_to_itself = !!determine_slot(node);
  let has_children_prop = false;
  function push_prop(prop2, delay = false) {
    const do_push = () => {
      const current = props_and_spreads.at(-1);
      const current_is_props = Array.isArray(current);
      const props = current_is_props ? current : [];
      props.push(prop2);
      if (!current_is_props) {
        props_and_spreads.push(props);
      }
    };
    if (delay) {
      delayed_props.push(do_push);
    } else {
      do_push();
    }
  }
  if (slot_scope_applies_to_itself) {
    for (const attribute of node.attributes) {
      if (attribute.type === "LetDirective") {
        lets.push(
          /** @type {ExpressionStatement} */
          context.visit(attribute)
        );
      }
    }
  }
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      if (!slot_scope_applies_to_itself) {
        lets.push(
          /** @type {ExpressionStatement} */
          context.visit(attribute, states.default)
        );
      }
    } else if (attribute.type === "OnDirective") {
      if (!attribute.expression) {
        context.state.analysis.needs_props = true;
      }
      let handler = build_event_handler(
        attribute.expression,
        attribute.metadata.expression,
        context
      );
      if (attribute.modifiers.includes("once")) {
        handler = call("$.once", handler);
      }
      (events[_a2 = attribute.name] || (events[_a2] = [])).push(handler);
    } else if (attribute.type === "SpreadAttribute") {
      const expression = (
        /** @type {Expression} */
        context.visit(attribute)
      );
      if (attribute.metadata.expression.has_state) {
        let value = expression;
        if (attribute.metadata.expression.has_call) {
          const id2 = id(context.state.scope.generate("spread_element"));
          context.state.init.push(var_builder(id2, call("$.derived", thunk(value))));
          value = call("$.get", id2);
        }
        props_and_spreads.push(thunk(value));
      } else {
        props_and_spreads.push(expression);
      }
    } else if (attribute.type === "Attribute") {
      if (attribute.name.startsWith("--")) {
        custom_css_props.push(
          init(
            attribute.name,
            build_attribute_value2(
              attribute.value,
              context,
              (value2, metadata) => (
                // TODO put the derived in the local block
                metadata.has_call ? memoize_expression(context.state, value2) : value2
              )
            ).value
          )
        );
        continue;
      }
      if (attribute.name === "slot") {
        slot_scope_applies_to_itself = true;
      }
      if (attribute.name === "children") {
        has_children_prop = true;
      }
      const { value, has_state } = build_attribute_value2(
        attribute.value,
        context,
        (value2, metadata) => {
          if (!metadata.has_state) return value2;
          const should_wrap_in_derived = get_attribute_chunks(attribute.value).some((n) => {
            return n.type === "ExpressionTag" && n.expression.type !== "Identifier" && n.expression.type !== "MemberExpression";
          });
          return should_wrap_in_derived ? memoize_expression(context.state, value2) : value2;
        }
      );
      if (has_state) {
        push_prop(get(attribute.name, [return_builder(value)]));
      } else {
        push_prop(init(attribute.name, value));
      }
    } else if (attribute.type === "BindDirective") {
      const expression = (
        /** @type {Expression} */
        context.visit(attribute.expression)
      );
      if (dev && attribute.name !== "this" && !is_ignored(node, "ownership_invalid_binding") && // bind:x={() => x.y, y => x.y = y} will be handled by the assignment expression binding validation
      attribute.expression.type !== "SequenceExpression") {
        const left = object2(attribute.expression);
        const binding = left && context.state.scope.get(left.name);
        if ((binding == null ? void 0 : binding.kind) === "bindable_prop" || (binding == null ? void 0 : binding.kind) === "prop") {
          context.state.analysis.needs_mutation_validation = true;
          binding_initializers.push(
            stmt(
              call(
                "$$ownership_validator.binding",
                literal(binding.node.name),
                id(component_name),
                thunk(expression)
              )
            )
          );
        }
      }
      if (expression.type === "SequenceExpression") {
        if (attribute.name === "this") {
          bind_this = attribute.expression;
        } else {
          const [get2, set2] = expression.expressions;
          const get_id = id(context.state.scope.generate("bind_get"));
          const set_id = id(context.state.scope.generate("bind_set"));
          context.state.init.push(var_builder(get_id, get2));
          context.state.init.push(var_builder(set_id, set2));
          push_prop(get(attribute.name, [return_builder(call(get_id))]));
          push_prop(set(attribute.name, [stmt(call(set_id, id("$$value")))]));
        }
      } else {
        if (dev && expression.type === "MemberExpression" && context.state.analysis.runes && !is_ignored(node, "binding_property_non_reactive")) {
          validate_binding(context.state, attribute, expression);
        }
        if (attribute.name === "this") {
          bind_this = attribute.expression;
        } else {
          const is_store_sub = attribute.expression.type === "Identifier" && ((_b = context.state.scope.get(attribute.expression.name)) == null ? void 0 : _b.kind) === "store_sub";
          if (is_store_sub) {
            push_prop(
              get(attribute.name, [stmt(call("$.mark_store_binding")), return_builder(expression)]),
              true
            );
          } else {
            push_prop(get(attribute.name, [return_builder(expression)]), true);
          }
          const assignment2 = assignment(
            "=",
            /** @type {Pattern} */
            attribute.expression,
            id("$$value")
          );
          push_prop(
            set(attribute.name, [stmt(
              /** @type {Expression} */
              context.visit(assignment2)
            )]),
            true
          );
        }
      }
    }
  }
  delayed_props.forEach((fn2) => fn2());
  if (slot_scope_applies_to_itself) {
    context.state.init.push(...lets);
  }
  if (Object.keys(events).length > 0) {
    const events_expression = object(
      Object.keys(events).map(
        (name) => init(name, events[name].length > 1 ? array(events[name]) : events[name][0])
      )
    );
    push_prop(init("$$events", events_expression));
  }
  const snippet_declarations = [];
  const serialized_slots = [];
  for (const child of node.fragment.nodes) {
    if (child.type === "SnippetBlock") {
      context.visit(child, {
        ...context.state,
        init: snippet_declarations
      });
      push_prop(prop("init", child.expression, child.expression));
      serialized_slots.push(
        init(child.expression.name === "children" ? "default" : child.expression.name, true_instance)
      );
      continue;
    }
    let slot_name = determine_slot(child) ?? "default";
    (children[slot_name] || (children[slot_name] = [])).push(child);
  }
  for (const slot_name of Object.keys(children)) {
    const block2 = (
      /** @type {BlockStatement} */
      context.visit(
        {
          ...node.fragment,
          // @ts-expect-error
          nodes: children[slot_name]
        },
        slot_name === "default" ? slot_scope_applies_to_itself ? context.state : states.default : {
          ...context.state,
          scope: node.metadata.scopes[slot_name],
          transform: { ...context.state.transform }
        }
      )
    );
    if (block2.body.length === 0) continue;
    const slot_fn = arrow(
      [id("$$anchor"), id("$$slotProps")],
      block([
        ...slot_name === "default" && !slot_scope_applies_to_itself ? lets : [],
        ...block2.body
      ])
    );
    if (slot_name === "default" && !has_children_prop) {
      if (lets.length === 0 && children.default.every(
        (node2) => node2.type !== "SvelteFragment" || !node2.attributes.some((attr) => attr.type === "LetDirective")
      )) {
        push_prop(
          init(
            "children",
            dev ? call("$.wrap_snippet", id(context.state.analysis.name), slot_fn) : slot_fn
          )
        );
        serialized_slots.push(init(slot_name, true_instance));
      } else {
        serialized_slots.push(init(slot_name, slot_fn));
        push_prop(init("children", id("$.invalid_default_snippet")));
      }
    } else {
      serialized_slots.push(init(slot_name, slot_fn));
    }
  }
  if (serialized_slots.length > 0) {
    push_prop(init("$$slots", object(serialized_slots)));
  }
  if (!context.state.analysis.runes && node.attributes.some((attribute) => attribute.type === "BindDirective")) {
    push_prop(init("$$legacy", true_instance));
  }
  const props_expression = props_and_spreads.length === 0 || props_and_spreads.length === 1 && Array.isArray(props_and_spreads[0]) ? object(
    /** @type {Property[]} */
    props_and_spreads[0] || []
  ) : call(
    "$.spread_props",
    ...props_and_spreads.map((p) => Array.isArray(p) ? object(p) : p)
  );
  let fn = (node_id) => {
    return call(
      // TODO We can remove this ternary once we remove legacy mode, since in runes mode dynamic components
      // will be handled separately through the `$.component` function, and then the component name will
      // always be referenced through just the identifier here.
      node.type === "SvelteComponent" ? component_name : (
        /** @type {Expression} */
        context.visit(member_id(component_name))
      ),
      node_id,
      props_expression
    );
  };
  if (bind_this !== null) {
    const prev = fn;
    fn = (node_id) => {
      return build_bind_this(bind_this, prev(node_id), context);
    };
  }
  const statements = [...snippet_declarations];
  if (node.type === "SvelteComponent") {
    const prev = fn;
    fn = (node_id) => {
      return call(
        "$.component",
        node_id,
        thunk(
          /** @type {Expression} */
          context.visit(node.expression)
        ),
        arrow(
          [id("$$anchor"), id(component_name)],
          block([...binding_initializers, stmt(prev(id("$$anchor")))])
        )
      );
    };
  } else {
    statements.push(...binding_initializers);
  }
  if (Object.keys(custom_css_props).length > 0) {
    context.state.template.push(
      context.state.metadata.namespace === "svg" ? "<g><!></g>" : '<svelte-css-wrapper style="display: contents"><!></svelte-css-wrapper>'
    );
    statements.push(
      stmt(call("$.css_props", anchor, thunk(object(custom_css_props)))),
      stmt(fn(member(anchor, "lastChild"))),
      stmt(call("$.reset", anchor))
    );
  } else {
    context.state.template.push("<!>");
    statements.push(stmt(fn(anchor)));
  }
  return statements.length > 1 ? block(statements) : statements[0];
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Component.js
function Component3(node, context) {
  if (node.metadata.dynamic) {
    const component2 = build_component(node, "$$component", context, id("$$anchor"));
    context.state.init.push(
      stmt(
        call(
          "$.component",
          context.state.node,
          // TODO use untrack here to not update when binding changes?
          // Would align with Svelte 4 behavior, but it's arguably nicer/expected to update this
          thunk(
            /** @type {Expression} */
            context.visit(member_id(node.name))
          ),
          arrow([id("$$anchor"), id("$$component")], block([component2]))
        )
      )
    );
    return;
  }
  const component = build_component(node, node.name, context);
  context.state.init.push(component);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ConstTag.js
function ConstTag3(node, context) {
  const declaration2 = node.declaration.declarations[0];
  if (declaration2.id.type === "Identifier") {
    context.state.init.push(
      const_builder(
        declaration2.id,
        create_derived(
          context.state,
          thunk(
            /** @type {Expression} */
            context.visit(declaration2.init)
          )
        )
      )
    );
    context.state.transform[declaration2.id.name] = { read: get_value };
    if (dev) {
      context.state.init.push(stmt(call("$.get", declaration2.id)));
    }
  } else {
    const identifiers = extract_identifiers(declaration2.id);
    const tmp = id(context.state.scope.generate("computed_const"));
    const transform = { ...context.state.transform };
    for (const node2 of identifiers) {
      delete transform[node2.name];
    }
    const child_state = { ...context.state, transform };
    const fn = arrow(
      [],
      block([
        const_builder(
          /** @type {Pattern} */
          context.visit(declaration2.id, child_state),
          /** @type {Expression} */
          context.visit(declaration2.init, child_state)
        ),
        return_builder(object(identifiers.map((node2) => prop("init", node2, node2))))
      ])
    );
    context.state.init.push(const_builder(tmp, create_derived(context.state, fn)));
    if (dev) {
      context.state.init.push(stmt(call("$.get", tmp)));
    }
    for (const node2 of identifiers) {
      context.state.transform[node2.name] = {
        read: (node3) => member(call("$.get", tmp), node3)
      };
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/DebugTag.js
function DebugTag3(node, context) {
  const object4 = object(
    node.identifiers.map((identifier) => {
      const visited = call(
        "$.snapshot",
        /** @type {Expression} */
        context.visit(identifier)
      );
      return prop(
        "init",
        identifier,
        context.state.analysis.runes ? visited : call("$.untrack", thunk(visited))
      );
    })
  );
  const call2 = call("console.log", object4);
  context.state.init.push(
    stmt(call("$.template_effect", thunk(block([stmt(call2), debugger_builder]))))
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/EachBlock.js
function EachBlock3(node, context) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const each_node_meta = node.metadata;
  const collection = (
    /** @type {Expression} */
    context.visit(node.expression, {
      ...context.state,
      scope: (
        /** @type {Scope} */
        context.state.scope.parent
      )
    })
  );
  if (!each_node_meta.is_controlled) {
    context.state.template.push("<!>");
  }
  let flags = 0;
  if (node.metadata.keyed && node.index) {
    flags |= EACH_INDEX_REACTIVE;
  }
  const key_is_item = ((_a2 = node.key) == null ? void 0 : _a2.type) === "Identifier" && ((_b = node.context) == null ? void 0 : _b.type) === "Identifier" && ((_c = node.context) == null ? void 0 : _c.name) === node.key.name;
  let uses_store;
  for (const binding of node.metadata.expression.dependencies) {
    if (binding.kind === "store_sub") {
      uses_store = true;
      break;
    }
  }
  for (const binding of node.metadata.expression.dependencies) {
    if (binding.scope.function_depth >= context.state.scope.function_depth) {
      continue;
    }
    if (!context.state.analysis.runes || !key_is_item || uses_store) {
      flags |= EACH_ITEM_REACTIVE;
      break;
    }
  }
  if (context.state.analysis.runes && !uses_store) {
    flags |= EACH_ITEM_IMMUTABLE;
  }
  if (node.key && node.body.nodes.some((child) => {
    if (child.type !== "RegularElement" && child.type !== "SvelteElement") return false;
    return child.attributes.some((attr) => attr.type === "AnimateDirective");
  })) {
    flags |= EACH_IS_ANIMATED;
  }
  if (each_node_meta.is_controlled) {
    flags |= EACH_IS_CONTROLLED;
  }
  let store_to_invalidate = "";
  if (node.expression.type === "Identifier" || node.expression.type === "MemberExpression") {
    const id2 = object2(node.expression);
    if (id2) {
      const binding = context.state.scope.get(id2.name);
      if ((binding == null ? void 0 : binding.kind) === "store_sub") {
        store_to_invalidate = id2.name;
      }
    }
  }
  const indirect_dependencies = collect_parent_each_blocks(context).flatMap((block3) => {
    const array2 = (
      /** @type {Expression} */
      context.visit(block3.expression)
    );
    const transitive_dependencies = build_transitive_dependencies(
      block3.metadata.expression.dependencies,
      context
    );
    return [array2, ...transitive_dependencies];
  });
  let collection_id = null;
  for (const [name] of context.state.scope.declarations) {
    if (((_d = context.state.scope.parent) == null ? void 0 : _d.get(name)) != null) {
      collection_id = context.state.scope.root.unique("$$array");
      break;
    }
  }
  if (collection_id) {
    indirect_dependencies.push(call(collection_id));
  } else {
    indirect_dependencies.push(collection);
    const transitive_dependencies = build_transitive_dependencies(
      each_node_meta.expression.dependencies,
      context
    );
    indirect_dependencies.push(...transitive_dependencies);
  }
  const child_state = {
    ...context.state,
    transform: { ...context.state.transform },
    store_to_invalidate
  };
  const key_state = {
    ...context.state,
    transform: { ...context.state.transform }
  };
  const index = each_node_meta.contains_group_binding || !node.index ? each_node_meta.index : id(node.index);
  const item = ((_e = node.context) == null ? void 0 : _e.type) === "Identifier" ? node.context : id("$$item");
  let uses_index = each_node_meta.contains_group_binding;
  let key_uses_index = false;
  if (node.index) {
    child_state.transform[node.index] = {
      read: (node2) => {
        uses_index = true;
        return (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(node2) : node2;
      }
    };
    key_state.transform[node.index] = {
      read: (node2) => {
        key_uses_index = true;
        return node2;
      }
    };
  }
  const declarations = [];
  const invalidate = call(
    "$.invalidate_inner_signals",
    thunk(sequence(indirect_dependencies))
  );
  const invalidate_store = store_to_invalidate ? call("$.invalidate_store", id("$$stores"), literal(store_to_invalidate)) : void 0;
  const sequence2 = [];
  if (!context.state.analysis.runes) sequence2.push(invalidate);
  if (invalidate_store) sequence2.push(invalidate_store);
  if (((_f = node.context) == null ? void 0 : _f.type) === "Identifier") {
    const binding = (
      /** @type {Binding} */
      context.state.scope.get(node.context.name)
    );
    child_state.transform[node.context.name] = {
      read: (node2) => {
        if (binding.reassigned) {
          return member(
            collection_id ? call(collection_id) : collection,
            (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(index) : index,
            true
          );
        }
        return (flags & EACH_ITEM_REACTIVE) !== 0 ? get_value(node2) : node2;
      },
      assign: (_, value) => {
        uses_index = true;
        const left = member(
          collection_id ? call(collection_id) : collection,
          (flags & EACH_INDEX_REACTIVE) !== 0 ? get_value(index) : index,
          true
        );
        return sequence([assignment("=", left, value), ...sequence2]);
      },
      mutate: (_, mutation) => {
        uses_index = true;
        return sequence([mutation, ...sequence2]);
      }
    };
    delete key_state.transform[node.context.name];
  } else if (node.context) {
    const unwrapped = (flags & EACH_ITEM_REACTIVE) !== 0 ? call("$.get", item) : item;
    for (const path of extract_paths(node.context)) {
      const name = (
        /** @type {Identifier} */
        path.node.name
      );
      const needs_derived = path.has_default_value;
      const fn = thunk(
        /** @type {Expression} */
        context.visit((_g = path.expression) == null ? void 0 : _g.call(path, unwrapped), child_state)
      );
      declarations.push(let_builder(path.node, needs_derived ? call("$.derived_safe_equal", fn) : fn));
      const read = needs_derived ? get_value : call;
      child_state.transform[name] = {
        read,
        assign: (_, value) => {
          const left = (
            /** @type {Pattern} */
            path.update_expression(unwrapped)
          );
          return sequence([assignment("=", left, value), ...sequence2]);
        },
        mutate: (_, mutation) => {
          return sequence([mutation, ...sequence2]);
        }
      };
      if (dev) {
        declarations.push(stmt(read(id(name))));
      }
      delete key_state.transform[name];
    }
  }
  const block2 = (
    /** @type {BlockStatement} */
    context.visit(node.body, child_state)
  );
  let key_function = id("$.index");
  if (node.metadata.keyed) {
    const pattern = (
      /** @type {Pattern} */
      node.context
    );
    const expression = (
      /** @type {Expression} */
      context.visit(
        /** @type {Expression} */
        node.key,
        key_state
      )
    );
    key_function = arrow(key_uses_index ? [pattern, index] : [pattern], expression);
  }
  if (node.index && each_node_meta.contains_group_binding) {
    declarations.push(let_builder(node.index, index));
  }
  if (dev && node.metadata.keyed) {
    context.state.init.push(
      stmt(call("$.validate_each_keys", thunk(collection), key_function))
    );
  }
  const render_args = [id("$$anchor"), item];
  if (uses_index || collection_id) render_args.push(index);
  if (collection_id) render_args.push(collection_id);
  const args = [
    context.state.node,
    literal(flags),
    thunk(collection),
    key_function,
    arrow(render_args, block(declarations.concat(block2.body)))
  ];
  if (node.fallback) {
    args.push(
      arrow(
        [id("$$anchor")],
        /** @type {BlockStatement} */
        context.visit(node.fallback)
      )
    );
  }
  context.state.init.push(stmt(call("$.each", ...args)));
}
function collect_parent_each_blocks(context) {
  return (
    /** @type {AST.EachBlock[]} */
    context.path.filter((node) => node.type === "EachBlock")
  );
}
function build_transitive_dependencies(references, context) {
  const dependencies = /* @__PURE__ */ new Set();
  for (const ref of references) {
    const deps = collect_transitive_dependencies(ref);
    for (const dep of deps) {
      dependencies.add(dep);
    }
  }
  return [...dependencies].map((dep) => build_getter({ ...dep.node }, context.state));
}
function collect_transitive_dependencies(binding, seen2 = /* @__PURE__ */ new Set()) {
  if (binding.kind !== "legacy_reactive") return [];
  for (const dep of binding.legacy_dependencies) {
    if (!seen2.has(dep)) {
      seen2.add(dep);
      for (const transitive_dep of collect_transitive_dependencies(dep, seen2)) {
        seen2.add(transitive_dep);
      }
    }
  }
  return [...seen2];
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ExportNamedDeclaration.js
function ExportNamedDeclaration2(node, context) {
  if (context.state.is_instance) {
    if (node.declaration) {
      return context.visit(node.declaration);
    }
    return empty;
  }
  return context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ExpressionStatement.js
function ExpressionStatement3(node, context) {
  if (node.expression.type === "CallExpression") {
    const rune = get_rune(node.expression, context.state.scope);
    if (rune === "$effect" || rune === "$effect.pre") {
      const callee = rune === "$effect" ? "$.user_effect" : "$.user_pre_effect";
      const func = (
        /** @type {Expression} */
        context.visit(node.expression.arguments[0])
      );
      const expr = call(
        callee,
        /** @type {Expression} */
        func
      );
      expr.callee.loc = node.expression.callee.loc;
      return stmt(expr);
    }
    if (rune === "$inspect.trace") {
      return empty;
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Fragment.js
function Fragment2(node, context) {
  const parent = context.path.at(-1) ?? node;
  const namespace = infer_namespace(context.state.metadata.namespace, parent, node.nodes);
  const { hoisted, trimmed, is_standalone, is_text_first } = clean_nodes(
    parent,
    node.nodes,
    context.path,
    namespace,
    context.state,
    context.state.preserve_whitespace,
    context.state.options.preserveComments
  );
  if (hoisted.length === 0 && trimmed.length === 0) {
    return block([]);
  }
  const is_single_element = trimmed.length === 1 && trimmed[0].type === "RegularElement";
  const is_single_child_not_needing_template = trimmed.length === 1 && (trimmed[0].type === "SvelteFragment" || trimmed[0].type === "TitleElement" || trimmed[0].type === "IfBlock" && trimmed[0].elseif);
  const template_name = context.state.scope.root.unique("root");
  const body = [];
  let close2 = void 0;
  const state = {
    ...context.state,
    init: [],
    update: [],
    expressions: [],
    after_update: [],
    template: [],
    locations: [],
    transform: { ...context.state.transform },
    metadata: {
      context: {
        template_needs_import_node: false,
        template_contains_script_tag: false
      },
      namespace,
      bound_contenteditable: context.state.metadata.bound_contenteditable
    }
  };
  for (const node2 of hoisted) {
    context.visit(node2, state);
  }
  if (is_text_first) {
    body.push(stmt(call("$.next")));
  }
  const add_template = (template_name2, args) => {
    let call2 = call(get_template_function(namespace, state), ...args);
    if (dev) {
      call2 = call(
        "$.add_locations",
        call2,
        member(id(context.state.analysis.name), "$.FILENAME", true),
        build_locations(state.locations)
      );
    }
    context.state.hoisted.push(var_builder(template_name2, call2));
  };
  if (is_single_element) {
    const element2 = (
      /** @type {AST.RegularElement} */
      trimmed[0]
    );
    const id2 = id(context.state.scope.generate(element2.name));
    context.visit(element2, {
      ...state,
      node: id2
    });
    const args = [join_template(state.template)];
    if (state.metadata.context.template_needs_import_node) {
      args.push(literal(TEMPLATE_USE_IMPORT_NODE));
    }
    add_template(template_name, args);
    body.push(var_builder(id2, call(template_name)));
    close2 = stmt(call("$.append", id("$$anchor"), id2));
  } else if (is_single_child_not_needing_template) {
    context.visit(trimmed[0], state);
  } else if (trimmed.length === 1 && trimmed[0].type === "Text") {
    const id2 = id(context.state.scope.generate("text"));
    body.push(var_builder(id2, call("$.text", literal(trimmed[0].data))));
    close2 = stmt(call("$.append", id("$$anchor"), id2));
  } else if (trimmed.length > 0) {
    const id2 = id(context.state.scope.generate("fragment"));
    const use_space_template = trimmed.some((node2) => node2.type === "ExpressionTag") && trimmed.every((node2) => node2.type === "Text" || node2.type === "ExpressionTag");
    if (use_space_template) {
      const id3 = id(context.state.scope.generate("text"));
      process_children2(trimmed, () => id3, false, {
        ...context,
        state
      });
      body.push(var_builder(id3, call("$.text")));
      close2 = stmt(call("$.append", id("$$anchor"), id3));
    } else {
      if (is_standalone) {
        process_children2(trimmed, () => id("$$anchor"), false, { ...context, state });
      } else {
        const expression = (is_text) => call("$.first_child", id2, is_text && true_instance);
        process_children2(trimmed, expression, false, { ...context, state });
        let flags = TEMPLATE_FRAGMENT;
        if (state.metadata.context.template_needs_import_node) {
          flags |= TEMPLATE_USE_IMPORT_NODE;
        }
        if (state.template.length === 1 && state.template[0] === "<!>") {
          body.push(var_builder(id2, call("$.comment")));
        } else {
          add_template(template_name, [join_template(state.template), literal(flags)]);
          body.push(var_builder(id2, call(template_name)));
        }
        close2 = stmt(call("$.append", id("$$anchor"), id2));
      }
    }
  }
  body.push(...state.init);
  if (state.update.length > 0) {
    body.push(build_render_statement(state));
  }
  body.push(...state.after_update);
  if (close2 !== void 0) {
    body.push(close2);
  }
  return block(body);
}
function join_template(items) {
  let quasi2 = quasi("");
  const template3 = template([quasi2], []);
  function push(expression) {
    if (expression.type === "TemplateLiteral") {
      for (let i = 0; i < expression.expressions.length; i += 1) {
        const q = expression.quasis[i];
        const e2 = expression.expressions[i];
        quasi2.value.cooked += /** @type {string} */
        q.value.cooked;
        push(e2);
      }
      const last = (
        /** @type {TemplateElement} */
        expression.quasis.at(-1)
      );
      quasi2.value.cooked += /** @type {string} */
      last.value.cooked;
    } else if (expression.type === "Literal") {
      quasi2.value.cooked += expression.value;
    } else {
      template3.expressions.push(expression);
      template3.quasis.push(quasi2 = quasi(""));
    }
  }
  for (const item of items) {
    if (typeof item === "string") {
      quasi2.value.cooked += item;
    } else {
      push(item);
    }
  }
  for (const quasi3 of template3.quasis) {
    quasi3.value.raw = sanitize_template_string(
      /** @type {string} */
      quasi3.value.cooked
    );
  }
  quasi2.tail = true;
  return template3;
}
function get_template_function(namespace, state) {
  const contains_script_tag = state.metadata.context.template_contains_script_tag;
  return namespace === "svg" ? contains_script_tag ? "$.svg_template_with_script" : "$.ns_template" : namespace === "mathml" ? "$.mathml_template" : contains_script_tag ? "$.template_with_script" : "$.template";
}
function build_locations(locations) {
  return array(
    locations.map((loc) => {
      const expression = array([literal(loc[0]), literal(loc[1])]);
      if (loc.length === 3) {
        expression.elements.push(build_locations(loc[2]));
      }
      return expression;
    })
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/FunctionDeclaration.js
function FunctionDeclaration2(node, context) {
  var _a2;
  const state = { ...context.state, in_constructor: false };
  if (((_a2 = node.metadata) == null ? void 0 : _a2.hoisted) === true) {
    const params = build_hoisted_params(node, context);
    const body = context.visit(node.body, state);
    context.state.hoisted.push(
      /** @type {FunctionDeclaration} */
      { ...node, params, body }
    );
    return empty;
  }
  context.next(state);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/FunctionExpression.js
function FunctionExpression2(node, context) {
  return visit_function2(node, context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/HtmlTag.js
function HtmlTag3(node, context) {
  context.state.template.push("<!>");
  const expression = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const is_svg2 = context.state.metadata.namespace === "svg";
  const is_mathml2 = context.state.metadata.namespace === "mathml";
  const statement = stmt(
    call(
      "$.html",
      context.state.node,
      thunk(expression),
      is_svg2 && true_instance,
      is_mathml2 && true_instance,
      is_ignored(node, "hydration_html_changed") && true_instance
    )
  );
  context.state.init.push(statement);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Identifier.js
function Identifier3(node, context) {
  const parent = (
    /** @type {Node} */
    context.path.at(-1)
  );
  if (is_reference(node, parent)) {
    if (node.name === "$$props") {
      return id("$$sanitized_props");
    }
    const binding = context.state.scope.get(node.name);
    if (context.state.analysis.runes && // can't do this in legacy mode because the proxy does more than just read/write
    binding !== null && node !== binding.node && binding.kind === "rest_prop") {
      const grand_parent = context.path.at(-2);
      if ((parent == null ? void 0 : parent.type) === "MemberExpression" && !parent.computed && (grand_parent == null ? void 0 : grand_parent.type) !== "AssignmentExpression" && (grand_parent == null ? void 0 : grand_parent.type) !== "UpdateExpression") {
        return id("$$props");
      }
    }
    return build_getter(node, context.state);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/IfBlock.js
function IfBlock3(node, context) {
  context.state.template.push("<!>");
  const statements = [];
  const consequent = (
    /** @type {BlockStatement} */
    context.visit(node.consequent)
  );
  const consequent_id = context.state.scope.generate("consequent");
  statements.push(var_builder(id(consequent_id), arrow([id("$$anchor")], consequent)));
  let alternate_id;
  if (node.alternate) {
    alternate_id = context.state.scope.generate("alternate");
    const alternate = (
      /** @type {BlockStatement} */
      context.visit(node.alternate)
    );
    const nodes = node.alternate.nodes;
    let alternate_args = [id("$$anchor")];
    if (nodes.length === 1 && nodes[0].type === "IfBlock" && nodes[0].elseif) {
      alternate_args.push(id("$$elseif"));
    }
    statements.push(var_builder(id(alternate_id), arrow(alternate_args, alternate)));
  }
  const args = [
    node.elseif ? id("$$anchor") : context.state.node,
    arrow(
      [id("$$render")],
      block([
        if_builder(
          /** @type {Expression} */
          context.visit(node.test),
          stmt(call(id("$$render"), id(consequent_id))),
          alternate_id ? stmt(call(id("$$render"), id(alternate_id), false_instance)) : void 0
        )
      ])
    )
  ];
  if (node.elseif) {
    args.push(id("$$elseif"));
  }
  statements.push(stmt(call("$.if", ...args)));
  context.state.init.push(block(statements));
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/ImportDeclaration.js
function ImportDeclaration2(node, context) {
  if ("hoisted" in context.state) {
    context.state.hoisted.push(node);
    return empty;
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/KeyBlock.js
function KeyBlock3(node, context) {
  context.state.template.push("<!>");
  const key2 = (
    /** @type {Expression} */
    context.visit(node.expression)
  );
  const body = (
    /** @type {Expression} */
    context.visit(node.fragment)
  );
  context.state.init.push(
    stmt(call("$.key", context.state.node, thunk(key2), arrow([id("$$anchor")], body)))
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/LabeledStatement.js
function LabeledStatement3(node, context) {
  if (context.state.analysis.runes || context.path.length > 1 || node.label.name !== "$") {
    context.next();
    return;
  }
  const reactive_statement = (
    /** @type {ReactiveStatement} */
    context.state.analysis.reactive_statements.get(node)
  );
  if (!reactive_statement) return;
  let serialized_body = (
    /** @type {Statement} */
    context.visit(node.body)
  );
  if (serialized_body.type !== "BlockStatement") {
    serialized_body = block([serialized_body]);
  }
  const body = serialized_body.body;
  const sequence2 = [];
  for (const binding of reactive_statement.dependencies) {
    if (binding.kind === "normal" && binding.declaration_kind !== "import") continue;
    const name = binding.node.name;
    let serialized = build_getter(id(name), context.state);
    if (name === "$$props" || name === "$$restProps" || binding.kind === "bindable_prop") {
      serialized = call("$.deep_read_state", serialized);
    }
    sequence2.push(serialized);
  }
  context.state.legacy_reactive_statements.set(
    node,
    stmt(
      call(
        "$.legacy_pre_effect",
        sequence2.length > 0 ? thunk(sequence(sequence2)) : thunk(block([])),
        thunk(block(body))
      )
    )
  );
  return empty;
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/LetDirective.js
function LetDirective2(node, context) {
  if (node.expression && node.expression.type !== "Identifier") {
    const name = context.state.scope.generate(node.name);
    const bindings = context.state.scope.get_bindings(node);
    for (const binding of bindings) {
      context.state.transform[binding.node.name] = {
        read: (node2) => member(call("$.get", id(name)), node2)
      };
    }
    return const_builder(
      name,
      call(
        "$.derived",
        thunk(
          block([
            let_builder(
              /** @type {Expression} */
              node.expression.type === "ObjectExpression" ? (
                // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                object_pattern(node.expression.properties)
              ) : (
                // @ts-expect-error types don't match, but it can't contain spread elements and the structure is otherwise fine
                array_pattern(node.expression.elements)
              ),
              member(id("$$slotProps"), node.name)
            ),
            return_builder(object(bindings.map((binding) => init(binding.node.name, binding.node))))
          ])
        )
      )
    );
  } else {
    const name = node.expression === null ? node.name : node.expression.name;
    context.state.transform[name] = {
      read: (node2) => call("$.get", node2)
    };
    return const_builder(
      name,
      create_derived(context.state, thunk(member(id("$$slotProps"), node.name)))
    );
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/MemberExpression.js
function MemberExpression3(node, context) {
  if (node.property.type === "PrivateIdentifier") {
    const field = context.state.private_state.get(node.property.name);
    if (field) {
      return context.state.in_constructor && (field.kind === "raw_state" || field.kind === "state") ? member(node, "v") : call("$.get", node);
    }
  }
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/OnDirective.js
var modifiers = [
  "stopPropagation",
  "stopImmediatePropagation",
  "preventDefault",
  "self",
  "trusted",
  "once"
];
function OnDirective2(node, context) {
  if (!node.expression) {
    context.state.analysis.needs_props = true;
  }
  let handler = build_event_handler(node.expression, node.metadata.expression, context);
  for (const modifier of modifiers) {
    if (node.modifiers.includes(modifier)) {
      handler = call("$." + modifier, handler);
    }
  }
  const capture = node.modifiers.includes("capture");
  const passive = node.modifiers.includes("passive") || (node.modifiers.includes("nonpassive") ? false : void 0);
  return build_event(node.name, context.state.node, handler, capture, passive);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/Program.js
function Program(_, context) {
  if (!context.state.analysis.runes) {
    context.state.transform["$$props"] = {
      read: (node) => ({ ...node, name: "$$sanitized_props" })
    };
    for (const [name, binding] of context.state.scope.declarations) {
      if (binding.declaration_kind === "import" && binding.mutated) {
        const { start, end } = context.state.analysis.instance.ast;
        const node = (
          /** @type {ImportDeclaration} */
          binding.initial
        );
        const is_instance_import = (
          /** @type {number} */
          node.start > /** @type {number} */
          start && /** @type {number} */
          node.end < /** @type {number} */
          end
        );
        if (is_instance_import) {
          const id2 = id("$$_import_" + name);
          context.state.transform[name] = {
            read: (_2) => call(id2),
            mutate: (_2, mutation) => call(id2, mutation)
          };
          context.state.legacy_reactive_imports.push(
            var_builder(id2, call("$.reactive_import", thunk(id(name))))
          );
        }
      }
    }
  }
  for (const [name, binding] of context.state.scope.declarations) {
    if (binding.kind === "store_sub") {
      let cached;
      const get_store = () => {
        return cached ?? (cached = /** @type {Expression} */
        context.visit(id(name.slice(1))));
      };
      context.state.transform[name] = {
        read: call,
        assign: (_2, value) => call("$.store_set", get_store(), value),
        mutate: (node, mutation) => {
          const untracked = call("$.untrack", node);
          function replace(n) {
            if (n.type === "MemberExpression") {
              return {
                ...n,
                object: replace(
                  /** @type {Expression} */
                  n.object
                ),
                property: n.property
              };
            }
            return untracked;
          }
          return call(
            "$.store_mutate",
            get_store(),
            mutation.type === "AssignmentExpression" ? assignment(
              mutation.operator,
              /** @type {MemberExpression} */
              replace(
                /** @type {MemberExpression} */
                mutation.left
              ),
              mutation.right
            ) : update(mutation.operator, replace(mutation.argument), mutation.prefix),
            untracked
          );
        },
        update: (node) => {
          return call(
            node.prefix ? "$.update_pre_store" : "$.update_store",
            build_getter(id(name.slice(1)), context.state),
            call(node.argument),
            node.operator === "--" && literal(-1)
          );
        }
      };
    }
    if (binding.kind === "prop" || binding.kind === "bindable_prop") {
      if (is_prop_source(binding, context.state)) {
        context.state.transform[name] = {
          read: call,
          assign: (node, value) => call(node, value),
          mutate: (node, value) => {
            if (binding.kind === "bindable_prop") {
              return call(node, value, true_instance);
            }
            return value;
          },
          update: (node) => {
            return call(
              node.prefix ? "$.update_pre_prop" : "$.update_prop",
              node.argument,
              node.operator === "--" && literal(-1)
            );
          }
        };
      } else if (binding.prop_alias) {
        const key2 = key(binding.prop_alias);
        context.state.transform[name] = {
          read: (_2) => member(id("$$props"), key2, key2.type === "Literal")
        };
      } else {
        context.state.transform[name] = {
          read: (node) => member(id("$$props"), node)
        };
      }
    }
  }
  add_state_transformers(context);
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/RenderTag.js
function RenderTag3(node, context) {
  context.state.template.push("<!>");
  const expression = unwrap_optional(node.expression);
  const callee = expression.callee;
  const raw_args = expression.arguments;
  let args = [];
  for (let i = 0; i < raw_args.length; i++) {
    let thunk2 = thunk(
      /** @type {Expression} */
      context.visit(raw_args[i])
    );
    const { has_call } = node.metadata.arguments[i];
    if (has_call) {
      const id2 = id(context.state.scope.generate("render_arg"));
      context.state.init.push(var_builder(id2, call("$.derived_safe_equal", thunk2)));
      args.push(thunk(call("$.get", id2)));
    } else {
      args.push(thunk2);
    }
  }
  let snippet_function = (
    /** @type {Expression} */
    context.visit(callee)
  );
  if (node.metadata.dynamic) {
    if (node.expression.type === "ChainExpression") {
      snippet_function = logical("??", snippet_function, id("$.noop"));
    }
    context.state.init.push(
      stmt(call("$.snippet", context.state.node, thunk(snippet_function), ...args))
    );
  } else {
    context.state.init.push(
      stmt(
        (node.expression.type === "CallExpression" ? call : maybe_call)(
          snippet_function,
          context.state.node,
          ...args
        )
      )
    );
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SlotElement.js
function SlotElement3(node, context) {
  context.state.template.push("<!>");
  const props = [];
  const spreads = [];
  const lets = [];
  let is_default = true;
  let name = literal("default");
  for (const attribute of node.attributes) {
    if (attribute.type === "SpreadAttribute") {
      spreads.push(thunk(
        /** @type {Expression} */
        context.visit(attribute)
      ));
    } else if (attribute.type === "Attribute") {
      const { value, has_state } = build_attribute_value2(
        attribute.value,
        context,
        (value2, metadata) => metadata.has_call ? memoize_expression(context.state, value2) : value2
      );
      if (attribute.name === "name") {
        name = /** @type {Literal} */
        value;
        is_default = false;
      } else if (attribute.name !== "slot") {
        if (has_state) {
          props.push(get(attribute.name, [return_builder(value)]));
        } else {
          props.push(init(attribute.name, value));
        }
      }
    } else if (attribute.type === "LetDirective") {
      lets.push(
        /** @type {ExpressionStatement} */
        context.visit(attribute)
      );
    }
  }
  context.state.init.push(...lets);
  const props_expression = spreads.length === 0 ? object(props) : call("$.spread_props", object(props), ...spreads);
  const fallback = node.fragment.nodes.length === 0 ? null_instance : arrow(
    [id("$$anchor")],
    /** @type {BlockStatement} */
    context.visit(node.fragment)
  );
  const slot = call(
    "$.slot",
    context.state.node,
    id("$$props"),
    name,
    props_expression,
    fallback
  );
  context.state.init.push(stmt(slot));
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SnippetBlock.js
function SnippetBlock3(node, context) {
  var _a2;
  const args = [id("$$anchor")];
  let body;
  const declarations = [];
  if (dev) {
    declarations.push(stmt(call("$.validate_snippet_args", spread(id("arguments")))));
  }
  const transform = { ...context.state.transform };
  const child_state = { ...context.state, transform };
  for (let i = 0; i < node.parameters.length; i++) {
    const argument = node.parameters[i];
    if (!argument) continue;
    if (argument.type === "Identifier") {
      args.push(assignment_pattern(argument, id("$.noop")));
      transform[argument.name] = { read: call };
      continue;
    }
    let arg_alias = `$$arg${i}`;
    args.push(id(arg_alias));
    const paths = extract_paths(argument);
    for (const path of paths) {
      const name = (
        /** @type {Identifier} */
        path.node.name
      );
      const needs_derived = path.has_default_value;
      const fn = thunk(
        /** @type {Expression} */
        context.visit((_a2 = path.expression) == null ? void 0 : _a2.call(path, maybe_call(id(arg_alias))))
      );
      declarations.push(let_builder(path.node, needs_derived ? call("$.derived_safe_equal", fn) : fn));
      transform[name] = {
        read: needs_derived ? get_value : call
      };
      if (dev) {
        declarations.push(stmt(transform[name].read(id(name))));
      }
    }
  }
  body = block([
    ...declarations,
    .../** @type {BlockStatement} */
    context.visit(node.body, child_state).body
  ]);
  let snippet = dev ? call("$.wrap_snippet", id(context.state.analysis.name), function_builder(null, args, body)) : arrow(args, body);
  const declaration2 = const_builder(node.expression, snippet);
  if (context.path.length === 1 && context.path[0].type === "Fragment") {
    if (node.metadata.can_hoist) {
      context.state.module_level_snippets.push(declaration2);
    } else {
      context.state.instance_level_snippets.push(declaration2);
    }
  } else {
    context.state.init.push(declaration2);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SpreadAttribute.js
function SpreadAttribute3(node, context) {
  return context.visit(node.expression);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/shared/special_element.js
function visit_special_element(node, id2, context) {
  const state = { ...context.state, node: id(id2) };
  for (const attribute of node.attributes) {
    if (attribute.type === "OnDirective") {
      context.state.init.push(stmt(
        /** @type {Expression} */
        context.visit(attribute, state)
      ));
    } else {
      context.visit(attribute, state);
    }
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteBody.js
function SvelteBody2(node, context) {
  visit_special_element(node, "$.document.body", context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteComponent.js
function SvelteComponent3(node, context) {
  const component = build_component(node, "$$component", context);
  context.state.init.push(component);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteDocument.js
function SvelteDocument2(node, context) {
  visit_special_element(node, "$.document", context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteElement.js
function SvelteElement3(node, context) {
  context.state.template.push(`<!>`);
  const attributes = [];
  let dynamic_namespace = void 0;
  const class_directives = [];
  const style_directives = [];
  const lets = [];
  const element_id = id(context.state.scope.generate("$$element"));
  const inner_context = {
    ...context,
    state: {
      ...context.state,
      node: element_id,
      init: [],
      update: [],
      expressions: [],
      after_update: []
    }
  };
  for (const attribute of node.attributes) {
    if (attribute.type === "Attribute") {
      if (attribute.name === "xmlns" && !is_text_attribute(attribute)) {
        dynamic_namespace = attribute.value;
      }
      attributes.push(attribute);
    } else if (attribute.type === "SpreadAttribute") {
      attributes.push(attribute);
    } else if (attribute.type === "ClassDirective") {
      class_directives.push(attribute);
    } else if (attribute.type === "StyleDirective") {
      style_directives.push(attribute);
    } else if (attribute.type === "LetDirective") {
      lets.push(
        /** @type {ExpressionStatement} */
        context.visit(attribute)
      );
    } else if (attribute.type === "OnDirective") {
      const handler = (
        /** @type {Expression} */
        context.visit(attribute, inner_context.state)
      );
      inner_context.state.after_update.push(stmt(handler));
    } else {
      context.visit(attribute, inner_context.state);
    }
  }
  context.state.init.push(...lets);
  if (attributes.length === 1 && attributes[0].type === "Attribute" && attributes[0].name.toLowerCase() === "class" && is_text_attribute(attributes[0])) {
    build_set_class(node, element_id, attributes[0], class_directives, inner_context, false);
  } else if (attributes.length) {
    const attributes_id = id(context.state.scope.generate("attributes"));
    build_set_attributes(
      attributes,
      class_directives,
      style_directives,
      inner_context,
      node,
      element_id,
      attributes_id
    );
  }
  const get_tag = thunk(
    /** @type {Expression} */
    context.visit(node.tag)
  );
  if (dev) {
    if (node.fragment.nodes.length > 0) {
      context.state.init.push(stmt(call("$.validate_void_dynamic_element", get_tag)));
    }
    context.state.init.push(stmt(call("$.validate_dynamic_element_tag", get_tag)));
  }
  const inner = inner_context.state.init;
  if (inner_context.state.update.length > 0) {
    inner.push(build_render_statement(inner_context.state));
  }
  inner.push(...inner_context.state.after_update);
  inner.push(
    .../** @type {BlockStatement} */
    context.visit(node.fragment, {
      ...context.state,
      metadata: {
        ...context.state.metadata,
        namespace: determine_namespace_for_children(node, context.state.metadata.namespace)
      }
    }).body
  );
  const location = dev && locator(node.start);
  context.state.init.push(
    stmt(
      call(
        "$.element",
        context.state.node,
        get_tag,
        node.metadata.svg || node.metadata.mathml ? true_instance : false_instance,
        inner.length > 0 && arrow([element_id, id("$$anchor")], block(inner)),
        dynamic_namespace && thunk(build_attribute_value2(dynamic_namespace, context).value),
        location && array([literal(location.line), literal(location.column)])
      )
    )
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteFragment.js
function SvelteFragment3(node, context) {
  for (const attribute of node.attributes) {
    if (attribute.type === "LetDirective") {
      context.state.init.push(
        /** @type {ExpressionStatement} */
        context.visit(attribute)
      );
    }
  }
  context.state.init.push(.../** @type {BlockStatement} */
  context.visit(node.fragment).body);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteBoundary.js
function SvelteBoundary3(node, context) {
  const props = object([]);
  for (const attribute of node.attributes) {
    if (attribute.type !== "Attribute" || attribute.value === true) {
      continue;
    }
    const chunk = Array.isArray(attribute.value) ? (
      /** @type {AST.ExpressionTag} */
      attribute.value[0]
    ) : attribute.value;
    const expression = (
      /** @type {Expression} */
      context.visit(chunk.expression, context.state)
    );
    if (chunk.metadata.expression.has_state) {
      props.properties.push(get(attribute.name, [return_builder(expression)]));
    } else {
      props.properties.push(init(attribute.name, expression));
    }
  }
  const nodes = [];
  const external_statements = [];
  const internal_statements = [];
  const snippets_visits = [];
  for (const child of node.fragment.nodes) {
    if (child.type === "SnippetBlock" && child.expression.name === "failed") {
      snippets_visits.push(() => {
        const init2 = [];
        context.visit(child, { ...context.state, init: init2 });
        props.properties.push(prop("init", child.expression, child.expression));
        external_statements.push(...init2);
      });
    } else if (child.type === "ConstTag") {
      const init2 = [];
      context.visit(child, { ...context.state, init: init2 });
      if (dev) {
        for (const statement of init2) {
          if (statement.type === "VariableDeclaration") {
            external_statements.push(statement);
          } else {
            internal_statements.push(statement);
          }
        }
      } else {
        external_statements.push(...init2);
      }
    } else {
      nodes.push(child);
    }
  }
  snippets_visits.forEach((visit) => visit());
  const block2 = (
    /** @type {BlockStatement} */
    context.visit({ ...node.fragment, nodes })
  );
  if (dev && internal_statements.length) {
    block2.body.unshift(...internal_statements);
  }
  const boundary = stmt(
    call("$.boundary", context.state.node, props, arrow([id("$$anchor")], block2))
  );
  context.state.template.push("<!>");
  context.state.init.push(
    external_statements.length > 0 ? block([...external_statements, boundary]) : boundary
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteHead.js
function SvelteHead3(node, context) {
  context.state.init.push(
    stmt(
      call(
        "$.head",
        arrow(
          [id("$$anchor")],
          /** @type {BlockStatement} */
          context.visit(node.fragment)
        )
      )
    )
  );
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteSelf.js
function SvelteSelf3(node, context) {
  const component = build_component(node, context.state.analysis.name, context);
  context.state.init.push(component);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/SvelteWindow.js
function SvelteWindow2(node, context) {
  visit_special_element(node, "$.window", context);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/TitleElement.js
function TitleElement3(node, context) {
  const { has_state, value } = build_template_chunk(
    /** @type {any} */
    node.fragment.nodes,
    context.visit,
    context.state
  );
  const statement = stmt(assignment("=", id("$.document.title"), value));
  if (has_state) {
    context.state.update.push(statement);
  } else {
    context.state.init.push(statement);
  }
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/TransitionDirective.js
function TransitionDirective2(node, context) {
  let flags = node.modifiers.includes("global") ? TRANSITION_GLOBAL : 0;
  if (node.intro) flags |= TRANSITION_IN;
  if (node.outro) flags |= TRANSITION_OUT;
  const args = [
    literal(flags),
    context.state.node,
    thunk(
      /** @type {Expression} */
      context.visit(parse_directive_name(node.name))
    )
  ];
  if (node.expression) {
    args.push(thunk(
      /** @type {Expression} */
      context.visit(node.expression)
    ));
  }
  context.state.after_update.push(stmt(call("$.transition", ...args)));
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/UpdateExpression.js
function UpdateExpression3(node, context) {
  const argument = node.argument;
  if (argument.type === "MemberExpression" && argument.object.type === "ThisExpression" && argument.property.type === "PrivateIdentifier" && context.state.private_state.has(argument.property.name)) {
    let fn = "$.update";
    if (node.prefix) fn += "_pre";
    const args = [argument];
    if (node.operator === "--") {
      args.push(literal(-1));
    }
    return call(fn, ...args);
  }
  if (argument.type !== "Identifier" && argument.type !== "MemberExpression") {
    throw new Error("An impossible state was reached");
  }
  const left = object2(argument);
  const transformers = left && context.state.transform[left.name];
  if (left === argument && (transformers == null ? void 0 : transformers.update)) {
    return transformers.update(node);
  }
  let update2 = (
    /** @type {Expression} */
    context.next()
  );
  if (left && (transformers == null ? void 0 : transformers.mutate)) {
    update2 = transformers.mutate(
      left,
      /** @type {AssignmentExpression | UpdateExpression} */
      update2
    );
  }
  return validate_mutation(node, context, update2);
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/UseDirective.js
function UseDirective2(node, context) {
  const params = [id("$$node")];
  if (node.expression) {
    params.push(id("$$action_arg"));
  }
  const args = [
    context.state.node,
    arrow(
      params,
      maybe_call(
        /** @type {Expression} */
        context.visit(parse_directive_name(node.name)),
        ...params
      )
    )
  ];
  if (node.expression) {
    args.push(thunk(
      /** @type {Expression} */
      context.visit(node.expression)
    ));
  }
  context.state.init.push(stmt(call("$.action", ...args)));
  context.next();
}

// node_modules/svelte/src/compiler/phases/3-transform/client/visitors/VariableDeclaration.js
function VariableDeclaration2(node, context) {
  var _a2;
  const declarations = [];
  if (context.state.analysis.runes) {
    for (const declarator2 of node.declarations) {
      const init2 = declarator2.init;
      const rune = get_rune(init2, context.state.scope);
      if (!rune || rune === "$effect.tracking" || rune === "$effect.root" || rune === "$inspect" || rune === "$inspect.trace" || rune === "$state.snapshot" || rune === "$host") {
        if (init2 != null && is_hoisted_function(init2)) {
          context.state.hoisted.push(
            const_builder(
              declarator2.id,
              /** @type {Expression} */
              context.visit(init2)
            )
          );
          continue;
        }
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (rune === "$props.id") {
        continue;
      }
      if (rune === "$props") {
        const seen2 = ["$$slots", "$$events", "$$legacy"];
        if (context.state.analysis.custom_element) {
          seen2.push("$$host");
        }
        if (declarator2.id.type === "Identifier") {
          const args2 = [id("$$props"), array(seen2.map((name) => literal(name)))];
          if (dev) {
            args2.push(literal(declarator2.id.name));
          }
          declarations.push(declarator(declarator2.id, call("$.rest_props", ...args2)));
        } else {
          equal(declarator2.id.type, "ObjectPattern");
          for (const property of declarator2.id.properties) {
            if (property.type === "Property") {
              const key2 = (
                /** @type {Identifier | Literal} */
                property.key
              );
              const name = key2.type === "Identifier" ? key2.name : (
                /** @type {string} */
                key2.value
              );
              seen2.push(name);
              let id2 = property.value.type === "AssignmentPattern" ? property.value.left : property.value;
              equal(id2.type, "Identifier");
              const binding = (
                /** @type {Binding} */
                context.state.scope.get(id2.name)
              );
              let initial = binding.initial && /** @type {Expression} */
              context.visit(binding.initial);
              if (initial && binding.kind === "bindable_prop" && should_proxy(initial, context.state.scope)) {
                initial = call("$.proxy", initial);
              }
              if (is_prop_source(binding, context.state)) {
                declarations.push(
                  declarator(id2, get_prop_source(binding, context.state, name, initial))
                );
              }
            } else {
              const args2 = [id("$$props"), array(seen2.map((name) => literal(name)))];
              if (dev) {
                args2.push(literal(
                  /** @type {Identifier} */
                  property.argument.name
                ));
              }
              declarations.push(declarator(property.argument, call("$.rest_props", ...args2)));
            }
          }
        }
        continue;
      }
      const args = (
        /** @type {CallExpression} */
        init2.arguments
      );
      const value = args.length > 0 ? (
        /** @type {Expression} */
        context.visit(args[0])
      ) : void0;
      if (rune === "$state" || rune === "$state.raw") {
        const create_state_declarator = (id2, value2) => {
          const binding = (
            /** @type {import('#compiler').Binding} */
            context.state.scope.get(id2.name)
          );
          if (rune === "$state" && should_proxy(value2, context.state.scope)) {
            value2 = call("$.proxy", value2);
          }
          if (is_state_source(binding, context.state.analysis)) {
            value2 = call("$.state", value2);
          }
          return value2;
        };
        if (declarator2.id.type === "Identifier") {
          declarations.push(
            declarator(declarator2.id, create_state_declarator(declarator2.id, value))
          );
        } else {
          const tmp = context.state.scope.generate("tmp");
          const paths = extract_paths(declarator2.id);
          declarations.push(
            declarator(id(tmp), value),
            ...paths.map((path) => {
              var _a3;
              const value2 = (_a3 = path.expression) == null ? void 0 : _a3.call(path, id(tmp));
              const binding = context.state.scope.get(
                /** @type {Identifier} */
                path.node.name
              );
              return declarator(
                path.node,
                (binding == null ? void 0 : binding.kind) === "state" || (binding == null ? void 0 : binding.kind) === "raw_state" ? create_state_declarator(binding.node, value2) : value2
              );
            })
          );
        }
        continue;
      }
      if (rune === "$derived" || rune === "$derived.by") {
        if (declarator2.id.type === "Identifier") {
          declarations.push(
            declarator(
              declarator2.id,
              call("$.derived", rune === "$derived.by" ? value : thunk(value))
            )
          );
        } else {
          const bindings = extract_paths(declarator2.id);
          const init3 = (
            /** @type {CallExpression} */
            declarator2.init
          );
          let id2;
          let rhs = value;
          if (rune === "$derived" && init3.arguments[0].type === "Identifier") {
            id2 = init3.arguments[0];
          } else {
            id2 = id(context.state.scope.generate("$$d"));
            rhs = call("$.get", id2);
            declarations.push(
              declarator(id2, call("$.derived", rune === "$derived.by" ? value : thunk(value)))
            );
          }
          for (let i = 0; i < bindings.length; i++) {
            const binding = bindings[i];
            declarations.push(
              declarator(binding.node, call("$.derived", thunk(binding.expression(rhs))))
            );
          }
        }
        continue;
      }
    }
  } else {
    for (const declarator2 of node.declarations) {
      const bindings = (
        /** @type {Binding[]} */
        context.state.scope.get_bindings(declarator2)
      );
      const has_state = bindings.some((binding) => binding.kind === "state");
      const has_props = bindings.some((binding) => binding.kind === "bindable_prop");
      if (!has_state && !has_props) {
        const init2 = declarator2.init;
        if (init2 != null && is_hoisted_function(init2)) {
          context.state.hoisted.push(
            const_builder(
              declarator2.id,
              /** @type {Expression} */
              context.visit(init2)
            )
          );
          continue;
        }
        declarations.push(
          /** @type {VariableDeclarator} */
          context.visit(declarator2)
        );
        continue;
      }
      if (has_props) {
        if (declarator2.id.type !== "Identifier") {
          const tmp = context.state.scope.generate("tmp");
          const paths = extract_paths(declarator2.id);
          declarations.push(
            declarator(
              id(tmp),
              /** @type {Expression} */
              context.visit(
                /** @type {Expression} */
                declarator2.init
              )
            )
          );
          for (const path of paths) {
            const name = (
              /** @type {Identifier} */
              path.node.name
            );
            const binding2 = (
              /** @type {Binding} */
              context.state.scope.get(name)
            );
            const value = (_a2 = path.expression) == null ? void 0 : _a2.call(path, id(tmp));
            declarations.push(
              declarator(
                path.node,
                binding2.kind === "bindable_prop" ? get_prop_source(binding2, context.state, binding2.prop_alias ?? name, value) : value
              )
            );
          }
          continue;
        }
        const binding = (
          /** @type {Binding} */
          context.state.scope.get(declarator2.id.name)
        );
        declarations.push(
          declarator(
            declarator2.id,
            get_prop_source(
              binding,
              context.state,
              binding.prop_alias ?? declarator2.id.name,
              declarator2.init && /** @type {Expression} */
              context.visit(declarator2.init)
            )
          )
        );
        continue;
      }
      declarations.push(
        ...create_state_declarators2(
          declarator2,
          context.state,
          /** @type {Expression} */
          declarator2.init && context.visit(declarator2.init)
        )
      );
    }
  }
  if (declarations.length === 0) {
    return empty;
  }
  return {
    ...node,
    declarations
  };
}
function create_state_declarators2(declarator2, { scope, analysis }, value) {
  if (declarator2.id.type === "Identifier") {
    return [
      declarator(
        declarator2.id,
        call("$.mutable_source", value, analysis.immutable ? true_instance : void 0)
      )
    ];
  }
  const tmp = scope.generate("tmp");
  const paths = extract_paths(declarator2.id);
  return [
    declarator(id(tmp), value),
    ...paths.map((path) => {
      var _a2;
      const value2 = (_a2 = path.expression) == null ? void 0 : _a2.call(path, id(tmp));
      const binding = scope.get(
        /** @type {Identifier} */
        path.node.name
      );
      return declarator(
        path.node,
        (binding == null ? void 0 : binding.kind) === "state" ? call("$.mutable_source", value2, analysis.immutable ? true_instance : void 0) : value2
      );
    })
  ];
}

// node_modules/svelte/src/compiler/phases/3-transform/client/transform-client.js
var visitors5 = {
  _: function set_scope2(node, { next: next2, state }) {
    const scope = state.scopes.get(node);
    if (scope && scope !== state.scope) {
      const transform = { ...state.transform };
      for (const [name, binding] of scope.declarations) {
        if (binding.kind === "normal" || // Reads of `$state(...)` declarations are not
        // transformed if they are never reassigned
        binding.kind === "state" && !is_state_source(binding, state.analysis)) {
          delete transform[name];
        }
      }
      next2({ ...state, transform, scope });
    } else {
      next2();
    }
  },
  AnimateDirective,
  ArrowFunctionExpression: ArrowFunctionExpression2,
  AssignmentExpression: AssignmentExpression3,
  Attribute: Attribute2,
  AwaitBlock: AwaitBlock3,
  BinaryExpression,
  BindDirective: BindDirective2,
  BlockStatement,
  BreakStatement,
  CallExpression: CallExpression3,
  ClassBody: ClassBody3,
  Comment,
  Component: Component3,
  ConstTag: ConstTag3,
  DebugTag: DebugTag3,
  EachBlock: EachBlock3,
  ExportNamedDeclaration: ExportNamedDeclaration2,
  ExpressionStatement: ExpressionStatement3,
  Fragment: Fragment2,
  FunctionDeclaration: FunctionDeclaration2,
  FunctionExpression: FunctionExpression2,
  HtmlTag: HtmlTag3,
  Identifier: Identifier3,
  IfBlock: IfBlock3,
  ImportDeclaration: ImportDeclaration2,
  KeyBlock: KeyBlock3,
  LabeledStatement: LabeledStatement3,
  LetDirective: LetDirective2,
  MemberExpression: MemberExpression3,
  OnDirective: OnDirective2,
  Program,
  RegularElement: RegularElement3,
  RenderTag: RenderTag3,
  SlotElement: SlotElement3,
  SnippetBlock: SnippetBlock3,
  SpreadAttribute: SpreadAttribute3,
  SvelteBody: SvelteBody2,
  SvelteComponent: SvelteComponent3,
  SvelteDocument: SvelteDocument2,
  SvelteElement: SvelteElement3,
  SvelteFragment: SvelteFragment3,
  SvelteBoundary: SvelteBoundary3,
  SvelteHead: SvelteHead3,
  SvelteSelf: SvelteSelf3,
  SvelteWindow: SvelteWindow2,
  TitleElement: TitleElement3,
  TransitionDirective: TransitionDirective2,
  UpdateExpression: UpdateExpression3,
  UseDirective: UseDirective2,
  VariableDeclaration: VariableDeclaration2
};
function client_component(analysis, options) {
  var _a2;
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    is_instance: false,
    hoisted: [import_all("$", "svelte/internal/client")],
    node: (
      /** @type {any} */
      null
    ),
    // populated by the root node
    legacy_reactive_imports: [],
    legacy_reactive_statements: /* @__PURE__ */ new Map(),
    metadata: {
      context: {
        template_needs_import_node: false,
        template_contains_script_tag: false
      },
      namespace: options.namespace,
      bound_contenteditable: false
    },
    events: /* @__PURE__ */ new Set(),
    preserve_whitespace: options.preserveWhitespace,
    public_state: /* @__PURE__ */ new Map(),
    private_state: /* @__PURE__ */ new Map(),
    transform: {},
    in_constructor: false,
    instance_level_snippets: [],
    module_level_snippets: [],
    // these are set inside the `Fragment` visitor, and cannot be used until then
    init: (
      /** @type {any} */
      null
    ),
    update: (
      /** @type {any} */
      null
    ),
    expressions: (
      /** @type {any} */
      null
    ),
    after_update: (
      /** @type {any} */
      null
    ),
    template: (
      /** @type {any} */
      null
    ),
    locations: (
      /** @type {any} */
      null
    )
  };
  const module = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.module.ast,
      state,
      visitors5
    )
  );
  const instance_state = {
    ...state,
    transform: { ...state.transform },
    scope: analysis.instance.scope,
    scopes: analysis.instance.scopes,
    is_instance: true
  };
  const instance = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.instance.ast,
      instance_state,
      visitors5
    )
  );
  const template3 = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.template.ast,
      {
        ...state,
        transform: instance_state.transform,
        scope: analysis.instance.scope,
        scopes: analysis.template.scopes
      },
      visitors5
    )
  );
  module.body.unshift(...state.legacy_reactive_imports);
  const store_setup = [];
  const legacy_reactive_declarations = [];
  let needs_store_cleanup = false;
  for (const [name, binding] of analysis.instance.scope.declarations) {
    if (binding.kind === "legacy_reactive") {
      legacy_reactive_declarations.push(
        const_builder(
          name,
          call("$.mutable_source", void 0, analysis.immutable ? true_instance : void 0)
        )
      );
    }
    if (binding.kind === "store_sub") {
      if (store_setup.length === 0) {
        needs_store_cleanup = true;
        store_setup.push(
          const_builder(array_pattern([id("$$stores"), id("$$cleanup")]), call("$.setup_stores"))
        );
      }
      const store_reference = build_getter(id(name.slice(1)), instance_state);
      const store_get = call("$.store_get", store_reference, literal(name), id("$$stores"));
      store_setup.push(
        const_builder(
          binding.node,
          dev ? thunk(
            sequence([
              call("$.validate_store", store_reference, literal(name.slice(1))),
              store_get
            ])
          ) : thunk(store_get)
        )
      );
    }
  }
  for (const [node] of analysis.reactive_statements) {
    const statement = [...state.legacy_reactive_statements].find(([n]) => n === node);
    if (statement === void 0) {
      throw new Error("Could not find reactive statement");
    }
    instance.body.push(statement[1]);
  }
  if (analysis.reactive_statements.size > 0) {
    instance.body.push(stmt(call("$.legacy_pre_effect_reset")));
  }
  const group_binding_declarations = [];
  for (const group of analysis.binding_groups.values()) {
    group_binding_declarations.push(const_builder(group.name, array([])));
  }
  const component_returned_object = analysis.exports.flatMap(({ name, alias }) => {
    const binding = instance_state.scope.get(name);
    const expression = build_getter(id(name), instance_state);
    const getter = get(alias ?? name, [return_builder(expression)]);
    if (expression.type === "Identifier") {
      if ((binding == null ? void 0 : binding.declaration_kind) === "let" || (binding == null ? void 0 : binding.declaration_kind) === "var") {
        return [
          getter,
          set(alias ?? name, [stmt(assignment("=", expression, id("$$value")))])
        ];
      } else if (!dev) {
        return init(alias ?? name, expression);
      }
    }
    if ((binding == null ? void 0 : binding.kind) === "prop" || (binding == null ? void 0 : binding.kind) === "bindable_prop") {
      return [getter, set(alias ?? name, [stmt(call(name, id("$$value")))])];
    }
    if ((binding == null ? void 0 : binding.kind) === "state" || (binding == null ? void 0 : binding.kind) === "raw_state") {
      const value = binding.kind === "state" ? call("$.proxy", id("$$value")) : id("$$value");
      return [getter, set(alias ?? name, [stmt(call("$.set", id(name), value))])];
    }
    return getter;
  });
  const properties = [...analysis.instance.scope.declarations].filter(
    ([name, binding]) => (binding.kind === "prop" || binding.kind === "bindable_prop") && !name.startsWith("$$")
  );
  if (analysis.accessors) {
    for (const [name, binding] of properties) {
      const key2 = binding.prop_alias ?? name;
      const getter = get(key2, [return_builder(call(id(name)))]);
      const setter = set(key2, [
        stmt(call(id(name), id("$$value"))),
        stmt(call("$.flush"))
      ]);
      if (analysis.runes && binding.initial) {
        setter.value.params[0] = {
          type: "AssignmentPattern",
          left: id("$$value"),
          right: (
            /** @type {ESTree.Expression} */
            binding.initial
          )
        };
      }
      component_returned_object.push(getter, setter);
    }
  }
  if (options.compatibility.componentApi === 4) {
    component_returned_object.push(
      init("$set", id("$.update_legacy_props")),
      init(
        "$on",
        arrow(
          [id("$$event_name"), id("$$event_cb")],
          call(
            "$.add_legacy_event_listener",
            id("$$props"),
            id("$$event_name"),
            id("$$event_cb")
          )
        )
      )
    );
  } else if (dev) {
    component_returned_object.push(spread(call(id("$.legacy_api"))));
  }
  const push_args = [id("$$props"), literal(analysis.runes)];
  if (dev) push_args.push(id(analysis.name));
  const component_block = block([
    ...store_setup,
    ...legacy_reactive_declarations,
    ...group_binding_declarations,
    ...state.instance_level_snippets,
    .../** @type {ESTree.Statement[]} */
    instance.body,
    analysis.runes || !analysis.needs_context ? empty : stmt(call("$.init", analysis.immutable ? true_instance : void 0)),
    .../** @type {ESTree.Statement[]} */
    template3.body
  ]);
  if (!analysis.runes) {
    for (const { name, alias } of analysis.exports) {
      component_block.body.push(
        stmt(
          call(
            "$.bind_prop",
            id("$$props"),
            literal(alias ?? name),
            build_getter(id(name), instance_state)
          )
        )
      );
    }
  }
  if (analysis.css.ast !== null && analysis.inject_styles) {
    const hash2 = literal(analysis.css.hash);
    const code = literal(render_stylesheet(analysis.source, analysis, options).code);
    state.hoisted.push(const_builder("$$css", object([init("hash", hash2), init("code", code)])));
    component_block.body.unshift(
      stmt(call("$.append_styles", id("$$anchor"), id("$$css")))
    );
  }
  if (analysis.needs_mutation_validation) {
    component_block.body.unshift(
      var_builder("$$ownership_validator", call("$.create_ownership_validator", id("$$props")))
    );
  }
  const should_inject_context = dev || analysis.needs_context || analysis.reactive_statements.size > 0 || component_returned_object.length > 0;
  if (should_inject_context) {
    component_block.body.unshift(stmt(call("$.push", ...push_args)));
    let to_push;
    if (component_returned_object.length > 0) {
      let pop_call = call("$.pop", object(component_returned_object));
      to_push = needs_store_cleanup ? var_builder("$$pop", pop_call) : return_builder(pop_call);
    } else {
      to_push = stmt(call("$.pop"));
    }
    component_block.body.push(to_push);
  }
  if (needs_store_cleanup) {
    component_block.body.push(stmt(call("$$cleanup")));
    if (component_returned_object.length > 0) {
      component_block.body.push(return_builder(id("$$pop")));
    }
  }
  if (analysis.uses_rest_props) {
    const named_props = analysis.exports.map(({ name, alias }) => alias ?? name);
    for (const [name, binding] of analysis.instance.scope.declarations) {
      if (binding.kind === "bindable_prop") named_props.push(binding.prop_alias ?? name);
    }
    component_block.body.unshift(
      const_builder(
        "$$restProps",
        call(
          "$.legacy_rest_props",
          id("$$sanitized_props"),
          array(named_props.map((name) => literal(name)))
        )
      )
    );
  }
  if (analysis.uses_props || analysis.uses_rest_props) {
    const to_remove = [
      literal("children"),
      literal("$$slots"),
      literal("$$events"),
      literal("$$legacy")
    ];
    if (analysis.custom_element) {
      to_remove.push(literal("$$host"));
    }
    component_block.body.unshift(
      const_builder(
        "$$sanitized_props",
        call("$.legacy_rest_props", id("$$props"), array(to_remove))
      )
    );
  }
  if (analysis.uses_slots) {
    component_block.body.unshift(const_builder("$$slots", call("$.sanitize_slots", id("$$props"))));
  }
  let should_inject_props = should_inject_context || analysis.needs_props || analysis.uses_props || analysis.uses_rest_props || analysis.uses_slots || analysis.slot_names.size > 0;
  const imports2 = [];
  let body = [];
  for (const entry of [...module.body, ...state.hoisted]) {
    if (entry.type === "ImportDeclaration") {
      imports2.push(entry);
    } else {
      body.push(entry);
    }
  }
  body = [...imports2, ...state.module_level_snippets, ...body];
  const component = function_declaration(
    id(analysis.name),
    should_inject_props ? [id("$$anchor"), id("$$props")] : [id("$$anchor")],
    component_block
  );
  if (options.hmr) {
    const id2 = id(analysis.name);
    const HMR = id("$.HMR");
    const existing = member(id2, HMR, true);
    const incoming = member(id("module.default"), HMR, true);
    const accept_fn_body = [
      stmt(assignment("=", member(incoming, "source"), member(existing, "source"))),
      stmt(call("$.set", member(existing, "source"), member(incoming, "original")))
    ];
    if (analysis.css.hash) {
      accept_fn_body.unshift(stmt(call("$.cleanup_styles", literal(analysis.css.hash))));
    }
    const hmr = block([
      stmt(assignment("=", id2, call("$.hmr", id2, thunk(member(existing, "source"))))),
      stmt(call("import.meta.hot.accept", arrow([id("module")], block(accept_fn_body))))
    ]);
    body.push(component, if_builder(id("import.meta.hot"), hmr), export_default(id(analysis.name)));
  } else {
    body.push(export_default(component));
  }
  if (dev) {
    body.unshift(
      stmt(
        assignment("=", member(id(analysis.name), "$.FILENAME", true), literal(filename))
      )
    );
  }
  if (!analysis.runes) {
    body.unshift(imports([], "svelte/internal/flags/legacy"));
  }
  if (analysis.tracing) {
    body.unshift(imports([], "svelte/internal/flags/tracing"));
  }
  if (options.discloseVersion) {
    body.unshift(imports([], "svelte/internal/disclose-version"));
  }
  if (options.compatibility.componentApi === 4) {
    body.unshift(imports([["createClassComponent", "$$_createClassComponent"]], "svelte/legacy"));
    component_block.body.unshift(
      if_builder(
        id("new.target"),
        return_builder(
          call(
            "$$_createClassComponent",
            // When called with new, the first argument is the constructor options
            object([init("component", id(analysis.name)), spread(id("$$anchor"))])
          )
        )
      )
    );
  } else if (dev) {
    component_block.body.unshift(stmt(call("$.check_target", id("new.target"))));
  }
  if (analysis.props_id) {
    component_block.body.unshift(const_builder(analysis.props_id, call("$.props_id")));
  }
  if (state.events.size > 0) {
    body.push(
      stmt(call("$.delegate", array(Array.from(state.events).map((name) => literal(name)))))
    );
  }
  if (analysis.custom_element) {
    const ce = analysis.custom_element;
    const ce_props = typeof ce === "boolean" ? {} : ce.props || {};
    const props_str = [];
    for (const [name, prop_def2] of Object.entries(ce_props)) {
      const binding = analysis.instance.scope.get(name);
      const key2 = (binding == null ? void 0 : binding.prop_alias) ?? name;
      if (!prop_def2.type && ((_a2 = binding == null ? void 0 : binding.initial) == null ? void 0 : _a2.type) === "Literal" && typeof (binding == null ? void 0 : binding.initial.value) === "boolean") {
        prop_def2.type = "Boolean";
      }
      const value = object(
        /** @type {ESTree.Property[]} */
        [
          prop_def2.attribute ? init("attribute", literal(prop_def2.attribute)) : void 0,
          prop_def2.reflect ? init("reflect", true_instance) : void 0,
          prop_def2.type ? init("type", literal(prop_def2.type)) : void 0
        ].filter(Boolean)
      );
      props_str.push(init(key2, value));
    }
    for (const [name, binding] of properties) {
      const key2 = binding.prop_alias ?? name;
      if (ce_props[key2]) continue;
      props_str.push(init(key2, object([])));
    }
    const slots_str = array([...analysis.slot_names.keys()].map((name) => literal(name)));
    const accessors_str = array(
      analysis.exports.map(({ name, alias }) => literal(alias ?? name))
    );
    const use_shadow_dom = typeof ce === "boolean" || ce.shadow !== "none" ? true : false;
    const create_ce = call(
      "$.create_custom_element",
      id(analysis.name),
      object(props_str),
      slots_str,
      accessors_str,
      literal(use_shadow_dom),
      /** @type {any} */
      typeof ce !== "boolean" ? ce.extend : void 0
    );
    if (typeof ce !== "boolean" && typeof ce.tag === "string") {
      const define = stmt(call("customElements.define", literal(ce.tag), create_ce));
      if (options.hmr) {
        body.push(
          if_builder(binary("==", call("customElements.get", literal(ce.tag)), null_instance), define)
        );
      } else {
        body.push(define);
      }
    } else {
      body.push(stmt(create_ce));
    }
  }
  return {
    type: "Program",
    sourceType: "module",
    body
  };
}
function client_module(analysis, options) {
  const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    public_state: /* @__PURE__ */ new Map(),
    private_state: /* @__PURE__ */ new Map(),
    transform: {},
    in_constructor: false
  };
  const module = (
    /** @type {ESTree.Program} */
    walk(
      /** @type {AST.SvelteNode} */
      analysis.module.ast,
      state,
      visitors5
    )
  );
  const body = [import_all("$", "svelte/internal/client")];
  if (analysis.tracing) {
    body.push(imports([], "svelte/internal/flags/tracing"));
  }
  return {
    type: "Program",
    sourceType: "module",
    body: [...body, ...module.body]
  };
}

// node_modules/svelte/src/compiler/phases/3-transform/index.js
function transform_component(analysis, source2, options) {
  if (options.generate === false) {
    return {
      js: (
        /** @type {any} */
        null
      ),
      css: null,
      warnings,
      // set afterwards
      metadata: {
        runes: analysis.runes
      },
      ast: (
        /** @type {any} */
        null
      )
      // set afterwards
    };
  }
  const program = options.generate === "server" ? server_component(analysis, options) : client_component(analysis, options);
  const js_source_name = get_source_name(options.filename, options.outputFilename, "input.svelte");
  const js2 = print(program, {
    // include source content; makes it easier/more robust looking up the source map code
    // (else esrap does return null for source and sourceMapContent which may trip up tooling)
    sourceMapContent: source2,
    sourceMapSource: js_source_name
  });
  merge_with_preprocessor_map(js2, options, js_source_name);
  const css = analysis.css.ast && !analysis.inject_styles ? render_stylesheet(source2, analysis, options) : null;
  return {
    js: js2,
    css,
    warnings,
    // set afterwards. TODO apply preprocessor sourcemap
    metadata: {
      runes: analysis.runes
    },
    ast: (
      /** @type {any} */
      null
    )
    // set afterwards
  };
}
function transform_module(analysis, source2, options) {
  if (options.generate === false) {
    return {
      js: (
        /** @type {any} */
        null
      ),
      css: null,
      warnings,
      // set afterwards
      metadata: {
        runes: true
      },
      ast: (
        /** @type {any} */
        null
      )
      // set afterwards
    };
  }
  const program = options.generate === "server" ? server_module(analysis, options) : client_module(analysis, options);
  const basename = options.filename.split(/[/\\]/).at(-1);
  if (program.body.length > 0) {
    program.body[0].leadingComments = [
      {
        type: "Block",
        value: ` ${basename} generated by Svelte v${VERSION} `
      }
    ];
  }
  return {
    js: print(program, {
      // include source content; makes it easier/more robust looking up the source map code
      // (else esrap does return null for source and sourceMapContent which may trip up tooling)
      sourceMapContent: source2,
      sourceMapSource: get_source_name(options.filename, void 0, "input.svelte.js")
    }),
    css: null,
    metadata: {
      runes: true
    },
    warnings,
    // set afterwards
    ast: (
      /** @type {any} */
      null
    )
    // set afterwards
  };
}

// node_modules/svelte/src/compiler/validate-options.js
var _a;
var common = {
  filename: string("(unknown)"),
  // default to process.cwd() where it exists to replicate svelte4 behavior (and make Deno work with this as well)
  // see https://github.com/sveltejs/svelte/blob/b62fc8c8fd2640c9b99168f01b9d958cb2f7574f/packages/svelte/src/compiler/compile/Component.js#L211
  /* eslint-disable */
  rootDir: string(
    typeof process !== "undefined" ? (_a = process.cwd) == null ? void 0 : _a.call(process) : (
      // @ts-expect-error
      typeof Deno !== "undefined" ? (
        // @ts-expect-error
        Deno.cwd()
      ) : void 0
    )
  ),
  /* eslint-enable */
  dev: boolean(false),
  generate: validator("client", (input, keypath) => {
    if (input === "dom" || input === "ssr") {
      warn_once(options_renamed_ssr_dom);
      return input === "dom" ? "client" : "server";
    }
    if (input !== "client" && input !== "server" && input !== false) {
      throw_error2(`${keypath} must be "client", "server" or false`);
    }
    return input;
  }),
  warningFilter: fun(() => true)
};
var validate_module_options = (
  /** @type {Validator<ModuleCompileOptions, ValidatedModuleCompileOptions>} */
  object3({
    ...common
  })
);
var validate_component_options = (
  /** @type {Validator<CompileOptions, ValidatedCompileOptions>} */
  object3({
    ...common,
    accessors: deprecate(options_deprecated_accessors, boolean(false)),
    css: validator("external", (input) => {
      if (input === true || input === false) {
        throw_error2(
          'The boolean options have been removed from the css option. Use "external" instead of false and "injected" instead of true'
        );
      }
      if (input === "none") {
        throw_error2(
          'css: "none" is no longer a valid option. If this was crucial for you, please open an issue on GitHub with your use case.'
        );
      }
      if (input !== "external" && input !== "injected") {
        throw_error2(`css should be either "external" (default, recommended) or "injected"`);
      }
      return input;
    }),
    cssHash: fun(({ css, hash: hash2 }) => {
      return `svelte-${hash2(css)}`;
    }),
    // TODO this is a sourcemap option, would be good to put under a sourcemap namespace
    cssOutputFilename: string(void 0),
    customElement: boolean(false),
    discloseVersion: boolean(true),
    immutable: deprecate(options_deprecated_immutable, boolean(false)),
    legacy: removed(
      "The legacy option has been removed. If you are using this because of legacy.componentApi, use compatibility.componentApi instead"
    ),
    compatibility: object3({
      componentApi: list2([4, 5], 5)
    }),
    loopGuardTimeout: warn_removed(options_removed_loop_guard_timeout),
    name: string(void 0),
    namespace: list2(["html", "mathml", "svg"]),
    modernAst: boolean(false),
    outputFilename: string(void 0),
    preserveComments: boolean(false),
    preserveWhitespace: boolean(false),
    runes: boolean(void 0),
    hmr: boolean(false),
    sourcemap: validator(void 0, (input) => {
      return input;
    }),
    enableSourcemap: warn_removed(options_removed_enable_sourcemap),
    hydratable: warn_removed(options_removed_hydratable),
    format: removed(
      'The format option has been removed in Svelte 4, the compiler only outputs ESM now. Remove "format" from your compiler options. If you did not set this yourself, bump the version of your bundler plugin (vite-plugin-svelte/rollup-plugin-svelte/svelte-loader)'
    ),
    tag: removed(
      'The tag option has been removed in Svelte 5. Use `<svelte:options customElement="tag-name" />` inside the component instead. If that does not solve your use case, please open an issue on GitHub with details.'
    ),
    sveltePath: removed(
      "The sveltePath option has been removed in Svelte 5. If this option was crucial for you, please open an issue on GitHub with your use case."
    ),
    // These two were primarily created for svelte-preprocess (https://github.com/sveltejs/svelte/pull/6194),
    // but with new TypeScript compilation modes strictly separating types it's not necessary anymore
    errorMode: removed(
      "The errorMode option has been removed. If you are using this through svelte-preprocess with TypeScript, use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead"
    ),
    varsReport: removed(
      "The vars option has been removed. If you are using this through svelte-preprocess with TypeScript, use the https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax setting instead"
    )
  })
);
function removed(msg) {
  return (input) => {
    if (input !== void 0) {
      options_removed(null, msg);
    }
    return (
      /** @type {any} */
      void 0
    );
  };
}
var warned = /* @__PURE__ */ new Set();
function warn_once(fn) {
  if (!warned.has(fn)) {
    warned.add(fn);
    fn(null);
  }
}
function warn_removed(fn) {
  return (input) => {
    if (input !== void 0) warn_once(fn);
    return (
      /** @type {any} */
      void 0
    );
  };
}
function deprecate(fn, validator2) {
  return (input, keypath) => {
    if (input !== void 0) warn_once(fn);
    return validator2(input, keypath);
  };
}
function object3(children, allow_unknown = false) {
  return (input, keypath) => {
    const output = {};
    if (input && typeof input !== "object" || Array.isArray(input)) {
      throw_error2(`${keypath} should be an object`);
    }
    for (const key2 in input) {
      if (!(key2 in children)) {
        if (allow_unknown) {
          output[key2] = input[key2];
        } else {
          options_unrecognised(null, `${keypath ? `${keypath}.${key2}` : key2}`);
        }
      }
    }
    for (const key2 in children) {
      const validator2 = children[key2];
      output[key2] = validator2(input && input[key2], keypath ? `${keypath}.${key2}` : key2);
    }
    return output;
  };
}
function validator(fallback, fn) {
  return (input, keypath) => {
    return input === void 0 ? fallback : fn(input, keypath);
  };
}
function string(fallback, allow_empty = true) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "string") {
      throw_error2(`${keypath} should be a string, if specified`);
    }
    if (!allow_empty && input === "") {
      throw_error2(`${keypath} cannot be empty`);
    }
    return input;
  });
}
function boolean(fallback) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "boolean") {
      throw_error2(`${keypath} should be true or false, if specified`);
    }
    return input;
  });
}
function list2(options, fallback = options[0]) {
  return validator(fallback, (input, keypath) => {
    if (!options.includes(input)) {
      const msg = options.length > 2 ? `${keypath} should be one of ${options.slice(0, -1).map((input2) => `"${input2}"`).join(", ")} or "${options[options.length - 1]}"` : `${keypath} should be either "${options[0]}" or "${options[1]}"`;
      throw_error2(msg);
    }
    return input;
  });
}
function fun(fallback) {
  return validator(fallback, (input, keypath) => {
    if (typeof input !== "function") {
      throw_error2(`${keypath} should be a function, if specified`);
    }
    return input;
  });
}
function throw_error2(msg) {
  options_invalid_value(null, msg);
}

// node_modules/svelte/src/compiler/preprocess/decode_sourcemap.js
var import_sourcemap_codec = __toESM(require_sourcemap_codec_umd(), 1);
function decoded_sourcemap_from_generator(generator) {
  let previous_generated_line = 1;
  const converted_mappings = [[]];
  let result_line = converted_mappings[0];
  let result_segment;
  let mapping;
  const source_idx = generator._sources.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const name_idx = generator._names.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
  const mappings = generator._mappings.toArray();
  for (let i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    if (mapping.generatedLine > previous_generated_line) {
      while (mapping.generatedLine > previous_generated_line) {
        converted_mappings.push([]);
        previous_generated_line++;
      }
      result_line = converted_mappings[mapping.generatedLine - 1];
    } else if (i > 0) {
      const previous_mapping = mappings[i - 1];
      if (
        // sorted by selectivity
        mapping.generatedColumn === previous_mapping.generatedColumn && mapping.originalColumn === previous_mapping.originalColumn && mapping.name === previous_mapping.name && mapping.generatedLine === previous_mapping.generatedLine && mapping.originalLine === previous_mapping.originalLine && mapping.source === previous_mapping.source
      ) {
        continue;
      }
    }
    result_line.push([mapping.generatedColumn]);
    result_segment = result_line[result_line.length - 1];
    if (mapping.source != null) {
      result_segment.push(
        ...[source_idx[mapping.source], mapping.originalLine - 1, mapping.originalColumn]
      );
      if (mapping.name != null) {
        result_segment.push(name_idx[mapping.name]);
      }
    }
  }
  const map = {
    version: generator._version,
    sources: generator._sources.toArray(),
    names: generator._names.toArray(),
    mappings: converted_mappings
  };
  if (generator._file != null) {
    map.file = generator._file;
  }
  return map;
}
function decode_map(processed) {
  let decoded_map = typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map;
  if (typeof decoded_map.mappings === "string") {
    decoded_map.mappings = (0, import_sourcemap_codec.decode)(decoded_map.mappings);
  }
  if (decoded_map._mappings && decoded_map.constructor.name === "SourceMapGenerator") {
    decoded_map = decoded_sourcemap_from_generator(decoded_map);
  }
  return decoded_map;
}

// node_modules/svelte/src/compiler/preprocess/replace_in_code.js
function slice_source(code_slice, offset, { file_basename, filename: filename2, get_location }) {
  return {
    source: code_slice,
    get_location: (index) => get_location(index + offset),
    file_basename,
    filename: filename2
  };
}
function calculate_replacements(re, get_replacement, source2) {
  const replacements2 = [];
  source2.replace(re, (...match) => {
    replacements2.push(
      get_replacement(...match).then((replacement) => {
        const matched_string = match[0];
        const offset = match[match.length - 2];
        return { offset, length: matched_string.length, replacement };
      })
    );
    return "";
  });
  return Promise.all(replacements2);
}
function perform_replacements(replacements2, source2) {
  const out = new MappedCode();
  let last_end = 0;
  for (const { offset, length, replacement } of replacements2) {
    const unchanged_prefix = MappedCode.from_source(
      slice_source(source2.source.slice(last_end, offset), last_end, source2)
    );
    out.concat(unchanged_prefix).concat(replacement);
    last_end = offset + length;
  }
  const unchanged_suffix = MappedCode.from_source(
    slice_source(source2.source.slice(last_end), last_end, source2)
  );
  return out.concat(unchanged_suffix);
}
async function replace_in_code(regex, get_replacement, location) {
  const replacements2 = await calculate_replacements(regex, get_replacement, location.source);
  return perform_replacements(replacements2, location);
}

// node_modules/svelte/src/compiler/preprocess/index.js
var PreprocessResult = class {
  /**
   * @param {string} source
   * @param {string} [filename]
   */
  constructor(source2, filename2) {
    /** @type {string} */
    __publicField(this, "source");
    /** @type {string | undefined} The filename passed as-is to preprocess */
    __publicField(this, "filename");
    // sourcemap_list is sorted in reverse order from last map (index 0) to first map (index -1)
    // so we use sourcemap_list.unshift() to add new maps
    // https://github.com/ampproject/remapping#multiple-transformations-of-a-file
    /**
     * @default []
     * @type {Array<DecodedSourceMap | RawSourceMap>}
     */
    __publicField(this, "sourcemap_list", []);
    /**
     * @default []
     * @type {string[]}
     */
    __publicField(this, "dependencies", []);
    /**
     * @type {string | null} last part of the filename, as used for `sources` in sourcemaps
     */
    __publicField(this, "file_basename");
    /**
     * @type {ReturnType<typeof getLocator>}
     */
    __publicField(this, "get_location");
    this.source = source2;
    this.filename = filename2;
    this.update_source({ string: source2 });
    this.file_basename = filename2 == null ? null : get_basename(filename2);
  }
  /**
   * @param {SourceUpdate} opts
   */
  update_source({ string: source2, map, dependencies }) {
    if (source2 != null) {
      this.source = source2;
      this.get_location = getLocator(source2);
    }
    if (map) {
      this.sourcemap_list.unshift(map);
    }
    if (dependencies) {
      this.dependencies.push(...dependencies);
    }
  }
  /**
   * @returns {Processed}
   */
  to_processed() {
    const map = combine_sourcemaps(this.file_basename, this.sourcemap_list);
    return {
      // TODO return separated output, in future version where svelte.compile supports it:
      // style: { code: styleCode, map: styleMap },
      // script { code: scriptCode, map: scriptMap },
      // markup { code: markupCode, map: markupMap },
      code: this.source,
      dependencies: [...new Set(this.dependencies)],
      // @ts-expect-error TODO there might be a bug in hiding here
      map,
      toString: () => this.source
    };
  }
};
function processed_content_to_code(processed, location, file_basename) {
  let decoded_map = void 0;
  if (processed.map) {
    decoded_map = decode_map(processed);
    if (decoded_map == null ? void 0 : decoded_map.sources) {
      const source_index = decoded_map.sources.indexOf(file_basename);
      if (source_index !== -1) {
        sourcemap_add_offset(decoded_map, location, source_index);
      }
    }
  }
  return MappedCode.from_processed(processed.code, decoded_map);
}
function processed_tag_to_code(processed, tag_name, original_attributes, generated_attributes, source2) {
  const { file_basename, get_location } = source2;
  const build_mapped_code = (code, offset) => MappedCode.from_source(slice_source(code, offset, source2));
  const original_tag_open = `<${tag_name}${original_attributes}>`;
  const tag_open = `<${tag_name}${generated_attributes}>`;
  let tag_open_code;
  if (original_tag_open.length !== tag_open.length) {
    const mappings = [
      [
        // start of tag
        [0, 0, 0, 0],
        // end of tag start
        [`<${tag_name}`.length, 0, 0, `<${tag_name}`.length]
      ]
    ];
    const line = tag_open.split("\n").length - 1;
    const column = tag_open.length - (line === 0 ? 0 : tag_open.lastIndexOf("\n")) - 1;
    while (mappings.length <= line) {
      mappings.push([[0, 0, 0, `<${tag_name}`.length]]);
    }
    mappings[line].push([
      column,
      0,
      original_tag_open.split("\n").length - 1,
      original_tag_open.length - original_tag_open.lastIndexOf("\n") - 1
    ]);
    const map = {
      version: 3,
      names: [],
      sources: [file_basename],
      mappings
    };
    sourcemap_add_offset(map, get_location(0), 0);
    tag_open_code = MappedCode.from_processed(tag_open, map);
  } else {
    tag_open_code = build_mapped_code(tag_open, 0);
  }
  const tag_close = `</${tag_name}>`;
  const tag_close_code = build_mapped_code(
    tag_close,
    original_tag_open.length + source2.source.length
  );
  parse_attached_sourcemap(processed, tag_name);
  const content_code = processed_content_to_code(
    processed,
    get_location(original_tag_open.length),
    file_basename
  );
  return tag_open_code.concat(content_code).concat(tag_close_code);
}
var attribute_pattern = /([\w-$]+\b)(?:=(?:"([^"]*)"|'([^']*)'|(\S+)))?/g;
function parse_tag_attributes(str) {
  const attrs = {};
  let match;
  while ((match = attribute_pattern.exec(str)) !== null) {
    const name = match[1];
    const value = match[2] || match[3] || match[4];
    attrs[name] = !value || value;
  }
  return attrs;
}
function stringify_tag_attributes(attributes) {
  if (!attributes) return;
  let value = Object.entries(attributes).map(([key2, value2]) => value2 === true ? key2 : `${key2}="${value2}"`).join(" ");
  if (value) {
    value = " " + value;
  }
  return value;
}
var regex_style_tags = /<!--[^]*?-->|<style((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/style>)/g;
var regex_script_tags = /<!--[^]*?-->|<script((?:\s+[^=>'"/\s]+=(?:"[^"]*"|'[^']*'|[^>\s]+)|\s+[^=>'"/\s]+)*\s*)(?:\/>|>([\S\s]*?)<\/script>)/g;
async function process_tag(tag_name, preprocessor, source2) {
  const { filename: filename2, source: markup } = source2;
  const tag_regex = tag_name === "style" ? regex_style_tags : regex_script_tags;
  const dependencies = [];
  async function process_single_tag(tag_with_content, attributes = "", content = "", tag_offset) {
    const no_change = () => MappedCode.from_source(slice_source(tag_with_content, tag_offset, source2));
    if (!attributes && !content) return no_change();
    const processed = await preprocessor({
      content: content || "",
      attributes: parse_tag_attributes(attributes || ""),
      markup,
      filename: filename2
    });
    if (!processed) return no_change();
    if (processed.dependencies) dependencies.push(...processed.dependencies);
    if (!processed.map && processed.code === content) return no_change();
    return processed_tag_to_code(
      processed,
      tag_name,
      attributes,
      stringify_tag_attributes(processed.attributes) ?? attributes,
      slice_source(content, tag_offset, source2)
    );
  }
  const { string: string2, map } = await replace_in_code(tag_regex, process_single_tag, source2);
  return { string: string2, map, dependencies };
}
async function process_markup(process2, source2) {
  const processed = await process2({
    content: source2.source,
    filename: source2.filename
  });
  if (processed) {
    return {
      string: processed.code,
      map: processed.map ? (
        // TODO: can we use decode_sourcemap?
        typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map
      ) : void 0,
      dependencies: processed.dependencies
    };
  } else {
    return {};
  }
}
async function preprocess(source2, preprocessor, options) {
  const filename2 = options && options.filename || /** @type {any} */
  preprocessor.filename;
  const preprocessors = preprocessor ? Array.isArray(preprocessor) ? preprocessor : [preprocessor] : [];
  const result = new PreprocessResult(source2, filename2);
  for (const preprocessor2 of preprocessors) {
    if (preprocessor2.markup) {
      result.update_source(await process_markup(preprocessor2.markup, result));
    }
    if (preprocessor2.script) {
      result.update_source(await process_tag("script", preprocessor2.script, result));
    }
    if (preprocessor2.style) {
      result.update_source(await process_tag("style", preprocessor2.style, result));
    }
  }
  return result.to_processed();
}

// node_modules/svelte/src/compiler/migrate/index.js
var regex_style_tags2 = /(<style[^>]+>)([\S\s]*?)(<\/style>)/g;
var style_placeholder = "/*$$__STYLE_CONTENT__$$*/";
var has_migration_task = false;
var MigrationError = class extends Error {
  /**
   * @param {string} msg
   */
  constructor(msg) {
    super(msg);
  }
};
function migrate_css(state) {
  var _a2, _b, _c, _d;
  if (!((_a2 = state.analysis.css.ast) == null ? void 0 : _a2.start)) return;
  const css_contents = state.str.snip(
    state.analysis.css.ast.start,
    /** @type {number} */
    (_b = state.analysis.css.ast) == null ? void 0 : _b.end
  ).toString();
  let code = css_contents;
  let starting = 0;
  const str = new MagicString(code);
  while (code) {
    if (code.startsWith(":has") || code.startsWith(":is") || code.startsWith(":where") || code.startsWith(":not")) {
      let start = code.indexOf("(") + 1;
      let is_global3 = false;
      const global_str = ":global";
      const next_global = code.indexOf(global_str);
      const str_between = code.substring(start, next_global);
      if (!str_between.trim()) {
        is_global3 = true;
        start += global_str.length;
      } else {
        const prev_global = css_contents.lastIndexOf(global_str, starting);
        if (prev_global > -1) {
          const end2 = find_closing_parenthesis(css_contents.indexOf("(", prev_global) + 1, css_contents) - starting;
          if (end2 > start) {
            starting += end2;
            code = code.substring(end2);
            continue;
          }
        }
      }
      const end = find_closing_parenthesis(start, code);
      if (start && end) {
        if (!is_global3 && !code.startsWith(":not")) {
          str.prependLeft(starting + start, ":global(");
          str.appendRight(starting + end - 1, ")");
        }
        starting += end - 1;
        code = code.substring(end - 1);
        continue;
      }
    }
    starting++;
    code = code.substring(1);
  }
  state.str.update((_c = state.analysis.css.ast) == null ? void 0 : _c.start, (_d = state.analysis.css.ast) == null ? void 0 : _d.end, str.toString());
}
function find_closing_parenthesis(start, code) {
  let parenthesis = 1;
  let end = start;
  let char = code[end];
  while (parenthesis !== 0 && char) {
    if (char === "(") parenthesis++;
    if (char === ")") parenthesis--;
    end++;
    char = code[end];
  }
  return end;
}
function migrate(source2, { filename: filename2, use_ts } = {}) {
  var _a2, _b, _c;
  let og_source = source2;
  try {
    let check_rune_binding = function(rune) {
      const has_rune_binding = !!state.scope.get(rune);
      if (has_rune_binding) {
        throw new MigrationError(
          `migrating this component would require adding a \`$${rune}\` rune but there's already a variable named ${rune}.
     Rename the variable and try again or migrate by hand.`
        );
      }
    };
    has_migration_task = false;
    const style_contents = [];
    source2 = source2.replace(regex_style_tags2, (_, start, content, end, idx) => {
      style_contents.push([idx + start.length, content]);
      return start + style_placeholder + end;
    });
    reset_warning_filter(() => false);
    reset(source2, { filename: filename2 ?? "(unknown)" });
    let parsed = parse2(source2);
    const { customElement: customElementOptions, ...parsed_options } = parsed.options || {};
    const combined_options = {
      ...validate_component_options({}, ""),
      ...parsed_options,
      customElementOptions,
      filename: filename2 ?? "(unknown)"
    };
    const str = new MagicString(source2);
    const analysis = analyze_component(parsed, source2, combined_options);
    const indent = guess_indent(source2);
    str.replaceAll(/(<svelte:options\s.*?\s?)accessors\s?/g, (_, $1) => $1);
    for (const content of style_contents) {
      str.overwrite(content[0], content[0] + style_placeholder.length, content[1]);
    }
    let state = {
      scope: analysis.instance.scope,
      analysis,
      filename: filename2,
      str,
      indent,
      props: [],
      props_insertion_point: ((_a2 = parsed.instance) == null ? void 0 : _a2.content.start) ?? 0,
      has_props_rune: false,
      has_type_or_fallback: false,
      end: source2.length,
      names: {
        props: analysis.root.unique("props").name,
        rest: analysis.root.unique("rest").name,
        // event stuff
        run: analysis.root.unique("run").name,
        handlers: analysis.root.unique("handlers").name,
        stopImmediatePropagation: analysis.root.unique("stopImmediatePropagation").name,
        preventDefault: analysis.root.unique("preventDefault").name,
        stopPropagation: analysis.root.unique("stopPropagation").name,
        once: analysis.root.unique("once").name,
        self: analysis.root.unique("self").name,
        trusted: analysis.root.unique("trusted").name,
        createBubbler: analysis.root.unique("createBubbler").name,
        bubble: analysis.root.unique("bubble").name,
        passive: analysis.root.unique("passive").name,
        nonpassive: analysis.root.unique("nonpassive").name
      },
      legacy_imports: /* @__PURE__ */ new Set(),
      script_insertions: /* @__PURE__ */ new Set(),
      derived_components: /* @__PURE__ */ new Map(),
      derived_conflicting_slots: /* @__PURE__ */ new Map(),
      derived_labeled_statements: /* @__PURE__ */ new Set(),
      has_svelte_self: false,
      uses_ts: (
        // Some people could use jsdoc but have a tsconfig.json, so double-check file for jsdoc indicators
        use_ts && !source2.includes("@type {") || !!((_b = parsed.instance) == null ? void 0 : _b.attributes.some(
          (attr) => attr.name === "lang" && /** @type {any} */
          attr.value[0].data === "ts"
        ))
      )
    };
    if (parsed.module) {
      const context = parsed.module.attributes.find((attr) => attr.name === "context");
      if (context) {
        state.str.update(context.start, context.end, "module");
      }
    }
    if (parsed.instance) {
      walk(parsed.instance.content, state, instance_script);
    }
    state = { ...state, scope: analysis.template.scope };
    walk(parsed.fragment, state, template2);
    let insertion_point = parsed.instance ? (
      /** @type {number} */
      parsed.instance.content.start
    ) : 0;
    const need_script = state.legacy_imports.size > 0 || state.derived_components.size > 0 || state.derived_conflicting_slots.size > 0 || state.script_insertions.size > 0 || state.props.length > 0 || analysis.uses_rest_props || analysis.uses_props || state.has_svelte_self;
    const need_ts_tag = state.uses_ts && (!parsed.instance || !parsed.instance.attributes.some((attr) => attr.name === "lang"));
    if (!parsed.instance && need_script) {
      str.appendRight(0, need_ts_tag ? '<script lang="ts">' : "<script>");
    }
    if (state.has_svelte_self && filename2) {
      const file = filename2.split("/").pop();
      str.appendRight(
        insertion_point,
        `
${indent}import ${state.analysis.name} from './${file}';`
      );
    }
    const specifiers = [...state.legacy_imports].map((imported) => {
      const local = state.names[imported];
      return imported === local ? imported : `${imported} as ${local}`;
    });
    const legacy_import = `import { ${specifiers.join(", ")} } from 'svelte/legacy';
`;
    if (state.legacy_imports.size > 0) {
      str.appendRight(insertion_point, `
${indent}${legacy_import}`);
    }
    if (state.script_insertions.size > 0) {
      str.appendRight(
        insertion_point,
        `
${indent}${[...state.script_insertions].join(`
${indent}`)}`
      );
    }
    insertion_point = state.props_insertion_point;
    if (state.props.length > 0 || analysis.uses_rest_props || analysis.uses_props) {
      const has_many_props = state.props.length > 3;
      const newline_separator = `
${indent}${indent}`;
      const props_separator = has_many_props ? newline_separator : " ";
      let props = "";
      if (analysis.uses_props) {
        props = `...${state.names.props}`;
      } else {
        props = state.props.filter((prop2) => !prop2.type_only).map((prop2) => {
          let prop_str = prop2.local === prop2.exported ? prop2.local : `${prop2.exported}: ${prop2.local}`;
          if (prop2.bindable) {
            check_rune_binding("bindable");
            prop_str += ` = $bindable(${prop2.init})`;
          } else if (prop2.init) {
            prop_str += ` = ${prop2.init}`;
          }
          return prop_str;
        }).join(`,${props_separator}`);
        if (analysis.uses_rest_props) {
          props += `${state.props.length > 0 ? `,${props_separator}` : ""}...${state.names.rest}`;
        }
      }
      if (state.has_props_rune) {
        str.appendRight(insertion_point, ` ${props},`);
      } else {
        const type_name = state.scope.root.unique("Props").name;
        let type = "";
        if (state.has_type_or_fallback || state.props.every((prop2) => prop2.slot_name)) {
          if (state.uses_ts) {
            type = `interface ${type_name} {${newline_separator}${state.props.map((prop2) => {
              const comment = prop2.comment ? `${prop2.comment}${newline_separator}` : "";
              return `${comment}${prop2.exported}${prop2.optional ? "?" : ""}: ${prop2.type};${prop2.trailing_comment ? " " + prop2.trailing_comment : ""}`;
            }).join(newline_separator)}`;
            if (analysis.uses_props || analysis.uses_rest_props) {
              type += `${state.props.length > 0 ? newline_separator : ""}[key: string]: any`;
            }
            type += `
${indent}}`;
          } else {
            type = `/**
${indent} * @typedef {Object} ${type_name}${state.props.map((prop2) => {
              return `
${indent} * @property {${prop2.type}} ${prop2.optional ? `[${prop2.exported}]` : prop2.exported}${prop2.comment ? ` - ${prop2.comment}` : ""}${prop2.trailing_comment ? ` - ${prop2.trailing_comment.trim()}` : ""}`;
            }).join(``)}
${indent} */`;
          }
        }
        let props_declaration = `let {${props_separator}${props}${has_many_props ? `
${indent}` : " "}}`;
        if (state.uses_ts) {
          if (type) {
            props_declaration = `${type}

${indent}${props_declaration}`;
          }
          check_rune_binding("props");
          props_declaration = `${props_declaration}${type ? `: ${type_name}` : ""} = $props();`;
        } else {
          if (type) {
            props_declaration = `${state.props.length > 0 ? `${type}

${indent}` : ""}/** @type {${state.props.length > 0 ? type_name : ""}${analysis.uses_props || analysis.uses_rest_props ? `${state.props.length > 0 ? " & " : ""}{ [key: string]: any }` : ""}} */
${indent}${props_declaration}`;
          }
          check_rune_binding("props");
          props_declaration = `${props_declaration} = $props();`;
        }
        props_declaration = `
${indent}${props_declaration}`;
        str.appendRight(insertion_point, props_declaration);
      }
      if (parsed.instance && need_ts_tag) {
        str.appendRight(parsed.instance.start + "<script".length, ' lang="ts"');
      }
    }
    let needs_reordering = false;
    for (const [node, { dependencies }] of state.analysis.reactive_statements) {
      let ids = [];
      if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
        ids = extract_identifiers(node.body.expression.left).map((id2) => state.scope.get(id2.name)).filter((id2) => !!id2);
      }
      if (dependencies.some(
        (dep) => !ids.includes(dep) && (dep.kind === "prop" || dep.kind === "bindable_prop" ? state.props_insertion_point : (
          /** @type {number} */
          dep.node.start
        )) > /** @type {number} */
        node.start
      )) {
        needs_reordering = true;
        break;
      }
    }
    if (needs_reordering) {
      const nodes = Array.from(state.analysis.reactive_statements.keys());
      for (const node of nodes) {
        const { start, end } = get_node_range(source2, node);
        str.appendLeft(end, "\n");
        str.move(
          start,
          end,
          /** @type {number} */
          (_c = parsed.instance) == null ? void 0 : _c.content.end
        );
        str.update(start - (source2[start - 2] === "\r" ? 2 : 1), start, "");
      }
    }
    insertion_point = parsed.instance ? (
      /** @type {number} */
      parsed.instance.content.end
    ) : insertion_point;
    if (state.derived_components.size > 0) {
      check_rune_binding("derived");
      str.appendRight(
        insertion_point,
        `
${indent}${[...state.derived_components.entries()].map(([init2, name]) => `const ${name} = $derived(${init2});`).join(`
${indent}`)}
`
      );
    }
    if (state.derived_conflicting_slots.size > 0) {
      check_rune_binding("derived");
      str.appendRight(
        insertion_point,
        `
${indent}${[...state.derived_conflicting_slots.entries()].map(([name, init2]) => `const ${name} = $derived(${init2});`).join(`
${indent}`)}
`
      );
    }
    if (state.props.length > 0 && state.analysis.accessors) {
      str.appendRight(
        insertion_point,
        `
${indent}export {${state.props.reduce((acc, prop2) => prop2.slot_name || prop2.type_only ? acc : `${acc}
${indent}	${prop2.local},`, "")}
${indent}}
`
      );
    }
    if (!parsed.instance && need_script) {
      str.appendRight(insertion_point, "\n<\/script>\n\n");
    }
    migrate_css(state);
    return {
      code: str.toString()
    };
  } catch (e2) {
    if (!(e2 instanceof MigrationError)) {
      console.error("Error while migrating Svelte code", e2);
    }
    has_migration_task = true;
    return {
      code: `<!-- @migration-task Error while migrating Svelte code: ${/** @type {any} */
      e2.message} -->
${og_source}`
    };
  } finally {
    if (has_migration_task) {
      console.log(
        `One or more \`@migration-task\` comments were added to ${filename2 ? `\`${filename2}\`` : "a file (unfortunately we don't know the name)"}, please check them and complete the migration manually.`
      );
    }
  }
}
var instance_script = {
  _(node, { state, next: next2 }) {
    const comments = node.leadingComments;
    if (comments) {
      for (const comment of comments) {
        if (comment.type === "Line") {
          const migrated = migrate_svelte_ignore(comment.value);
          if (migrated !== comment.value) {
            state.str.overwrite(comment.start + "//".length, comment.end, migrated);
          }
        }
      }
    }
    next2();
  },
  Identifier(node, { state, path }) {
    handle_identifier(node, state, path);
  },
  ImportDeclaration(node, { state }) {
    state.props_insertion_point = node.end ?? state.props_insertion_point;
    if (node.source.value === "svelte") {
      let illegal_specifiers = [];
      let removed_specifiers = 0;
      for (let specifier of node.specifiers) {
        if (specifier.type === "ImportSpecifier" && specifier.imported.type === "Identifier" && ["beforeUpdate", "afterUpdate"].includes(specifier.imported.name)) {
          const references = state.scope.references.get(specifier.local.name);
          if (!references) {
            let end = (
              /** @type {number} */
              state.str.original.indexOf(",", specifier.end) !== -1 && state.str.original.indexOf(",", specifier.end) < state.str.original.indexOf("}", specifier.end) ? state.str.original.indexOf(",", specifier.end) + 1 : specifier.end
            );
            while (state.str.original[end].trim() === "") end++;
            state.str.remove(
              /** @type {number} */
              specifier.start,
              end
            );
            removed_specifiers++;
            continue;
          }
          illegal_specifiers.push(specifier.imported.name);
        }
      }
      if (removed_specifiers === node.specifiers.length) {
        state.str.remove(
          /** @type {number} */
          node.start,
          /** @type {number} */
          node.end
        );
      }
      if (illegal_specifiers.length > 0) {
        throw new MigrationError(
          `Can't migrate code with ${illegal_specifiers.join(" and ")}. Please migrate by hand.`
        );
      }
    }
  },
  ExportNamedDeclaration(node, { state, next: next2 }) {
    if (node.declaration) {
      next2();
      return;
    }
    let count_removed = 0;
    for (const specifier of node.specifiers) {
      if (specifier.local.type !== "Identifier") continue;
      const binding = state.scope.get(specifier.local.name);
      if ((binding == null ? void 0 : binding.kind) === "bindable_prop") {
        state.str.remove(
          /** @type {number} */
          specifier.start,
          /** @type {number} */
          specifier.end
        );
        count_removed++;
      }
    }
    if (count_removed === node.specifiers.length) {
      state.str.remove(
        /** @type {number} */
        node.start,
        /** @type {number} */
        node.end
      );
    }
  },
  VariableDeclaration(node, { state, path, visit, next: next2 }) {
    var _a2, _b, _c, _d, _e, _f, _g;
    if (state.scope !== state.analysis.instance.scope) {
      return;
    }
    let nr_of_props = 0;
    for (let i = 0; i < node.declarations.length; i++) {
      let check_rune_binding = function(rune) {
        const has_rune_binding = !!state.scope.get(rune);
        if (has_rune_binding) {
          throw new MigrationError(
            `can't migrate \`${state.str.original.substring(
              /** @type {number} */
              node.start,
              node.end
            )}\` to \`$${rune}\` because there's a variable named ${rune}.
     Rename the variable and try again or migrate by hand.`
          );
        }
      };
      const declarator2 = node.declarations[i];
      if (state.analysis.runes) {
        if (get_rune(declarator2.init, state.scope) === "$props") {
          state.props_insertion_point = /** @type {number} */
          declarator2.id.start + 1;
          state.has_props_rune = true;
        }
        continue;
      }
      let bindings;
      try {
        bindings = state.scope.get_bindings(declarator2);
      } catch (e2) {
        next2();
        continue;
      }
      const has_state = bindings.some((binding) => binding.kind === "state");
      const has_props = bindings.some((binding) => binding.kind === "bindable_prop");
      if (!has_state && !has_props) {
        next2();
        continue;
      }
      if (has_props) {
        nr_of_props++;
        if (declarator2.id.type !== "Identifier") {
          throw new MigrationError(
            "Encountered an export declaration pattern that is not supported for automigration."
          );
        }
        const name = declarator2.id.name;
        const binding = (
          /** @type {Binding} */
          state.scope.get(name)
        );
        if (state.analysis.uses_props && (declarator2.init || binding.updated)) {
          throw new MigrationError(
            "$$props is used together with named props in a way that cannot be automatically migrated."
          );
        }
        const prop2 = state.props.find((prop3) => prop3.exported === (binding.prop_alias || name));
        if (prop2) {
          next2();
          prop2.init = declarator2.init ? state.str.snip(
            /** @type {number} */
            declarator2.init.start,
            /** @type {number} */
            declarator2.init.end
          ).toString() : "";
          prop2.bindable = binding.updated;
          prop2.exported = binding.prop_alias || name;
          prop2.type_only = false;
        } else {
          next2();
          state.props.push({
            local: name,
            exported: binding.prop_alias ? binding.prop_alias : name,
            init: declarator2.init ? state.str.snip(
              /** @type {number} */
              declarator2.init.start,
              /** @type {number} */
              declarator2.init.end
            ).toString() : "",
            optional: !!declarator2.init,
            bindable: binding.updated,
            ...extract_type_and_comment(declarator2, state, path)
          });
        }
        let start = (
          /** @type {number} */
          declarator2.start
        );
        let end = (
          /** @type {number} */
          declarator2.end
        );
        if (node.declarations.length > 1) {
          state.props_insertion_point = /** @type {number} */
          node.end;
          if (i !== 0) {
            start = state.str.original.indexOf(
              ",",
              /** @type {number} */
              node.declarations[i - 1].end
            );
          }
          if (i !== node.declarations.length - 1) {
            if (i === 0) {
              end = /** @type {number} */
              node.declarations[i + 1].start;
            } else {
              end = state.str.original.lastIndexOf(
                ",",
                /** @type {number} */
                node.declarations[i + 1].start
              );
            }
          }
        } else {
          state.props_insertion_point = /** @type {number} */
          declarator2.end;
        }
        state.str.update(start, end, "");
        continue;
      }
      if (declarator2.init) {
        let { start, end } = (
          /** @type {{ start: number, end: number }} */
          declarator2.init
        );
        if (declarator2.init.type === "SequenceExpression") {
          while (state.str.original[start] !== "(") start -= 1;
          while (state.str.original[end - 1] !== ")") end += 1;
        }
        check_rune_binding("state");
        state.str.prependLeft(start, "$state(");
        state.str.appendRight(end, ")");
      } else {
        let assignment_in_labeled;
        let labeled_statement;
        const possible_derived = bindings.every(
          (binding) => binding.references.every((reference) => {
            const declaration2 = reference.path.find((el) => el.type === "VariableDeclaration");
            const assignment2 = reference.path.find((el) => el.type === "AssignmentExpression");
            const update2 = reference.path.find((el) => el.type === "UpdateExpression");
            const labeled2 = (
              /** @type {LabeledStatement | undefined} */
              reference.path.find((el) => el.type === "LabeledStatement" && el.label.name === "$")
            );
            if (assignment2 && labeled2 && // ensure that $: foo = bar * 2 is not counted as a reassignment of bar
            (labeled2.body.type !== "ExpressionStatement" || labeled2.body.expression !== assignment2 || assignment2.left.type === "Identifier" && assignment2.left.name === binding.node.name)) {
              if (assignment_in_labeled) return false;
              assignment_in_labeled = /** @type {AssignmentExpression} */
              assignment2;
              labeled_statement = labeled2;
            }
            return !update2 && (declaration2 && binding.initial || labeled2 && assignment2 || !labeled2 && !assignment2);
          })
        );
        const labeled_has_single_assignment = (labeled_statement == null ? void 0 : labeled_statement.body.type) === "BlockStatement" && labeled_statement.body.body.length === 1 && labeled_statement.body.body[0].type === "ExpressionStatement";
        const is_expression_assignment = (labeled_statement == null ? void 0 : labeled_statement.body.type) === "ExpressionStatement" && labeled_statement.body.expression.type === "AssignmentExpression";
        let should_be_state = false;
        if (is_expression_assignment) {
          const body = (
            /**@type {ExpressionStatement}*/
            labeled_statement == null ? void 0 : labeled_statement.body
          );
          const expression = (
            /**@type {AssignmentExpression}*/
            body.expression
          );
          const [, ids] = extract_all_identifiers_from_expression(expression.right);
          if (ids.length === 0) {
            should_be_state = true;
            state.derived_labeled_statements.add(
              /** @type {LabeledStatement} */
              labeled_statement
            );
          }
        }
        if (!should_be_state && possible_derived && assignment_in_labeled && labeled_statement && (labeled_has_single_assignment || is_expression_assignment)) {
          const indent = state.str.original.substring(
            state.str.original.lastIndexOf(
              "\n",
              /** @type {number} */
              node.start
            ) + 1,
            /** @type {number} */
            node.start
          );
          if (labeled_statement.body.type === "BlockStatement" && labeled_statement.body.body[0].leadingComments) {
            for (let comment of labeled_statement.body.body[0].leadingComments) {
              state.str.prependLeft(
                /** @type {number} */
                node.start,
                comment.type === "Block" ? `/*${comment.value}*/
${indent}` : `// ${comment.value}
${indent}`
              );
            }
          }
          check_rune_binding("derived");
          state.str.appendRight(
            /** @type {number} */
            ((_a2 = declarator2.id.typeAnnotation) == null ? void 0 : _a2.end) ?? declarator2.id.end,
            " = $derived("
          );
          visit(assignment_in_labeled.right);
          state.str.appendRight(
            /** @type {number} */
            ((_b = declarator2.id.typeAnnotation) == null ? void 0 : _b.end) ?? declarator2.id.end,
            state.str.snip(
              /** @type {number} */
              assignment_in_labeled.right.start,
              /** @type {number} */
              assignment_in_labeled.right.end
            ).toString()
          );
          state.str.remove(
            /** @type {number} */
            labeled_statement.start,
            /** @type {number} */
            labeled_statement.end
          );
          state.str.appendRight(
            /** @type {number} */
            ((_c = declarator2.id.typeAnnotation) == null ? void 0 : _c.end) ?? declarator2.id.end,
            ")"
          );
          state.derived_labeled_statements.add(labeled_statement);
          if (labeled_statement.body.type === "BlockStatement" && labeled_statement.body.body[0].trailingComments) {
            for (let comment of labeled_statement.body.body[0].trailingComments) {
              state.str.appendRight(
                /** @type {number} */
                ((_d = declarator2.id.typeAnnotation) == null ? void 0 : _d.end) ?? declarator2.id.end,
                comment.type === "Block" ? `
${indent}/*${comment.value}*/` : `
${indent}// ${comment.value}`
              );
            }
          }
        } else {
          check_rune_binding("state");
          state.str.prependLeft(
            /** @type {number} */
            ((_e = declarator2.id.typeAnnotation) == null ? void 0 : _e.end) ?? declarator2.id.end,
            " = $state("
          );
          if (should_be_state) {
            state.str.appendRight(
              /** @type {number} */
              ((_f = declarator2.id.typeAnnotation) == null ? void 0 : _f.end) ?? declarator2.id.end,
              state.str.snip(
                /** @type {number} */
                /** @type {AssignmentExpression} */
                assignment_in_labeled.right.start,
                /** @type {number} */
                /** @type {AssignmentExpression} */
                assignment_in_labeled.right.end
              ).toString()
            );
            state.str.remove(
              /** @type {number} */
              /** @type {LabeledStatement} */
              labeled_statement.start,
              /** @type {number} */
              /** @type {LabeledStatement} */
              labeled_statement.end
            );
          }
          state.str.appendRight(
            /** @type {number} */
            ((_g = declarator2.id.typeAnnotation) == null ? void 0 : _g.end) ?? declarator2.id.end,
            ")"
          );
        }
      }
    }
    if (nr_of_props === node.declarations.length) {
      let start = (
        /** @type {number} */
        node.start
      );
      let end = (
        /** @type {number} */
        node.end
      );
      const parent = path.at(-1);
      if ((parent == null ? void 0 : parent.type) === "ExportNamedDeclaration") {
        start = /** @type {number} */
        parent.start;
        end = /** @type {number} */
        parent.end;
      }
      while (state.str.original[start] !== "\n") start--;
      while (state.str.original[end] !== "\n") end++;
      state.str.update(start, end, "");
    }
  },
  BreakStatement(node, { state, path }) {
    var _a2;
    if (path[1].type !== "LabeledStatement") return;
    if (((_a2 = node.label) == null ? void 0 : _a2.name) !== "$") return;
    state.str.update(
      /** @type {number} */
      node.start,
      /** @type {number} */
      node.end,
      "return;"
    );
  },
  LabeledStatement(node, { path, state, next: next2 }) {
    if (state.analysis.runes) return;
    if (path.length > 1) return;
    if (node.label.name !== "$") return;
    if (state.derived_labeled_statements.has(node)) return;
    next2();
    function check_rune_binding(rune) {
      const has_rune_binding = state.scope.get(rune);
      if (has_rune_binding) {
        throw new MigrationError(
          `can't migrate \`$: ${state.str.original.substring(
            /** @type {number} */
            node.body.start,
            node.body.end
          )}\` to \`$${rune}\` because there's a variable named ${rune}.
     Rename the variable and try again or migrate by hand.`
        );
      }
    }
    if (node.body.type === "ExpressionStatement" && node.body.expression.type === "AssignmentExpression") {
      const { left, right } = node.body.expression;
      const ids = extract_identifiers(left);
      const [, expression_ids] = extract_all_identifiers_from_expression(right);
      const bindings = ids.map((id2) => (
        /** @type {Binding} */
        state.scope.get(id2.name)
      ));
      if (bindings.every((b) => b.kind === "legacy_reactive")) {
        if (right.type !== "Literal" && bindings.every((b) => b.kind !== "store_sub") && left.type !== "MemberExpression") {
          let { start, end } = (
            /** @type {{ start: number, end: number }} */
            right
          );
          check_rune_binding("derived");
          state.str.update(
            /** @type {number} */
            node.start,
            /** @type {number} */
            node.body.expression.start,
            "let "
          );
          if (right.type === "SequenceExpression") {
            while (state.str.original[start] !== "(") start -= 1;
            while (state.str.original[end - 1] !== ")") end += 1;
          }
          state.str.prependRight(start, `$derived(`);
          if (state.str.original[
            /** @type {number} */
            node.body.start
          ] !== "(") {
            state.str.appendLeft(end, `)`);
          }
          return;
        }
        for (const binding of bindings) {
          if (binding.reassigned && (ids.includes(binding.node) || expression_ids.length === 0)) {
            check_rune_binding("state");
            const init2 = binding.kind === "state" ? " = $state()" : expression_ids.length === 0 ? ` = $state(${state.str.original.substring(
              /** @type {number} */
              right.start,
              right.end
            )})` : "";
            state.str.prependLeft(
              /** @type {number} */
              node.start,
              `let ${binding.node.name}${init2};
${state.indent}`
            );
          }
        }
        if (expression_ids.length === 0 && bindings.every((b) => b.kind !== "store_sub")) {
          state.str.remove(
            /** @type {number} */
            node.start,
            /** @type {number} */
            node.end
          );
          return;
        }
      }
    }
    state.legacy_imports.add("run");
    const is_block_stmt = node.body.type === "BlockStatement";
    const start_end = (
      /** @type {number} */
      node.body.start
    );
    if (is_block_stmt) {
      state.str.update(
        /** @type {number} */
        node.start,
        start_end + 1,
        `${state.names.run}(() => {`
      );
      const end = (
        /** @type {number} */
        node.body.end
      );
      state.str.update(end - 1, end, "});");
    } else {
      state.str.update(
        /** @type {number} */
        node.start,
        start_end,
        `${state.names.run}(() => {
${state.indent}`
      );
      state.str.indent(state.indent, {
        exclude: [
          [
            0,
            /** @type {number} */
            node.body.start
          ],
          [
            /** @type {number} */
            node.body.end,
            state.end
          ]
        ]
      });
      state.str.appendLeft(
        /** @type {number} */
        node.end,
        `
${state.indent}});`
      );
    }
  }
};
function trim_block(state, start, end) {
  const original = state.str.snip(start, end).toString();
  const without_parens = original.substring(1, original.length - 1);
  if (without_parens.trim().length !== without_parens.length) {
    state.str.update(start + 1, end - 1, without_parens.trim());
  }
}
var template2 = {
  Identifier(node, { state, path }) {
    handle_identifier(node, state, path);
  },
  RegularElement(node, { state, path, next: next2 }) {
    migrate_slot_usage(node, path, state);
    handle_events(node, state);
    const node_name = node.name.replace(/[a-zA-Z-]*:/g, "");
    if (state.analysis.source[node.end - 2] === "/" && !is_void(node_name) && !is_svg(node_name)) {
      let trimmed_position = node.end - 2;
      while (state.str.original.charAt(trimmed_position - 1) === " ") trimmed_position--;
      state.str.remove(trimmed_position, node.end - 1);
      state.str.appendRight(node.end, `</${node.name}>`);
    }
    next2();
  },
  SvelteSelf(node, { state, next: next2 }) {
    const source2 = state.str.original.substring(node.start, node.end);
    if (!state.filename) {
      const indent = guess_indent(source2);
      has_migration_task = true;
      state.str.prependRight(
        node.start,
        `<!-- @migration-task: svelte:self is deprecated, import this Svelte file into itself instead -->
${indent}`
      );
      next2();
      return;
    }
    state.str.overwrite(
      node.start + 1,
      node.start + 1 + "svelte:self".length,
      `${state.analysis.name}`
    );
    if (node.fragment.nodes.length > 0) {
      state.str.overwrite(
        state.str.original.lastIndexOf("<", node.end) + 2,
        node.end - 1,
        `${state.analysis.name}`
      );
    } else if (!source2.endsWith("/>")) {
      state.str.overwrite(
        node.start + source2.lastIndexOf("</", node.end) + 2,
        node.end - 1,
        `${state.analysis.name}`
      );
    }
    state.has_svelte_self = true;
    next2();
  },
  SvelteElement(node, { state, path, next: next2 }) {
    migrate_slot_usage(node, path, state);
    if (node.tag.type === "Literal") {
      let is_static = true;
      let a = (
        /** @type {number} */
        node.tag.start
      );
      let b = (
        /** @type {number} */
        node.tag.end
      );
      let quote_mark = state.str.original[a - 1];
      while (state.str.original[--a] !== "=") {
        if (state.str.original[a] === "{") {
          is_static = false;
          break;
        }
      }
      if (is_static && state.str.original[b] === quote_mark) {
        state.str.prependLeft(a + 1, "{");
        state.str.appendRight(
          /** @type {number} */
          node.tag.end + 1,
          "}"
        );
      }
    }
    handle_events(node, state);
    next2();
  },
  Component(node, { state, path, next: next2 }) {
    next2();
    migrate_slot_usage(node, path, state);
  },
  SvelteComponent(node, { state, next: next2, path }) {
    next2();
    migrate_slot_usage(node, path, state);
    let expression = state.str.snip(
      /** @type {number} */
      node.expression.start,
      /** @type {number} */
      node.expression.end
    ).toString();
    if (node.expression.type !== "Identifier" && node.expression.type !== "MemberExpression" || !regex_valid_component_name.test(expression)) {
      let current_expression = expression;
      expression = state.scope.generate("SvelteComponent");
      let needs_derived = true;
      for (let i = path.length - 1; i >= 0; i--) {
        const part = path[i];
        if (part.type === "EachBlock" || part.type === "AwaitBlock" || part.type === "IfBlock" || part.type === "SnippetBlock" || part.type === "Component" || part.type === "SvelteComponent") {
          let position = node.start;
          if (i !== path.length - 1) {
            for (let modifier = 1; modifier < path.length - i; modifier++) {
              const path_part = path[i + modifier];
              if ("start" in path_part) {
                position = /** @type {number} */
                path_part.start;
                break;
              }
            }
          }
          const indent = state.str.original.substring(
            state.str.original.lastIndexOf("\n", position) + 1,
            position
          );
          state.str.appendRight(
            position,
            `{@const ${expression} = ${current_expression}}
${indent}`
          );
          needs_derived = false;
          break;
        }
      }
      if (needs_derived) {
        if (state.derived_components.has(current_expression)) {
          expression = /** @type {string} */
          state.derived_components.get(current_expression);
        } else {
          state.derived_components.set(current_expression, expression);
        }
      }
    }
    state.str.overwrite(node.start + 1, node.start + node.name.length + 1, expression);
    if (state.str.original.substring(node.end - node.name.length - 1, node.end - 1) === node.name) {
      state.str.overwrite(node.end - node.name.length - 1, node.end - 1, expression);
    }
    let this_pos = state.str.original.lastIndexOf("this", node.expression.start);
    while (!state.str.original.charAt(this_pos - 1).trim()) this_pos--;
    const end_pos = state.str.original.indexOf("}", node.expression.end) + 1;
    state.str.remove(this_pos, end_pos);
  },
  SvelteFragment(node, { state, path, next: next2 }) {
    migrate_slot_usage(node, path, state);
    next2();
  },
  SvelteWindow(node, { state, next: next2 }) {
    handle_events(node, state);
    next2();
  },
  SvelteBody(node, { state, next: next2 }) {
    handle_events(node, state);
    next2();
  },
  SvelteDocument(node, { state, next: next2 }) {
    handle_events(node, state);
    next2();
  },
  SlotElement(node, { state, path, next: next2, visit }) {
    migrate_slot_usage(node, path, state);
    if (state.analysis.custom_element) return;
    let name = "children";
    let slot_name = "default";
    let slot_props = "{ ";
    let aliased_slot_name;
    for (const attr of node.attributes) {
      if (attr.type === "SpreadAttribute") {
        slot_props += `...${state.str.original.substring(
          /** @type {number} */
          attr.expression.start,
          attr.expression.end
        )}, `;
      } else if (attr.type === "Attribute") {
        if (attr.name === "slot") {
          continue;
        }
        if (attr.name === "name") {
          slot_name = /** @type {any} */
          attr.value[0].data;
          if (path.some(
            (parent) => (parent.type === "RegularElement" || parent.type === "SvelteElement" || parent.type === "Component" || parent.type === "SvelteComponent" || parent.type === "SvelteFragment") && parent.attributes.some(
              (attribute) => attribute.type === "Attribute" && attribute.name === "slot" && is_text_attribute(attribute) && attribute.value[0].data === slot_name
            )
          ) || node.attributes.some(
            (attribute) => attribute.type === "Attribute" && attribute.name === "slot" && is_text_attribute(attribute) && attribute.value[0].data === slot_name
          )) {
            aliased_slot_name = `${slot_name}_render`;
            state.derived_conflicting_slots.set(aliased_slot_name, slot_name);
          }
        } else {
          const attr_value = attr.value === true || Array.isArray(attr.value) ? attr.value : [attr.value];
          let value = "true";
          if (attr_value !== true) {
            const first = attr_value[0];
            const last = attr_value[attr_value.length - 1];
            for (const attr2 of attr_value) {
              visit(attr2);
            }
            value = state.str.snip(
              first.type === "Text" ? first.start - 1 : (
                /** @type {number} */
                first.expression.start
              ),
              last.type === "Text" ? last.end + 1 : (
                /** @type {number} */
                last.expression.end
              )
            ).toString();
          }
          slot_props += value === attr.name ? `${value}, ` : `${attr.name}: ${value}, `;
        }
      }
    }
    slot_props += "}";
    if (slot_props === "{ }") {
      slot_props = "";
    }
    const existing_prop = state.props.find((prop2) => prop2.slot_name === slot_name);
    if (existing_prop) {
      name = existing_prop.local;
    } else if (slot_name !== "default") {
      name = state.scope.generate(slot_name);
      if (name !== slot_name) {
        throw new MigrationError(
          `This migration would change the name of a slot (${slot_name} to ${name}) making the component unusable`
        );
      }
    }
    if (!existing_prop) {
      state.props.push({
        local: name,
        exported: name,
        init: "",
        bindable: false,
        optional: true,
        slot_name,
        type: `import('svelte').${slot_props ? "Snippet<[any]>" : "Snippet"}`
      });
    } else if (existing_prop.needs_refine_type) {
      existing_prop.type = `import('svelte').${slot_props ? "Snippet<[any]>" : "Snippet"}`;
      existing_prop.needs_refine_type = false;
    }
    if (slot_name === "default" && path.some(
      (parent) => (parent.type === "SvelteComponent" || parent.type === "Component" || parent.type === "RegularElement" || parent.type === "SvelteElement" || parent.type === "SvelteFragment") && parent.attributes.some((attr) => attr.type === "LetDirective")
    )) {
      aliased_slot_name = `${name}_render`;
      state.derived_conflicting_slots.set(aliased_slot_name, name);
    }
    name = aliased_slot_name ?? name;
    if (node.fragment.nodes.length > 0) {
      next2();
      state.str.update(
        node.start,
        node.fragment.nodes[0].start,
        `{#if ${name}}{@render ${state.analysis.uses_props ? `${state.names.props}.` : ""}${name}(${slot_props})}{:else}`
      );
      state.str.update(node.fragment.nodes[node.fragment.nodes.length - 1].end, node.end, "{/if}");
    } else {
      state.str.update(
        node.start,
        node.end,
        `{@render ${state.analysis.uses_props ? `${state.names.props}.` : ""}${name}?.(${slot_props})}`
      );
    }
  },
  Comment(node, { state }) {
    const migrated = migrate_svelte_ignore(node.data);
    if (migrated !== node.data) {
      state.str.overwrite(node.start + "<!--".length, node.end - "-->".length, migrated);
    }
  },
  HtmlTag(node, { state, next: next2 }) {
    trim_block(state, node.start, node.end);
    next2();
  },
  ConstTag(node, { state, next: next2 }) {
    trim_block(state, node.start, node.end);
    next2();
  },
  IfBlock(node, { state, next: next2 }) {
    const start = node.start;
    const end = state.str.original.indexOf("}", node.test.end) + 1;
    trim_block(state, start, end);
    next2();
  },
  AwaitBlock(node, { state, next: next2 }) {
    var _a2, _b, _c, _d, _e;
    const start = node.start;
    const end = state.str.original.indexOf(
      "}",
      node.pending !== null ? node.expression.end : (_a2 = node.value) == null ? void 0 : _a2.end
    ) + 1;
    trim_block(state, start, end);
    if (node.pending !== null) {
      const start2 = state.str.original.lastIndexOf("{", (_b = node.value) == null ? void 0 : _b.start);
      const end2 = state.str.original.indexOf("}", (_c = node.value) == null ? void 0 : _c.end) + 1;
      trim_block(state, start2, end2);
    }
    if (node.catch !== null) {
      const start2 = state.str.original.lastIndexOf("{", (_d = node.error) == null ? void 0 : _d.start);
      const end2 = state.str.original.indexOf("}", (_e = node.error) == null ? void 0 : _e.end) + 1;
      trim_block(state, start2, end2);
    }
    next2();
  },
  KeyBlock(node, { state, next: next2 }) {
    const start = node.start;
    const end = state.str.original.indexOf("}", node.expression.end) + 1;
    trim_block(state, start, end);
    next2();
  }
};
function migrate_slot_usage(node, path, state) {
  const parent = path.at(-2);
  if ((parent == null ? void 0 : parent.type) !== "Component" && (parent == null ? void 0 : parent.type) !== "SvelteComponent" && node.type !== "Component" && node.type !== "SvelteComponent") {
    return;
  }
  let snippet_name = "children";
  let snippet_props = [];
  let removal_queue = [];
  for (let attribute of node.attributes) {
    if (attribute.type === "Attribute" && attribute.name === "slot" && is_text_attribute(attribute)) {
      snippet_name = attribute.value[0].data;
      if (snippet_name === "default") {
        snippet_name = "children";
      }
      if (!regex_is_valid_identifier.test(snippet_name) || is_reserved(snippet_name)) {
        has_migration_task = true;
        state.str.appendLeft(
          node.start,
          `<!-- @migration-task: migrate this slot by hand, \`${snippet_name}\` is an invalid identifier -->
${state.indent}`
        );
        return;
      }
      if ((parent == null ? void 0 : parent.type) === "Component" || (parent == null ? void 0 : parent.type) === "SvelteComponent") {
        for (let attribute2 of parent.attributes) {
          if (attribute2.type === "Attribute" || attribute2.type === "BindDirective") {
            if (attribute2.name === snippet_name) {
              state.str.appendLeft(
                node.start,
                `<!-- @migration-task: migrate this slot by hand, \`${snippet_name}\` would shadow a prop on the parent component -->
${state.indent}`
              );
              return;
            }
          }
        }
      }
      for (let remove_let of removal_queue) {
        remove_let();
      }
      state.str.remove(attribute.start, attribute.end);
    }
    if (attribute.type === "LetDirective") {
      snippet_props.push(
        attribute.name + (attribute.expression ? `: ${state.str.original.substring(
          /** @type {number} */
          attribute.expression.start,
          /** @type {number} */
          attribute.expression.end
        )}` : "")
      );
      removal_queue.push(() => state.str.remove(attribute.start, attribute.end));
    }
  }
  if (removal_queue.length > 0) {
    for (let remove_let of removal_queue) {
      remove_let();
    }
  }
  if (node.type === "SvelteFragment" && node.fragment.nodes.length > 0) {
    state.str.remove(node.start, node.fragment.nodes[0].start);
    state.str.remove(node.fragment.nodes[node.fragment.nodes.length - 1].end, node.end);
  }
  const props = snippet_props.length > 0 ? `{ ${snippet_props.join(", ")} }` : "";
  if (snippet_name === "children" && node.type !== "SvelteFragment") {
    if (snippet_props.length === 0) return;
    let inner_start = 0;
    let inner_end = 0;
    for (let i = 0; i < node.fragment.nodes.length; i++) {
      const inner = node.fragment.nodes[i];
      const is_empty_text = inner.type === "Text" && !inner.data.trim();
      if ((inner.type === "RegularElement" || inner.type === "SvelteElement" || inner.type === "Component" || inner.type === "SvelteComponent" || inner.type === "SlotElement" || inner.type === "SvelteFragment") && inner.attributes.some((attr) => attr.type === "Attribute" && attr.name === "slot")) {
        if (inner_start && !inner_end) {
          inner_end = inner.start;
        }
      } else if (!inner_start && !is_empty_text) {
        inner_start = inner.start;
      } else if (inner_end && !is_empty_text) {
        state.str.update(inner_end - 1, inner_end, "");
        state.str.prependLeft(inner_end - 1, state.str.original[inner_end - 1]);
        state.str.move(inner.start, inner.end, inner_end - 1);
      }
    }
    if (!inner_end) {
      inner_end = node.fragment.nodes[node.fragment.nodes.length - 1].end;
    }
    state.str.appendLeft(
      inner_start,
      `{#snippet ${snippet_name}(${props})}
${state.indent.repeat(path.length)}`
    );
    state.str.indent(state.indent, {
      exclude: [
        [0, inner_start],
        [inner_end, state.str.original.length]
      ]
    });
    if (inner_end < node.fragment.nodes[node.fragment.nodes.length - 1].end) {
      state.str.prependLeft(inner_end, `{/snippet}
${state.indent.repeat(path.length)}`);
    } else {
      state.str.prependLeft(
        inner_end,
        `${state.indent.repeat(path.length)}{/snippet}
${state.indent.repeat(path.length - 1)}`
      );
    }
  } else {
    state.str.prependLeft(
      node.start,
      `{#snippet ${snippet_name}(${props})}
${state.indent.repeat(path.length - 2)}`
    );
    state.str.indent(state.indent, {
      exclude: [
        [0, node.start],
        [node.end, state.str.original.length]
      ]
    });
    const str = `
${state.indent.repeat(path.length - 2)}{/snippet}`;
    if (node.type === "SlotElement") {
      state.str.appendRight(node.end, str);
    } else {
      state.str.appendLeft(node.end, str);
    }
  }
}
function extract_type_and_comment(declarator2, state, path) {
  var _a2, _b, _c, _d;
  const str = state.str;
  const parent = path.at(-1);
  let comment_node = (
    /** @type {Node} */
    (_a2 = parent == null ? void 0 : parent.leadingComments) == null ? void 0 : _a2.at(-1)
  );
  const comment_start = (
    /** @type {any} */
    comment_node == null ? void 0 : comment_node.start
  );
  const comment_end = (
    /** @type {any} */
    comment_node == null ? void 0 : comment_node.end
  );
  let comment = comment_node && str.original.substring(comment_start, comment_end);
  if (comment_node) {
    str.update(comment_start, comment_end, "");
  }
  const trailing_comment_node = (
    /** @type {Node} */
    (_b = parent == null ? void 0 : parent.trailingComments) == null ? void 0 : _b.at(0)
  );
  const trailing_comment_start = (
    /** @type {any} */
    trailing_comment_node == null ? void 0 : trailing_comment_node.start
  );
  const trailing_comment_end = (
    /** @type {any} */
    trailing_comment_node == null ? void 0 : trailing_comment_node.end
  );
  let trailing_comment = trailing_comment_node && str.original.substring(trailing_comment_start, trailing_comment_end);
  if (trailing_comment_node) {
    str.update(trailing_comment_start, trailing_comment_end, "");
  }
  if (declarator2.id.typeAnnotation) {
    state.has_type_or_fallback = true;
    let start = declarator2.id.typeAnnotation.start + 1;
    while (str.original[start] === " ") {
      start++;
    }
    return {
      type: str.original.substring(start, declarator2.id.typeAnnotation.end),
      comment,
      trailing_comment
    };
  }
  let cleaned_comment_arr = comment == null ? void 0 : comment.split("\n").map(
    (line) => line.trim().replace(/^\/\/\s*/g, "").replace(/^\/\*\*?\s*/g, "").replace(/\s*\*\/$/g, "").replace(/^\*\s*/g, "")
  ).filter(Boolean);
  const first_at_comment = cleaned_comment_arr == null ? void 0 : cleaned_comment_arr.findIndex((line) => line.startsWith("@"));
  let cleaned_comment = cleaned_comment_arr == null ? void 0 : cleaned_comment_arr.slice(0, first_at_comment !== -1 ? first_at_comment : cleaned_comment_arr.length).join("\n");
  let cleaned_comment_arr_trailing = trailing_comment == null ? void 0 : trailing_comment.split("\n").map(
    (line) => line.trim().replace(/^\/\/\s*/g, "").replace(/^\/\*\*?\s*/g, "").replace(/\s*\*\/$/g, "").replace(/^\*\s*/g, "")
  ).filter(Boolean);
  const first_at_comment_trailing = cleaned_comment_arr_trailing == null ? void 0 : cleaned_comment_arr_trailing.findIndex(
    (line) => line.startsWith("@")
  );
  let cleaned_comment_trailing = cleaned_comment_arr_trailing == null ? void 0 : cleaned_comment_arr_trailing.slice(
    0,
    first_at_comment_trailing !== -1 ? first_at_comment_trailing : cleaned_comment_arr_trailing.length
  ).join("\n");
  if ((parent == null ? void 0 : parent.type) === "ExportNamedDeclaration" && comment_node) {
    state.has_type_or_fallback = true;
    const match = /@type {(.+)}/.exec(comment_node.value);
    if (match) {
      const jsdoc_comment = /@type {.+} (?:\w+|\[.*?\]) - (.+)/.exec(comment_node.value);
      if (jsdoc_comment) {
        cleaned_comment += (_c = jsdoc_comment[1]) == null ? void 0 : _c.trim();
      }
      return {
        type: match[1],
        comment: cleaned_comment,
        trailing_comment: cleaned_comment_trailing
      };
    }
  }
  if (((_d = declarator2.init) == null ? void 0 : _d.type) === "Literal") {
    state.has_type_or_fallback = true;
    const type = typeof declarator2.init.value;
    if (type === "string" || type === "number" || type === "boolean") {
      return {
        type,
        comment: state.uses_ts ? comment : cleaned_comment,
        trailing_comment: state.uses_ts ? trailing_comment : cleaned_comment_trailing
      };
    }
  }
  return {
    type: "any",
    comment: state.uses_ts ? comment : cleaned_comment,
    trailing_comment: state.uses_ts ? trailing_comment : cleaned_comment_trailing
  };
}
var modifier_order = [
  "preventDefault",
  "stopPropagation",
  "stopImmediatePropagation",
  "self",
  "trusted",
  "once"
];
function handle_events(element2, state) {
  const handlers = /* @__PURE__ */ new Map();
  for (const attribute of element2.attributes) {
    if (attribute.type !== "OnDirective") continue;
    let name = `on${attribute.name}`;
    if (attribute.modifiers.includes("capture")) {
      name += "capture";
    }
    const nodes = handlers.get(name) || [];
    nodes.push(attribute);
    handlers.set(name, nodes);
  }
  for (const [name, nodes] of handlers) {
    const handlers2 = [];
    let first = null;
    for (const node of nodes) {
      let body;
      if (node.expression) {
        body = state.str.original.substring(
          /** @type {number} */
          node.expression.start,
          /** @type {number} */
          node.expression.end
        );
      } else {
        body = `${state.names.bubble}('${node.name}')`;
        state.legacy_imports.add("createBubbler");
        state.script_insertions.add(
          `const ${state.names.bubble} = ${state.names.createBubbler}();`
        );
      }
      const has_passive = node.modifiers.includes("passive");
      const has_nonpassive = node.modifiers.includes("nonpassive");
      const modifiers2 = modifier_order.filter((modifier) => node.modifiers.includes(modifier));
      for (const modifier of modifiers2) {
        state.legacy_imports.add(modifier);
        body = `${state.names[modifier]}(${body})`;
      }
      if (has_passive || has_nonpassive) {
        const action = has_passive ? "passive" : "nonpassive";
        state.legacy_imports.add(action);
        state.str.overwrite(
          node.start,
          node.end,
          `use:${state.names[action]}={['${node.name}', () => ${body}]}`
        );
      } else {
        if (first) {
          let start = node.start;
          let end = node.end;
          while (/[\s\n]/.test(state.str.original[start - 1])) start -= 1;
          state.str.remove(start, end);
        } else {
          first = node;
        }
        handlers2.push(body);
      }
    }
    if (first) {
      let replacement;
      if (handlers2.length > 1) {
        state.legacy_imports.add("handlers");
        replacement = `${name}={${state.names.handlers}(${handlers2.join(", ")})}`;
      } else {
        const handler = handlers2[0];
        replacement = handler === name ? `{${handler}}` : `${name}={${handler}}`;
      }
      state.str.overwrite(first.start, first.end, replacement);
    }
  }
}
function get_node_range(source2, node) {
  var _a2, _b;
  const first_leading_comment = (_a2 = node.leadingComments) == null ? void 0 : _a2[0];
  const last_trailing_comment = (_b = node.trailingComments) == null ? void 0 : _b[node.trailingComments.length - 1];
  let start = (
    /** @type {number} */
    (first_leading_comment == null ? void 0 : first_leading_comment.start) ?? node.start
  );
  let end = (
    /** @type {number} */
    (last_trailing_comment == null ? void 0 : last_trailing_comment.end) ?? node.end
  );
  let idx = start;
  while (source2[idx - 1] !== "\n" && source2[idx - 1] !== "\r") {
    idx--;
    if (source2[idx] !== " " && source2[idx] !== "	") {
      idx = start;
      break;
    }
  }
  start = idx;
  return { start, end };
}
function handle_identifier(node, state, path) {
  var _a2, _b, _c, _d;
  const parent = path.at(-1);
  if ((parent == null ? void 0 : parent.type) === "MemberExpression" && parent.property === node) return;
  if (state.analysis.uses_props && node.name !== "$$slots") {
    if (node.name === "$$props" || node.name === "$$restProps") {
      state.str.update(
        /** @type {number} */
        node.start,
        /** @type {number} */
        node.end,
        state.names.props
      );
    } else {
      const binding = state.scope.get(node.name);
      if ((binding == null ? void 0 : binding.kind) === "bindable_prop" && binding.node !== node) {
        state.str.prependLeft(
          /** @type {number} */
          node.start,
          `${state.names.props}.`
        );
      }
    }
  } else if (node.name === "$$restProps" && state.analysis.uses_rest_props) {
    state.str.update(
      /** @type {number} */
      node.start,
      /** @type {number} */
      node.end,
      state.names.rest
    );
  } else if (node.name === "$$slots" && state.analysis.uses_slots) {
    if ((parent == null ? void 0 : parent.type) === "MemberExpression") {
      if (state.analysis.custom_element) return;
      let name = parent.property.type === "Literal" ? parent.property.value : parent.property.name;
      let slot_name = name;
      const existing_prop = state.props.find((prop2) => prop2.slot_name === name);
      if (existing_prop) {
        name = existing_prop.local;
      } else if (name !== "default") {
        let new_name = state.scope.generate(name);
        if (new_name !== name) {
          throw new MigrationError(
            `This migration would change the name of a slot (${name} to ${new_name}) making the component unusable`
          );
        }
      }
      name = name === "default" ? "children" : name;
      if (!existing_prop) {
        state.props.push({
          local: name,
          exported: name,
          init: "",
          bindable: false,
          optional: true,
          slot_name,
          // if it's the first time we encounter this slot
          // we start with any and delegate to when the slot
          // is actually rendered (it might not happen in that case)
          // any is still a safe bet
          type: `import('svelte').Snippet<[any]>`,
          needs_refine_type: true
        });
      }
      state.str.update(
        /** @type {number} */
        node.start,
        parent.property.start,
        state.analysis.uses_props ? `${state.names.props}.` : ""
      );
      state.str.update(parent.property.start, parent.end, name);
    }
  } else if ((parent == null ? void 0 : parent.type) === "TSInterfaceDeclaration" || (parent == null ? void 0 : parent.type) === "TSTypeAliasDeclaration") {
    const members = parent.type === "TSInterfaceDeclaration" ? parent.body.body : (_a2 = parent.typeAnnotation) == null ? void 0 : _a2.members;
    if (Array.isArray(members)) {
      if (node.name === "$$Props") {
        state.has_type_or_fallback = true;
        for (const member2 of members) {
          const prop2 = state.props.find((prop3) => prop3.exported === member2.key.name);
          const type = state.str.original.substring(
            member2.typeAnnotation.typeAnnotation.start,
            member2.typeAnnotation.typeAnnotation.end
          );
          let comment;
          const comment_node = (_b = member2.leadingComments) == null ? void 0 : _b.at(-1);
          if ((comment_node == null ? void 0 : comment_node.type) === "Block") {
            comment = state.str.original.substring(comment_node.start, comment_node.end);
          }
          const trailing_comment = (_d = (_c = member2.trailingComments) == null ? void 0 : _c.at(0)) == null ? void 0 : _d.value;
          if (prop2) {
            prop2.type = type;
            prop2.optional = member2.optional;
            prop2.comment = comment ?? prop2.comment;
            prop2.trailing_comment = trailing_comment ?? prop2.trailing_comment;
          } else {
            state.props.push({
              local: member2.key.name,
              exported: member2.key.name,
              init: "",
              bindable: false,
              optional: member2.optional,
              type,
              comment,
              trailing_comment,
              type_only: true
            });
          }
        }
        state.str.remove(parent.start, parent.end);
      }
    }
  }
}
function guess_indent(content) {
  const lines = content.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return "	";
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current) => {
    var _a2;
    const count = ((_a2 = /^ +/.exec(current)) == null ? void 0 : _a2[0].length) ?? 0;
    return Math.min(count, previous);
  }, Infinity);
  return " ".repeat(min);
}

// node_modules/svelte/src/compiler/index.js
function compile(source2, options) {
  source2 = remove_bom(source2);
  reset_warning_filter(options.warningFilter);
  const validated = validate_component_options(options, "");
  reset(source2, validated);
  let parsed = parse2(source2);
  const { customElement: customElementOptions, ...parsed_options } = parsed.options || {};
  const combined_options = {
    ...validated,
    ...parsed_options,
    customElementOptions
  };
  if (parsed.metadata.ts) {
    parsed = {
      ...parsed,
      fragment: parsed.fragment && remove_typescript_nodes(parsed.fragment),
      instance: parsed.instance && remove_typescript_nodes(parsed.instance),
      module: parsed.module && remove_typescript_nodes(parsed.module)
    };
  }
  const analysis = analyze_component(parsed, source2, combined_options);
  const result = transform_component(analysis, source2, combined_options);
  result.ast = to_public_ast(source2, parsed, options.modernAst);
  return result;
}
function compileModule(source2, options) {
  source2 = remove_bom(source2);
  reset_warning_filter(options.warningFilter);
  const validated = validate_module_options(options, "");
  reset(source2, validated);
  const analysis = analyze_module(parse(source2, false), validated);
  return transform_module(analysis, source2, validated);
}
function parse3(source2, { filename: filename2, rootDir, modern, loose } = {}) {
  source2 = remove_bom(source2);
  reset_warning_filter(() => false);
  reset(source2, { filename: filename2 ?? "(unknown)", rootDir });
  const ast = parse2(source2, loose);
  return to_public_ast(source2, ast, modern);
}
function to_public_ast(source2, ast, modern) {
  var _a2;
  if (modern) {
    const clean = (node) => {
      delete node.metadata;
    };
    (_a2 = ast.options) == null ? void 0 : _a2.attributes.forEach((attribute) => {
      clean(attribute);
      clean(attribute.value);
      if (Array.isArray(attribute.value)) {
        attribute.value.forEach(clean);
      }
    });
    return walk(ast, null, {
      _(node, { next: next2 }) {
        clean(node);
        next2();
      }
    });
  }
  return convert(source2, ast);
}
function remove_bom(source2) {
  if (source2.charCodeAt(0) === 65279) {
    return source2.slice(1);
  }
  return source2;
}
function walk2() {
  throw new Error(
    `'svelte/compiler' no longer exports a \`walk\` utility — please import it directly from 'estree-walker' instead`
  );
}
export {
  VERSION,
  compile,
  compileModule,
  migrate,
  parse3 as parse,
  preprocess,
  walk2 as walk
};
//# sourceMappingURL=svelte_compiler.js.map
